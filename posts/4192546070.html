<!DOCTYPE html><html lang="zh-CN"><head><style type="text/css">.douban-card-block{display:flex;justify-content:center;align-items:center;width:100%;max-height:400px}.douban-card{display:flex;margin:30px 10px;padding:15px;border-radius:15px;position:relative;justify-content:center;align-items:center;overflow:hidden;color:#faebd7;text-decoration:none}.douban-card:hover{text-decoration:none}.douban-card-bgimg{position:absolute;width:115%;height:115%;filter:blur(15px) brightness(.6);background-size:100%;background-position:center;background-repeat:no-repeat}.douban-card-img{position:relative;height:130px;width:80px;background-size:100%;background-position:center;background-repeat:no-repeat}.douban-card-left:hover .douban-card-img{filter:blur(5px) brightness(.6);transform:perspective(800px) rotateX(180deg)}.douban-card-left .douban-card-img{transition:all .5s ease}.douban-card-left{position:relative;display:flex;flex-direction:column;align-items:center}.douban-card-left .douban-card-status{height:130px;width:80px;text-align:center;font-weight:700;position:absolute;left:0;top:30%;transform:rotateX(180deg);backface-visibility:hidden;transition:all .5s ease}.douban-card-left:hover .douban-card-status{transform:perspective(800px) rotateX(0)}.douban-card-right{position:relative;display:flex;flex-direction:column;margin-left:12px;font-size:16px;font-family:"Courier New",Courier,monospace;line-height:1.3;color:#faebd7}.douban-card-item{margin-top:4px}</style><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Roboto+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=PT+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.shaogui.life","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat","show_result":true},"fold":{"enable":true,"height":200},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="图像因为相机或拍摄存在噪声、缺失和抖动问题，导致成像有噪点、不清晰，如果噪声和抖动是有规律的，那么可以通过特定的方法去除这些干扰，复原或修复图像"><meta property="og:type" content="article"><meta property="og:title" content="E01 - 图像复原与重建"><meta property="og:url" content="https://www.shaogui.life/posts/4192546070.html"><meta property="og:site_name" content="年轻人起来冲"><meta property="og:description" content="图像因为相机或拍摄存在噪声、缺失和抖动问题，导致成像有噪点、不清晰，如果噪声和抖动是有规律的，那么可以通过特定的方法去除这些干扰，复原或修复图像"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121410630.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121410955.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121410523.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121410872.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121410165.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411263.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411697.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411122.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411398.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411720.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411493.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411738.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411678.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411656.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411194.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412658.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412517.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412392.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412736.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412437.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412938.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412100.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412913.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412732.png"><meta property="og:image" content="https://www.shaogui.life/posts/07-%E5%9B%BE%E5%83%8F%E5%A4%8D%E5%8E%9F%E4%B8%8E%E9%87%8D%E5%BB%BA-20230704211030.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412476.png"><meta property="article:published_time" content="2022-06-15T00:09:17.000Z"><meta property="article:modified_time" content="2025-01-18T11:05:43.934Z"><meta property="article:author" content="Shaogui"><meta property="article:tag" content="opencv"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121410630.png"><link rel="canonical" href="https://www.shaogui.life/posts/4192546070.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.shaogui.life/posts/4192546070.html","path":"posts/4192546070.html","title":"E01 - 图像复原与重建"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>E01 - 图像复原与重建 | 年轻人起来冲</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><link rel="alternate" href="/atom.xml" title="年轻人起来冲" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">年轻人起来冲</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">77</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">70</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">544</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE%E5%83%8F%E5%99%AA%E5%A3%B0"><span class="nav-number">1.</span> <span class="nav-text">什么是图像噪声？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A0%E6%80%A7%E5%99%AA%E5%A3%B0"><span class="nav-number">2.</span> <span class="nav-text">什么是加性噪声？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%98%E6%80%A7%E5%99%AA%E5%A3%B0"><span class="nav-number">3.</span> <span class="nav-text">什么是乘性噪声？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0"><span class="nav-number">4.</span> <span class="nav-text">什么是高斯噪声？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%91%9E%E5%88%A9%E5%99%AA%E5%A3%B0"><span class="nav-number">5.</span> <span class="nav-text">什么是瑞利噪声？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%88%B1%E5%B0%94%E5%85%B0%E5%99%AA%E5%A3%B0"><span class="nav-number">6.</span> <span class="nav-text">什么是爱尔兰噪声？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E6%95%B0%E5%99%AA%E5%A3%B0"><span class="nav-number">7.</span> <span class="nav-text">什么是指数噪声？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9D%87%E5%8C%80%E5%99%AA%E5%A3%B0"><span class="nav-number">8.</span> <span class="nav-text">什么是均匀噪声？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A4%92%E7%9B%90%E5%99%AA%E5%A3%B0"><span class="nav-number">9.</span> <span class="nav-text">什么是椒盐噪声？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%8A%E6%9D%BE%E5%99%AA%E5%A3%B0"><span class="nav-number">10.</span> <span class="nav-text">什么是泊松噪声？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%99%AA%E5%A3%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%9C%BA%E6%99%AF"><span class="nav-number">11.</span> <span class="nav-text">常见噪声的模拟场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%9C%AF%E5%B9%B3%E5%9D%87%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">12.</span> <span class="nav-text">什么是算术平均滤波器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%A0%E4%BD%95%E5%B9%B3%E5%9D%87%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">13.</span> <span class="nav-text">什么是几何平均滤波器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B0%90%E6%B3%A2%E5%B9%B3%E5%9D%87%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">14.</span> <span class="nav-text">什么是谐波平均滤波器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E8%B0%90%E6%B3%A2%E5%B9%B3%E5%9D%87%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">15.</span> <span class="nav-text">什么是反谐波平均滤波器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%9F%E8%AE%A1%E6%8E%92%E5%BA%8F%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">16.</span> <span class="nav-text">什么是统计排序滤波器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%AE%E6%AD%A3%E9%98%BF%E5%B0%94%E6%B3%95%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">17.</span> <span class="nav-text">什么是修正阿尔法均值滤波器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E9%80%82%E5%BA%94%E5%B1%80%E9%83%A8%E9%99%8D%E5%99%AA%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">18.</span> <span class="nav-text">什么是自适应局部降噪滤波器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E9%80%82%E5%BA%94%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="nav-number">19.</span> <span class="nav-text">什么是自适应中值滤波器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE%E5%83%8F%E5%A4%8D%E5%8E%9F"><span class="nav-number">20.</span> <span class="nav-text">什么是图像复原？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A%E9%80%80%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="nav-number">21.</span> <span class="nav-text">运动模糊退化模型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B9%8D%E6%B5%81%E6%A8%A1%E7%B3%8A%E9%80%80%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="nav-number">22.</span> <span class="nav-text">湍流模糊退化模型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B9%8D%E6%B5%81%E6%A8%A1%E7%B3%8A%E9%80%80%E5%8C%96%E5%9B%BE%E5%83%8F%E7%9A%84%E9%80%86%E6%BB%A4%E6%B3%A2"><span class="nav-number">23.</span> <span class="nav-text">湍流模糊退化图像的逆滤波？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%80%E5%8C%96%E5%9B%BE%E5%83%8F%E7%9A%84%E7%BB%B4%E7%BA%B3%E6%BB%A4%E6%B3%A2wiener-filter"><span class="nav-number">24.</span> <span class="nav-text">退化图像的维纳滤波（Wiener filter）?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%96%B9%E6%BB%A4%E6%B3%A2"><span class="nav-number">25.</span> <span class="nav-text">约束最小二乘方滤波？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E4%BD%95%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="nav-number">26.</span> <span class="nav-text">几何均值滤波？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE%E5%83%8F%E7%9A%84%E9%87%8D%E5%BB%BA"><span class="nav-number">27.</span> <span class="nav-text">什么是图像的重建？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%95%E5%BD%B1%E5%92%8C%E9%9B%B7%E7%99%BB%E5%8F%98%E6%8D%A2radon-transform"><span class="nav-number">28.</span> <span class="nav-text">投影和雷登变换（Radon transform）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B7%E7%99%BB%E5%8F%98%E6%8D%A2%E5%8F%8D%E6%8A%95%E5%BD%B1%E9%87%8D%E5%BB%BA%E5%9B%BE%E5%83%8F"><span class="nav-number">29.</span> <span class="nav-text">雷登变换反投影重建图像？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%A4%E6%B3%A2%E5%8F%8D%E6%8A%95%E5%BD%B1%E9%87%8D%E5%BB%BA%E5%9B%BE%E5%83%8F"><span class="nav-number">30.</span> <span class="nav-text">滤波反投影重建图像？</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Shaogui" src="/images/avatar-2023.png"><p class="site-author-name" itemprop="name">Shaogui</p><div class="site-description" itemprop="description">害怕失败是本能，勇敢面对才是本事</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">544</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">77</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/WuShaogui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;WuShaogui" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/mu-zhi-zhi-tian" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;mu-zhi-zhi-tian" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>知乎</a></span></div><div class="cc-license animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://manaai.cn/" title="http:&#x2F;&#x2F;manaai.cn&#x2F;" rel="noopener" target="_blank">神力AI</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.shaogui.life/posts/4192546070.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar-2023.png"><meta itemprop="name" content="Shaogui"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="年轻人起来冲"><meta itemprop="description" content="害怕失败是本能，勇敢面对才是本事"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="E01 - 图像复原与重建 | 年轻人起来冲"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">E01 - 图像复原与重建</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-06-15 08:09:17" itemprop="dateCreated datePublished" datetime="2022-06-15T08:09:17+08:00">2022-06-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-18 19:05:43" itemprop="dateModified" datetime="2025-01-18T19:05:43+08:00">2025-01-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/" itemprop="url" rel="index"><span itemprop="name">3-编程实践</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/E-OpenCV/" itemprop="url" rel="index"><span itemprop="name">E-OpenCV</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/E-OpenCV/OpenCV%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" itemprop="url" rel="index"><span itemprop="name">OpenCV使用指南</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>26k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>23 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>图像因为相机或拍摄存在噪声、缺失和抖动问题，导致成像有噪点、不清晰，如果噪声和抖动是有规律的，那么可以通过特定的方法去除这些干扰，复原或修复图像</p><span id="more"></span><h3 id="什么是图像噪声"><a class="markdownIt-Anchor" href="#什么是图像噪声"></a> 什么是图像噪声？</h3><ul><li>数字图像中的噪声源主要来自图像获取和传输过程。在获取图像时，光照水平和传感器温度影响图像中的噪声。在传输图像时，传输信道中的干扰对图像产生污染</li></ul><h3 id="什么是加性噪声"><a class="markdownIt-Anchor" href="#什么是加性噪声"></a> 什么是加性噪声？</h3><ul><li>一般指热噪声、散弹噪声等，它们与信号的关系是相加，不管有没有信号，噪声都存在，即将一个固定大小的随机数加到数据上，结果可以表示为原始数据加上噪声。它具有独立性和相等方差性，常见于无监督学习，如高斯、瑞利、爱尔兰噪声等</li></ul><h3 id="什么是乘性噪声"><a class="markdownIt-Anchor" href="#什么是乘性噪声"></a> 什么是乘性噪声？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121410630.png" alt=""></li><li>一般由信道不理想引起，它们与信号的关系是相乘，信号在它在，信号不在他也就不在，即将数据乘以一个随机数，结果可以表示为原始数据乘上噪声。它常常表现为数据的变化率随机变化，如合成孔径雷达、超声波、激光等相干图像系统当中<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成乘性噪声</span></span><br><span class="line">img_height,img_width,img_channels=image.shape</span><br><span class="line">gauss = np.random.randn(img_height,img_width,img_channels)</span><br><span class="line"><span class="comment">#给图片添加speckle噪声</span></span><br><span class="line">speckle_noisy_img = image + image * gauss</span><br><span class="line"><span class="comment">#归一化图像的像素值</span></span><br><span class="line">speckle_noisy_img = np.clip(speckle_noisy_img,a_min=<span class="number">0</span>,a_max=<span class="number">255</span>)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是高斯噪声"><a class="markdownIt-Anchor" href="#什么是高斯噪声"></a> 什么是高斯噪声？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121410955.png" alt=""></li><li>高斯噪声中空间域和频率域中都很方便进行数学处理，因而得到了广泛的应用<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0503.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line"><span class="comment"># 加入高斯噪声</span></span><br><span class="line">mu, sigma = <span class="number">0.0</span>, <span class="number">20.0</span></span><br><span class="line">noiseGause = np.random.normal(mu, sigma, img.shape)</span><br><span class="line">imgGaussNoise = img + noiseGause</span><br><span class="line">imgGaussNoise = np.uint8(cv2.normalize(imgGaussNoise, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX))</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是瑞利噪声"><a class="markdownIt-Anchor" href="#什么是瑞利噪声"></a> 什么是瑞利噪声？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121410523.png" alt=""></li><li>瑞利噪声概率密度分布到原点的距离及密度的基本形状右偏<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0503.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line"><span class="comment"># 加入瑞利噪声</span></span><br><span class="line">a = <span class="number">30.0</span></span><br><span class="line">noiseRayleigh = np.random.rayleigh(a, size=img.shape)</span><br><span class="line">imgRayleighNoise = img + noiseRayleigh</span><br><span class="line">imgRayleighNoise = np.uint8(cv2.normalize(imgRayleighNoise, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX)) </span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是爱尔兰噪声"><a class="markdownIt-Anchor" href="#什么是爱尔兰噪声"></a> 什么是爱尔兰噪声？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121410872.png" alt=""></li><li>也称伽马噪声<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0503.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">a, b = <span class="number">10.0</span>, <span class="number">2.5</span></span><br><span class="line">noiseGamma = np.random.gamma(shape=b, scale=a, size=img.shape)</span><br><span class="line">imgGammaNoise = img + noiseGamma</span><br><span class="line">imgGammaNoise = np.uint8(cv2.normalize(imgGammaNoise, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX))</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是指数噪声"><a class="markdownIt-Anchor" href="#什么是指数噪声"></a> 什么是指数噪声？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121410165.png" alt=""></li><li>指数噪声是爱尔兰噪声在 b=1 时的特殊情况<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0503.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">a = <span class="number">10.0</span></span><br><span class="line">noiseExponent = np.random.exponential(scale=a, size=img.shape)</span><br><span class="line">imgExponentNoise = img + noiseExponent</span><br><span class="line">imgExponentNoise = np.uint8(cv2.normalize(imgExponentNoise, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX))</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是均匀噪声"><a class="markdownIt-Anchor" href="#什么是均匀噪声"></a> 什么是均匀噪声？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411263.png" alt=""></li><li>使用 uniform 产生<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0503.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">mean, sigma = <span class="number">10</span>, <span class="number">100</span></span><br><span class="line">a = <span class="number">2</span> * mean - np.sqrt(<span class="number">12</span> * sigma)  <span class="comment"># a = -14.64</span></span><br><span class="line">b = <span class="number">2</span> * mean + np.sqrt(<span class="number">12</span> * sigma)  <span class="comment"># b = 54.64</span></span><br><span class="line">noiseUniform = np.random.uniform(a, b, img.shape)</span><br><span class="line">imgUniformNoise = img + noiseUniform</span><br><span class="line">imgUniformNoise = np.uint8(cv2.normalize(imgUniformNoise, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX))</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是椒盐噪声"><a class="markdownIt-Anchor" href="#什么是椒盐噪声"></a> 什么是椒盐噪声？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411697.png" alt=""></li><li>就像盐粒或胡椒粒那样随机地分布在整个图像上，因此称为椒盐噪声，也称为双极冲击噪声<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0503.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">ps, pp = <span class="number">0.05</span>, <span class="number">0.02</span></span><br><span class="line">mask = np.random.choice((<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>), size=img.shape[:<span class="number">2</span>], p=[pp, (<span class="number">1</span>-ps-pp), ps])</span><br><span class="line">imgChoiceNoise = img.copy()</span><br><span class="line">imgChoiceNoise[mask==<span class="number">1</span>] = <span class="number">255</span></span><br><span class="line">imgChoiceNoise[mask==<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是泊松噪声"><a class="markdownIt-Anchor" href="#什么是泊松噪声"></a> 什么是泊松噪声？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411122.png" alt=""></li><li>符合泊松分布的噪声模型，泊松分布适合于描述单位时间内随机事件发生的次数的概率分布，如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA 序列的变异数、放射性原子核的衰变数等等<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成泊松噪声</span></span><br><span class="line"><span class="comment">#计算图像像素的分布范围</span></span><br><span class="line">vals = <span class="built_in">len</span>(np.unique(image))</span><br><span class="line">vals = <span class="number">2</span> ** np.ceil(np.log2(vals))</span><br><span class="line"><span class="comment">#给图片添加泊松噪声</span></span><br><span class="line">poisson_noisy_img = np.random.poisson(image * vals) / <span class="built_in">float</span>(vals)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="常见噪声的模拟场景"><a class="markdownIt-Anchor" href="#常见噪声的模拟场景"></a> 常见噪声的模拟场景？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411398.png" alt=""></li><li><strong>高斯噪声</strong>：常用于电子电路及传感器噪声（光照不足和 / 或高温引起）等因素所导致噪声的建模；</li><li><strong>瑞利噪声</strong>：常用于距离成像中的噪声建模；</li><li><strong>指数噪声和伽马噪声</strong>：常用于激光成像中的噪声建模；</li><li><strong>冲激噪声</strong>：常用于在成像期间的快速瞬变（如开关故障）的噪声建模；</li><li><strong>均匀噪声</strong>：是对实际情况最基本描述，也是数字图像处理中各种随机数发生器的基础</li></ul><h3 id="什么是算术平均滤波器"><a class="markdownIt-Anchor" href="#什么是算术平均滤波器"></a> 什么是算术平均滤波器？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411720.png" alt=""></li><li>算术平均滤波器是最简单的均值滤波器，与空间域滤波中的盒式滤波器相同，即取一个固定大小窗口内的平均像素代替该像素值<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0507b.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">kSize = (<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">kernalMean = np.ones(kSize, np.float32) / (kSize[<span class="number">0</span>]*kSize[<span class="number">1</span>])  <span class="comment"># 生成归一化盒式核</span></span><br><span class="line">imgConv1 = cv2.filter2D(img, -<span class="number">1</span>, kernalMean)  <span class="comment"># cv2.filter2D 方法</span></span><br><span class="line">kSize = (<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">imgConv3 = cv2.boxFilter(img, -<span class="number">1</span>, kSize)  <span class="comment"># cv2.boxFilter 方法 (默认normalize=True)</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是几何平均滤波器"><a class="markdownIt-Anchor" href="#什么是几何平均滤波器"></a> 什么是几何平均滤波器？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411493.png" alt=""></li><li>选择一个窗口，求取窗口内的几何平均值作为该位置像素值<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0507b.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">img_h = img.shape[<span class="number">0</span>]</span><br><span class="line">img_w = img.shape[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 算术平均滤波 (Arithmentic mean filter)</span></span><br><span class="line">kSize = (<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">kernalMean = np.ones(kSize, np.float32) / (kSize[<span class="number">0</span>]*kSize[<span class="number">1</span>])  <span class="comment"># 生成归一化盒式核</span></span><br><span class="line">imgAriMean = cv2.filter2D(img, -<span class="number">1</span>, kernalMean)</span><br><span class="line"><span class="comment"># 几何均值滤波器 (Geometric mean filter)</span></span><br><span class="line">m, n = <span class="number">3</span>, <span class="number">3</span></span><br><span class="line">order = <span class="number">1</span>/(m*n)</span><br><span class="line">kernalMean = np.ones((m,n), np.float32)  <span class="comment"># 生成盒式核</span></span><br><span class="line">hPad = <span class="built_in">int</span>((m-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">wPad = <span class="built_in">int</span>((n-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">imgPad = np.pad(img.copy(), ((hPad, m-hPad-<span class="number">1</span>), (wPad, n-wPad-<span class="number">1</span>)), mode=<span class="string">"edge"</span>)</span><br><span class="line">imgGeoMean = img.copy()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hPad, img_h + hPad):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(wPad, img_w + wPad):</span><br><span class="line">		prod = np.prod(imgPad[i-hPad:i+hPad+<span class="number">1</span>, j-wPad:j+wPad+<span class="number">1</span>]*<span class="number">1.0</span>)</span><br><span class="line">		imgGeoMean[i-hPad][j-wPad] = np.power(prod, order)  </span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是谐波平均滤波器"><a class="markdownIt-Anchor" href="#什么是谐波平均滤波器"></a> 什么是谐波平均滤波器？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411738.png" alt=""></li><li>谐波平均滤波器既能处理盐粒噪声（白色噪点），又能处理类似于高斯噪声的其他噪声，但不能处理胡椒噪声（黑色噪点）<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0507b.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">img_h,img_w = img.shape[<span class="number">0</span>],img.shape[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 算术平均滤波 (Arithmentic mean filter)</span></span><br><span class="line">kSize = (<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">kernalMean = np.ones(kSize, np.float32) / (kSize[<span class="number">0</span>]*kSize[<span class="number">1</span>])  <span class="comment"># 生成归一化盒式核</span></span><br><span class="line">imgAriMean = cv2.filter2D(img, -<span class="number">1</span>, kernalMean)</span><br><span class="line"><span class="comment"># 谐波平均滤波器 (Harmonic mean filter)</span></span><br><span class="line">m, n = <span class="number">3</span>, <span class="number">3</span></span><br><span class="line">order = m * n</span><br><span class="line">kernalMean = np.ones((m,n), np.float32)  <span class="comment"># 生成盒式核</span></span><br><span class="line">hPad = <span class="built_in">int</span>((m-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">wPad = <span class="built_in">int</span>((n-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">imgPad = np.pad(img.copy(), ((hPad, m-hPad-<span class="number">1</span>), (wPad, n-wPad-<span class="number">1</span>)), mode=<span class="string">"edge"</span>)</span><br><span class="line">epsilon = <span class="number">1e-8</span></span><br><span class="line">imgHarMean = img.copy()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hPad, img_h + hPad):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(wPad, img_w + wPad):</span><br><span class="line">		sumTemp = np.<span class="built_in">sum</span>(<span class="number">1.0</span> / (imgPad[i-hPad:i+hPad+<span class="number">1</span>, j-wPad:j+wPad+<span class="number">1</span>] + epsilon))</span><br><span class="line">		imgHarMean[i-hPad][j-wPad] = order / sumTemp</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是反谐波平均滤波器"><a class="markdownIt-Anchor" href="#什么是反谐波平均滤波器"></a> 什么是反谐波平均滤波器？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411678.png" alt=""></li><li>反谐波平均滤波器适用于降低或消除椒盐噪声<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0508a.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">img_h = img.shape[<span class="number">0</span>]</span><br><span class="line">img_w = img.shape[<span class="number">1</span>]</span><br><span class="line">m, n = <span class="number">3</span>, <span class="number">3</span></span><br><span class="line">order = m * n</span><br><span class="line">kernalMean = np.ones((m,n), np.float32)  <span class="comment"># 生成盒式核</span></span><br><span class="line">hPad = <span class="built_in">int</span>((m-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">wPad = <span class="built_in">int</span>((n-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">imgPad = np.pad(img.copy(), ((hPad, m-hPad-<span class="number">1</span>), (wPad, n-wPad-<span class="number">1</span>)), mode=<span class="string">"edge"</span>)</span><br><span class="line">Q = <span class="number">1.5</span>  <span class="comment"># 反谐波平均滤波器 阶数</span></span><br><span class="line">epsilon = <span class="number">1e-8</span></span><br><span class="line">imgHarMean = img.copy()</span><br><span class="line">imgInvHarMean = img.copy()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hPad, img_h + hPad):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(wPad, img_w + wPad):</span><br><span class="line">		<span class="comment"># 谐波平均滤波器 (Harmonic mean filter)</span></span><br><span class="line">		sumTemp = np.<span class="built_in">sum</span>(<span class="number">1.0</span> / (imgPad[i-hPad:i+hPad+<span class="number">1</span>, j-wPad:j+wPad+<span class="number">1</span>] + epsilon))</span><br><span class="line">		imgHarMean[i-hPad][j-wPad] = order / sumTemp</span><br><span class="line">		<span class="comment"># 反谐波平均滤波器 (Inv-harmonic mean filter)</span></span><br><span class="line">		temp = imgPad[i-hPad:i+hPad+<span class="number">1</span>, j-wPad:j+wPad+<span class="number">1</span>] + epsilon</span><br><span class="line">		imgInvHarMean[i-hPad][j-wPad] = np.<span class="built_in">sum</span>(np.power(temp, (Q+<span class="number">1</span>))) / np.<span class="built_in">sum</span>(np.power(temp, Q) + epsilon)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是统计排序滤波器"><a class="markdownIt-Anchor" href="#什么是统计排序滤波器"></a> 什么是统计排序滤波器？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411656.png" alt=""></li><li>统计排序滤波器是空间滤波器，其响应是基于滤波器邻域中的像素值的顺序，排序结果决定了滤波器的输出</li><li>统计排序包括中值滤波器、最大值滤波器、最小值滤波器、中点滤波器和修正阿尔法均值滤波器<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0508a.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">img_h,img_w = img.shape[<span class="number">0</span>],img.shape[<span class="number">1</span>]</span><br><span class="line">m, n = <span class="number">3</span>, <span class="number">3</span></span><br><span class="line">kernalMean = np.ones((m, n), np.float32)  <span class="comment"># 生成盒式核</span></span><br><span class="line"><span class="comment"># 边缘填充</span></span><br><span class="line">hPad = <span class="built_in">int</span>((m-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">wPad = <span class="built_in">int</span>((n-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">imgPad = np.pad(img.copy(), ((hPad, m-hPad-<span class="number">1</span>), (wPad, n-wPad-<span class="number">1</span>)), mode=<span class="string">"edge"</span>)</span><br><span class="line">imgMedianFilter = np.zeros(img.shape)  <span class="comment"># 中值滤波器</span></span><br><span class="line">imgMaxFilter = np.zeros(img.shape)  <span class="comment"># 最大值滤波器</span></span><br><span class="line">imgMinFilter = np.zeros(img.shape)  <span class="comment"># 最小值滤波器</span></span><br><span class="line">imgMiddleFilter = np.zeros(img.shape)  <span class="comment"># 中点滤波器</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img_h):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(img_w):</span><br><span class="line">		<span class="comment"># # 1. 中值滤波器 (median filter)</span></span><br><span class="line">		pad = imgPad[i:i+m, j:j+n]</span><br><span class="line">		imgMedianFilter[i, j] = np.median(pad)</span><br><span class="line">		<span class="comment"># # 2. 最大值滤波器 (maximum filter)</span></span><br><span class="line">		pad = imgPad[i:i+m, j:j+n]</span><br><span class="line">		imgMaxFilter[i, j] = np.<span class="built_in">max</span>(pad)</span><br><span class="line">		<span class="comment"># # 3. 最小值滤波器 (minimum filter)</span></span><br><span class="line">		pad = imgPad[i:i+m, j:j+n]</span><br><span class="line">		imgMinFilter[i, j] = np.<span class="built_in">min</span>(pad)</span><br><span class="line">		<span class="comment"># # 4. 中点滤波器 (middle filter)</span></span><br><span class="line">		pad = imgPad[i:i+m, j:j+n]</span><br><span class="line">		imgMiddleFilter[i, j] = <span class="built_in">int</span>(pad.<span class="built_in">max</span>()/<span class="number">2</span> + pad.<span class="built_in">min</span>()/<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是修正阿尔法均值滤波器"><a class="markdownIt-Anchor" href="#什么是修正阿尔法均值滤波器"></a> 什么是修正阿尔法均值滤波器？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121411194.png" alt=""></li><li>修正阿尔法均值滤波器也属于统计排序滤波器，其思想类似于比赛中去掉最高分和最低分后计算平均分的方法。取固定大小的窗口，去掉 d 个最低和 d 个最高，剩下元素的平均作为输出结果<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0507b.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">img_h = img.shape[<span class="number">0</span>]</span><br><span class="line">img_w = img.shape[<span class="number">1</span>]</span><br><span class="line">m, n = <span class="number">5</span>, <span class="number">5</span></span><br><span class="line">kernalMean = np.ones((m, n), np.float32)  <span class="comment"># 生成盒式核</span></span><br><span class="line"><span class="comment"># 边缘填充</span></span><br><span class="line">hPad = <span class="built_in">int</span>((m-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">wPad = <span class="built_in">int</span>((n-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">imgPad = np.pad(img.copy(), ((hPad, m-hPad-<span class="number">1</span>), (wPad, n-wPad-<span class="number">1</span>)), mode=<span class="string">"edge"</span>)</span><br><span class="line">imgAlphaFilter0 = np.zeros(img.shape)</span><br><span class="line">imgAlphaFilter1 = np.zeros(img.shape)</span><br><span class="line">imgAlphaFilter2 = np.zeros(img.shape)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img_h):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(img_w):</span><br><span class="line">		<span class="comment"># 邻域 m * n</span></span><br><span class="line">		pad = imgPad[i:i+m, j:j+n]</span><br><span class="line">		padSort = np.sort(pad.flatten())  <span class="comment"># 对邻域像素按灰度值排序</span></span><br><span class="line">		d = <span class="number">1</span></span><br><span class="line">		sumAlpha = np.<span class="built_in">sum</span>(padSort[d:m*n-d-<span class="number">1</span>])  <span class="comment"># 删除 d 个最大灰度值, d 个最小灰度值</span></span><br><span class="line">		imgAlphaFilter0[i, j] = sumAlpha / (m*n-<span class="number">2</span>*d)  <span class="comment"># 对剩余像素进行算术平均</span></span><br><span class="line">		d = <span class="number">2</span></span><br><span class="line">		sumAlpha = np.<span class="built_in">sum</span>(padSort[d:m*n-d-<span class="number">1</span>])</span><br><span class="line">		imgAlphaFilter1[i, j] = sumAlpha / (m*n-<span class="number">2</span>*d)</span><br><span class="line">		d = <span class="number">4</span></span><br><span class="line">		sumAlpha = np.<span class="built_in">sum</span>(padSort[d:m*n-d-<span class="number">1</span>])</span><br><span class="line">		imgAlphaFilter2[i, j] = sumAlpha / (m*n-<span class="number">2</span>*d)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是自适应局部降噪滤波器"><a class="markdownIt-Anchor" href="#什么是自适应局部降噪滤波器"></a> 什么是自适应局部降噪滤波器？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412658.png" alt=""></li><li>前述滤波器直接应用到图像处理，并未考虑图像本身的特征。自适应滤波器的特性根据 m∗n 矩形邻域 Sxy 定义的滤波区域内的图像的统计特性变化。通常，自适应滤波器的性能优于前述的滤波器，但滤波器的复杂度和计算量也更大<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0507b.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">hImg,wImg = img.shape[<span class="number">0</span>],img.shape[<span class="number">1</span>]</span><br><span class="line">m, n = <span class="number">5</span>, <span class="number">5</span></span><br><span class="line">imgAriMean = cv2.boxFilter(img, -<span class="number">1</span>, (m, n))  <span class="comment"># 算术平均滤波</span></span><br><span class="line"><span class="comment"># 边缘填充</span></span><br><span class="line">hPad = <span class="built_in">int</span>((m-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">wPad = <span class="built_in">int</span>((n-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">imgPad = np.pad(img.copy(), ((hPad, m-hPad-<span class="number">1</span>), (wPad, n-wPad-<span class="number">1</span>)), mode=<span class="string">"edge"</span>)</span><br><span class="line"><span class="comment"># 估计原始图像的噪声方差 sigmaEta</span></span><br><span class="line">mean, stddev = cv2.meanStdDev(img)</span><br><span class="line">sigmaEta = stddev ** <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(sigmaEta)</span><br><span class="line"><span class="comment"># 自适应局部降噪</span></span><br><span class="line">epsilon = <span class="number">1e-8</span></span><br><span class="line">imgAdaLocal = np.zeros(img.shape)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hImg):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(wImg):</span><br><span class="line">		pad = imgPad[i:i+m, j:j+n]  <span class="comment"># 邻域 Sxy, m*n</span></span><br><span class="line">		gxy = img[i,j]  <span class="comment"># 含噪声图像的像素点</span></span><br><span class="line">		zSxy = np.mean(pad)  <span class="comment"># 局部平均灰度</span></span><br><span class="line">		sigmaSxy = np.var(pad)  <span class="comment"># 灰度的局部方差</span></span><br><span class="line">		rateSigma = <span class="built_in">min</span>(sigmaEta / (sigmaSxy + epsilon), <span class="number">1.0</span>)  <span class="comment"># 加性噪声假设：sigmaEta/sigmaSxy &lt; 1</span></span><br><span class="line">		imgAdaLocal[i, j] = gxy - rateSigma * (gxy - zSxy)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是自适应中值滤波器"><a class="markdownIt-Anchor" href="#什么是自适应中值滤波器"></a> 什么是自适应中值滤波器？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412517.png" alt=""></li><li>中值滤波器的窗口尺寸是固定大小不变的，不能同时兼顾去噪和保护图像的细节，在噪声的密度较小时的性能较好，当噪声概率较高时的性能就会劣化</li><li>自适应中值滤波器根据预先设定的条件，在滤波的过程中动态改变滤波器的窗口尺寸大小；进一步地，根据条件判断当前像素是否噪声，由此决定是否用邻域中值替换当前像素</li><li>自适应中值滤波器可以处理较大概率的脉冲噪声，平滑非脉冲噪声，尽可能保护图像细节信息，避免图像边缘的细化或者粗化<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/Fig0514a.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">hImg,wImg = img.shape[<span class="number">0</span>],img.shape[<span class="number">1</span>]</span><br><span class="line">smax = <span class="number">7</span>  <span class="comment"># 允许最大窗口尺寸</span></span><br><span class="line">m, n = smax, smax</span><br><span class="line">imgAriMean = cv2.boxFilter(img, -<span class="number">1</span>, (m, n))  <span class="comment"># 算术平均滤波</span></span><br><span class="line"><span class="comment"># 边缘填充</span></span><br><span class="line">hPad = <span class="built_in">int</span>((m-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">wPad = <span class="built_in">int</span>((n-<span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">imgPad = np.pad(img.copy(), ((hPad, m-hPad-<span class="number">1</span>), (wPad, n-wPad-<span class="number">1</span>)), mode=<span class="string">"edge"</span>)</span><br><span class="line">imgMedianFilter = np.zeros(img.shape)  <span class="comment"># 中值滤波器</span></span><br><span class="line">imgAdaMedFilter = np.zeros(img.shape)  <span class="comment"># 自适应中值滤波器</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hPad, hPad+hImg):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(wPad, wPad+wImg):</span><br><span class="line">		<span class="comment"># 1. 中值滤波器 (Median filter)</span></span><br><span class="line">		ksize = <span class="number">3</span></span><br><span class="line">		k = <span class="built_in">int</span>(ksize/<span class="number">2</span>)</span><br><span class="line">		pad = imgPad[i-k:i+k+<span class="number">1</span>, j-k:j+k+<span class="number">1</span>]  <span class="comment"># 邻域 Sxy, m*n</span></span><br><span class="line">		imgMedianFilter[i-hPad, j-wPad] = np.median(pad)</span><br><span class="line">		<span class="comment"># 2. 自适应中值滤波器 (Adaptive median filter)</span></span><br><span class="line">		ksize = <span class="number">3</span></span><br><span class="line">		k = <span class="built_in">int</span>(ksize/<span class="number">2</span>)</span><br><span class="line">		pad = imgPad[i-k:i+k+<span class="number">1</span>, j-k:j+k+<span class="number">1</span>]</span><br><span class="line">		zxy = img[i-hPad][j-wPad]</span><br><span class="line">		zmin = np.<span class="built_in">min</span>(pad)</span><br><span class="line">		zmed = np.median(pad)</span><br><span class="line">		zmax = np.<span class="built_in">max</span>(pad)</span><br><span class="line">		<span class="keyword">if</span> zmin &lt; zmed &lt; zmax:</span><br><span class="line">			<span class="keyword">if</span> zmin &lt; zxy &lt; zmax:</span><br><span class="line">				imgAdaMedFilter[i-hPad, j-wPad] = zxy</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				imgAdaMedFilter[i-hPad, j-wPad] = zmed</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">				ksize = ksize + <span class="number">2</span></span><br><span class="line">				<span class="keyword">if</span> zmin &lt; zmed &lt; zmax <span class="keyword">or</span> ksize &gt; smax:</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				k = <span class="built_in">int</span>(ksize / <span class="number">2</span>)</span><br><span class="line">				pad = imgPad[i-k:i+k+<span class="number">1</span>, j-k:j+k+<span class="number">1</span>]</span><br><span class="line">				zmed = np.median(pad)</span><br><span class="line">				zmin = np.<span class="built_in">min</span>(pad)</span><br><span class="line">				zmax = np.<span class="built_in">max</span>(pad)</span><br><span class="line">			<span class="keyword">if</span> zmin &lt; zmed &lt; zmax <span class="keyword">or</span> ksize &gt; smax:</span><br><span class="line">				<span class="keyword">if</span> zmin &lt; zxy &lt; zmax:</span><br><span class="line">					imgAdaMedFilter[i-hPad, j-wPad] = zxy</span><br><span class="line">				<span class="keyword">else</span>:</span><br><span class="line">					imgAdaMedFilter[i-hPad, j-wPad] = zmed</span><br></pre></td></tr></tbody></table></figure></li></ul><p>%% 图像复原 %%</p><h3 id="什么是图像复原"><a class="markdownIt-Anchor" href="#什么是图像复原"></a> 什么是图像复原？</h3><ul><li>图像复原是对图像退化的过程进行估计，并补偿退化过程造成的失真，以便获得未经退化的原始图像或原始图像的最优估值，从而改善图像质量的一种方法</li><li>典型的图像复原方法是根据图像退化的先验知识建立退化模型，如湍流导致的模糊、匀速运动导致的模糊，以退化模型为基础采用滤波等手段进行处理，使复原后的图像符合一定的准则，达到改善图像质量的目的</li><li>图像复原是沿着质量降低的逆过程来重现真实的原始图像，通过去模糊函数而去除图像模糊</li></ul><h3 id="运动模糊退化模型"><a class="markdownIt-Anchor" href="#运动模糊退化模型"></a> 运动模糊退化模型？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412392.png" alt=""></li><li>运动模糊是相机，物体，背景间相对运动造成的效果，通常由于长时间曝光或场景内的物体快速移动导致，在摄影中可以借助移动镜头追踪移动的物体来避<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">motionBlur</span>(<span class="params">image, degree=<span class="number">10</span>, angle=<span class="number">45</span></span>):</span><br><span class="line">	image = np.array(image)</span><br><span class="line">	center = (degree/<span class="number">2</span>, degree/<span class="number">2</span>)  <span class="comment"># 旋转中心</span></span><br><span class="line">	M = cv2.getRotationMatrix2D(center, angle, <span class="number">1</span>)  <span class="comment"># 无损旋转</span></span><br><span class="line">	kernel = np.diag(np.ones(degree) / degree)  <span class="comment"># 运动模糊内核</span></span><br><span class="line">	kernel = cv2.warpAffine(kernel, M, (degree, degree))</span><br><span class="line">	blurred = cv2.filter2D(image, -<span class="number">1</span>, kernel)  <span class="comment"># 图像卷积</span></span><br><span class="line">	blurredNorm = np.uint8(cv2.normalize(blurred, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX))  <span class="comment"># 归一化为 [0,255]</span></span><br><span class="line">	<span class="keyword">return</span> blurredNorm</span><br><span class="line"><span class="comment"># 运动模糊图像</span></span><br><span class="line">img = cv2.imread(<span class="string">"../images/Fig0526a.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">imgBlur1 = motionBlur(img, degree=<span class="number">30</span>, angle=<span class="number">45</span>)</span><br><span class="line">imgBlur2 = motionBlur(img, degree=<span class="number">40</span>, angle=<span class="number">45</span>)</span><br><span class="line">imgBlur3 = motionBlur(img, degree=<span class="number">60</span>, angle=<span class="number">45</span>)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="湍流模糊退化模型"><a class="markdownIt-Anchor" href="#湍流模糊退化模型"></a> 湍流模糊退化模型？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412736.png" alt=""></li><li>湍流是自然界中普遍存在的一种复杂的流动现象。物体通过湍流大气成像时，受到湍流效应的影响，出现光强闪烁、光束方向漂移、光束宽度扩展及接收面上相位的起伏，造成图像模糊和抖动，甚至扭曲变形<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getDegradedImg</span>(<span class="params">image, Huv</span>):  <span class="comment"># 根据退化模型生成退化图像</span></span><br><span class="line">	rows, cols = image.shape[:<span class="number">2</span>]  <span class="comment"># 图片的高度和宽度</span></span><br><span class="line">	<span class="comment"># (1) 中心化, centralized 2d array f(x,y) * (-1)^(x+y)</span></span><br><span class="line">	mask = np.ones((rows, cols))</span><br><span class="line">	mask[<span class="number">1</span>::<span class="number">2</span>, ::<span class="number">2</span>] = -<span class="number">1</span></span><br><span class="line">	mask[::<span class="number">2</span>, <span class="number">1</span>::<span class="number">2</span>] = -<span class="number">1</span></span><br><span class="line">	imageCen = image * mask</span><br><span class="line">	<span class="comment"># (2) 快速傅里叶变换</span></span><br><span class="line">	dftImage = np.zeros((rows, cols, <span class="number">2</span>), np.float32)</span><br><span class="line">	dftImage[:, :, <span class="number">0</span>] = imageCen</span><br><span class="line">	cv2.dft(dftImage, dftImage, cv2.DFT_COMPLEX_OUTPUT)  <span class="comment"># 快速傅里叶变换 (rows, cols, 2)</span></span><br><span class="line">	<span class="comment"># (4) 构建 频域滤波器传递函数:</span></span><br><span class="line">	Filter = np.zeros((rows, cols, <span class="number">2</span>), np.float32)  <span class="comment"># (rows, cols, 2)</span></span><br><span class="line">	Filter[:, :, <span class="number">0</span>], Filter[:, :, <span class="number">1</span>] = Huv, Huv</span><br><span class="line">	<span class="comment"># (5) 在频率域修改傅里叶变换: 傅里叶变换 点乘 滤波器传递函数</span></span><br><span class="line">	dftFilter = dftImage * Filter</span><br><span class="line">	<span class="comment"># (6) 对修正傅里叶变换 进行傅里叶逆变换，并只取实部</span></span><br><span class="line">	idft = np.ones((rows, cols), np.float32)  <span class="comment"># 快速傅里叶变换的尺寸</span></span><br><span class="line">	cv2.dft(dftFilter, idft, cv2.DFT_REAL_OUTPUT + cv2.DFT_INVERSE + cv2.DFT_SCALE)  <span class="comment"># 只取实部</span></span><br><span class="line">	<span class="comment"># (7) 中心化, centralized 2d array g(x,y) * (-1)^(x+y)</span></span><br><span class="line">	mask2 = np.ones(dftImage.shape[:<span class="number">2</span>])</span><br><span class="line">	mask2[<span class="number">1</span>::<span class="number">2</span>, ::<span class="number">2</span>] = -<span class="number">1</span></span><br><span class="line">	mask2[::<span class="number">2</span>, <span class="number">1</span>::<span class="number">2</span>] = -<span class="number">1</span></span><br><span class="line">	idftCen = idft * mask2  <span class="comment"># g(x,y) * (-1)^(x+y)</span></span><br><span class="line">	<span class="comment"># (8) 截取左上角，大小和输入图像相等</span></span><br><span class="line">	imgDegraded = np.uint8(cv2.normalize(idftCen, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX))  <span class="comment"># 归一化为 [0,255]</span></span><br><span class="line">	<span class="comment"># print(image.shape, dftFilter.shape, imgDegraded.shape)</span></span><br><span class="line">	<span class="keyword">return</span> imgDegraded</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">turbulenceBlur</span>(<span class="params">img, k=<span class="number">0.001</span></span>):  <span class="comment"># 湍流模糊传递函数</span></span><br><span class="line">	<span class="comment"># H(u,v) = exp(-k(u^2+v^2)^5/6)</span></span><br><span class="line">	M, N = img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]</span><br><span class="line">	u, v = np.meshgrid(np.arange(M), np.arange(N))</span><br><span class="line">	radius = (u - M//<span class="number">2</span>)**<span class="number">2</span> + (v - N//<span class="number">2</span>)**<span class="number">2</span></span><br><span class="line">	kernel = np.exp(-k * np.power(radius, <span class="number">5</span>/<span class="number">6</span>))</span><br><span class="line">	<span class="keyword">return</span> kernel</span><br><span class="line"><span class="comment"># 读取原始图像</span></span><br><span class="line">img = cv2.imread(<span class="string">"../images/Fig0525a.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line"><span class="comment"># 生成湍流模糊图像</span></span><br><span class="line">HBlur1 = turbulenceBlur(img, k=<span class="number">0.001</span>)  <span class="comment"># 湍流模糊传递函数</span></span><br><span class="line">imgBlur1 = getDegradedImg(img, HBlur1)  <span class="comment"># 生成湍流模糊图像</span></span><br><span class="line">HBlur2 = turbulenceBlur(img, k=<span class="number">0.0025</span>)</span><br><span class="line">imgBlur2 = getDegradedImg(img, HBlur2)</span><br><span class="line">show_images([img,imgBlur1,imgBlur2])</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="湍流模糊退化图像的逆滤波"><a class="markdownIt-Anchor" href="#湍流模糊退化图像的逆滤波"></a> 湍流模糊退化图像的逆滤波？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412437.png" alt=""></li><li>湍流退化模型可以得到退化图像。使用该退化模型进行逆滤波，退化函数与生成退化图像所用的退化函数相反<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">turbulenceBlur</span>(<span class="params">img, k=<span class="number">0.001</span></span>):  <span class="comment"># 湍流模糊传递函数: H(u,v) = exp(-k(u^2+v^2)^5/6)</span></span><br><span class="line">	M, N = img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]</span><br><span class="line">	u, v = np.meshgrid(np.arange(M), np.arange(N))</span><br><span class="line">	radius = (u - M//<span class="number">2</span>)**<span class="number">2</span> + (v - N//<span class="number">2</span>)**<span class="number">2</span></span><br><span class="line">	kernel = np.exp(-k * np.power(radius, <span class="number">5</span>/<span class="number">6</span>))</span><br><span class="line">	<span class="keyword">return</span> kernel</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getDegradedImg</span>(<span class="params">image, Huv, eps</span>):  <span class="comment"># 根据退化模型生成退化图像</span></span><br><span class="line">	<span class="comment"># (1) 傅里叶变换, 中心化</span></span><br><span class="line">	fft = np.fft.fft2(image.astype(np.float32))  <span class="comment"># 傅里叶变换</span></span><br><span class="line">	fftShift = np.fft.fftshift(fft)  <span class="comment"># 将低频分量移动到频域图像中心</span></span><br><span class="line">	<span class="comment"># (2) 在频率域修改傅里叶变换: 傅里叶变换 点乘 滤波器传递函数</span></span><br><span class="line">	fftShiftFilter = fftShift * Huv  <span class="comment"># Guv = Fuv * Huv</span></span><br><span class="line">	<span class="comment"># (3) 对修正傅里叶变换 进行傅里叶逆变换，逆中心化</span></span><br><span class="line">	invShift = np.fft.ifftshift(fftShiftFilter)  <span class="comment"># 将低频分量逆转换回图像四角</span></span><br><span class="line">	imgIfft = np.fft.ifft2(invShift)  <span class="comment"># 逆傅里叶变换，返回值是复数数组</span></span><br><span class="line">	imgDegraded = np.uint8(cv2.normalize(np.<span class="built_in">abs</span>(imgIfft), <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX))  <span class="comment"># 归一化为 [0,255]</span></span><br><span class="line">	<span class="keyword">return</span> imgDegraded</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ideaLPFilter</span>(<span class="params">img, radius=<span class="number">10</span></span>):  <span class="comment"># 理想低通滤波器</span></span><br><span class="line">	M, N = img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]</span><br><span class="line">	u, v = np.meshgrid(np.arange(M), np.arange(N))</span><br><span class="line">	D = np.sqrt((u - M//<span class="number">2</span>)**<span class="number">2</span> + (v - N//<span class="number">2</span>)**<span class="number">2</span>)</span><br><span class="line">	kernel = np.zeros(img.shape[:<span class="number">2</span>], np.float32)</span><br><span class="line">	kernel[D &lt;= radius] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> kernel</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inverseFilter</span>(<span class="params">image, Huv, D0</span>):  <span class="comment"># 根据退化模型逆滤波</span></span><br><span class="line">	<span class="comment"># (1) 傅里叶变换, 中心化</span></span><br><span class="line">	fft = np.fft.fft2(image.astype(np.float32))  <span class="comment"># 傅里叶变换</span></span><br><span class="line">	fftShift = np.fft.fftshift(fft)  <span class="comment"># 将低频分量移动到频域图像中心</span></span><br><span class="line">	<span class="comment"># (2) 在频率域修改傅里叶变换: 傅里叶变换 点乘 滤波器传递函数</span></span><br><span class="line">	<span class="keyword">if</span> D0==<span class="number">0</span>:</span><br><span class="line">		fftShiftFilter = fftShift / Huv  <span class="comment"># Guv = Fuv / Huv</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		lpFilter = ideaLPFilter(image, radius=D0)</span><br><span class="line">		fftShiftFilter = fftShift / Huv * lpFilter  <span class="comment"># Guv = Fuv / Huv</span></span><br><span class="line">	<span class="comment"># (3) 对修正傅里叶变换 进行傅里叶逆变换，逆中心化</span></span><br><span class="line">	invShift = np.fft.ifftshift(fftShiftFilter)  <span class="comment"># 将低频分量逆转换回图像四角</span></span><br><span class="line">	imgIfft = np.fft.ifft2(invShift)  <span class="comment"># 逆傅里叶变换，返回值是复数数组</span></span><br><span class="line">	imgRebuild = np.uint8(cv2.normalize(np.<span class="built_in">abs</span>(imgIfft), <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX))  <span class="comment"># 归一化为 [0,255]</span></span><br><span class="line">	<span class="keyword">return</span> imgRebuild</span><br><span class="line"><span class="comment"># 读取原始图像</span></span><br><span class="line">img = cv2.imread(<span class="string">"../images/Fig0525a.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line"><span class="comment"># 生成湍流模糊图像</span></span><br><span class="line">HTurb = turbulenceBlur(img, k=<span class="number">0.0025</span>)</span><br><span class="line">imgBlur = np.<span class="built_in">abs</span>(getDegradedImg(img, HTurb, <span class="number">0.0</span>))</span><br><span class="line"><span class="built_in">print</span>(imgBlur.<span class="built_in">max</span>(), imgBlur.<span class="built_in">min</span>())</span><br><span class="line"><span class="comment"># 逆滤波</span></span><br><span class="line">imgRebuild = inverseFilter(imgBlur, HTurb, <span class="number">480</span>)  <span class="comment"># Huv 全滤波器</span></span><br><span class="line">imgRebuild1 = inverseFilter(imgBlur, HTurb, D0=<span class="number">40</span>) <span class="comment">#在半径 D0 之外 Huv 截止</span></span><br><span class="line">imgRebuild2 = inverseFilter(imgBlur, HTurb, D0=<span class="number">70</span>)</span><br><span class="line">imgRebuild3 = inverseFilter(imgBlur, HTurb, D0=<span class="number">100</span>)</span><br><span class="line">show_images([img,imgBlur,imgRebuild,imgRebuild1,imgRebuild2,imgRebuild3])</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="退化图像的维纳滤波wiener-filter"><a class="markdownIt-Anchor" href="#退化图像的维纳滤波wiener-filter"></a> 退化图像的维纳滤波（Wiener filter）?</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412938.png" alt=""></li><li>最小均方差滤波由 1942 首先提出，是最早提出的线性图像复原方法，因此称为维纳滤波。用于处理运动滤波</li><li>对于不含噪声的运动模糊图像，在已知运动模糊退化模型和参数的前提下，使用逆滤波可以很好地复原退化图像，逆滤波的性能优于维纳滤波。但是，考虑实际退化图像往往含有一定水平的加性噪声，此时即使已知退化模型，逆滤波的后的噪声几乎掩盖了图像内容，而维纳滤波的结果则较好<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getMotionDsf</span>(<span class="params">shape, angle, dist</span>):</span><br><span class="line">	xCenter = (shape[<span class="number">0</span>] - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">	yCenter = (shape[<span class="number">1</span>] - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">	sinVal = np.sin(angle * np.pi / <span class="number">180</span>)</span><br><span class="line">	cosVal = np.cos(angle * np.pi / <span class="number">180</span>)</span><br><span class="line">	PSF = np.zeros(shape)  <span class="comment"># 点扩散函数</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dist):  <span class="comment"># 将对应角度上motion_dis个点置成1</span></span><br><span class="line">		xOffset = <span class="built_in">round</span>(sinVal * i)</span><br><span class="line">		yOffset = <span class="built_in">round</span>(cosVal * i)</span><br><span class="line">		PSF[<span class="built_in">int</span>(xCenter - xOffset), <span class="built_in">int</span>(yCenter + yOffset)] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> PSF / PSF.<span class="built_in">sum</span>()  <span class="comment"># 归一化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeBlurred</span>(<span class="params">image, PSF, eps</span>):  <span class="comment"># 对图片进行运动模糊</span></span><br><span class="line">	fftImg = np.fft.fft2(image)  <span class="comment"># 进行二维数组的傅里叶变换</span></span><br><span class="line">	fftPSF = np.fft.fft2(PSF) + eps</span><br><span class="line">	fftBlur = np.fft.ifft2(fftImg * fftPSF)</span><br><span class="line">	fftBlur = np.<span class="built_in">abs</span>(np.fft.fftshift(fftBlur))</span><br><span class="line">	<span class="keyword">return</span> fftBlur</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inverseFilter</span>(<span class="params">image, PSF, eps</span>):  <span class="comment"># 逆滤波</span></span><br><span class="line">	fftImg = np.fft.fft2(image)</span><br><span class="line">	fftPSF = np.fft.fft2(PSF) + eps  <span class="comment"># 噪声功率，这是已知的，考虑epsilon</span></span><br><span class="line">	imgInvFilter = np.fft.ifft2(fftImg / fftPSF)  <span class="comment"># 计算F(u,v)的傅里叶反变换</span></span><br><span class="line">	imgInvFilter = np.<span class="built_in">abs</span>(np.fft.fftshift(imgInvFilter))</span><br><span class="line">	<span class="keyword">return</span> imgInvFilter</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wienerFilter</span>(<span class="params"><span class="built_in">input</span>, PSF, eps, K=<span class="number">0.01</span></span>):  <span class="comment"># 维纳滤波，K=0.01</span></span><br><span class="line">	fftImg = np.fft.fft2(<span class="built_in">input</span>)</span><br><span class="line">	fftPSF = np.fft.fft2(PSF) + eps</span><br><span class="line">	fftWiener = np.conj(fftPSF) / (np.<span class="built_in">abs</span>(fftPSF)**<span class="number">2</span> + K)</span><br><span class="line">	imgWienerFilter = np.fft.ifft2(fftImg * fftWiener)</span><br><span class="line">	imgWienerFilter = np.<span class="built_in">abs</span>(np.fft.fftshift(imgWienerFilter))</span><br><span class="line">	<span class="keyword">return</span> imgWienerFilter</span><br><span class="line"><span class="comment"># 读取原始图像</span></span><br><span class="line">img = cv2.imread(<span class="string">"../images/Fig0526a.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">hImg, wImg = img.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 不含噪声的运动模糊</span></span><br><span class="line">PSF = getMotionDsf((hImg, wImg), <span class="number">45</span>, <span class="number">100</span>)  <span class="comment"># 运动模糊函数</span></span><br><span class="line">imgBlurred = np.<span class="built_in">abs</span>(makeBlurred(img, PSF, <span class="number">1e-6</span>))  <span class="comment"># 生成不含噪声的运动模糊图像</span></span><br><span class="line">imgInvFilter = inverseFilter(imgBlurred, PSF, <span class="number">1e-6</span>)  <span class="comment"># 逆滤波</span></span><br><span class="line">imgWienerFilter = wienerFilter(imgBlurred, PSF, <span class="number">1e-6</span>)  <span class="comment"># 维纳滤波</span></span><br><span class="line"><span class="comment"># 带有噪声的运动模糊</span></span><br><span class="line">scale = <span class="number">0.05</span>  <span class="comment"># 噪声方差</span></span><br><span class="line">noisy = imgBlurred.std() * np.random.normal(loc=<span class="number">0.0</span>, scale=scale, size=imgBlurred.shape)  <span class="comment"># 添加高斯噪声</span></span><br><span class="line">imgBlurNoisy = imgBlurred + noisy  <span class="comment"># 带有噪声的运动模糊</span></span><br><span class="line">imgNoisyInv = inverseFilter(imgBlurNoisy, PSF, scale)  <span class="comment"># 对添加噪声的模糊图像进行逆滤波</span></span><br><span class="line">imgNoisyWiener = wienerFilter(imgBlurNoisy, PSF, scale)  <span class="comment"># 对添加噪声的模糊图像进行维纳滤波</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="约束最小二乘方滤波"><a class="markdownIt-Anchor" href="#约束最小二乘方滤波"></a> 约束最小二乘方滤波？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412100.png" alt=""></li><li>维纳滤波建立在退化函数和信噪比已知的前提下，这在实践中并不容易满足，约束最小二乘方滤波仅要求噪声方差和均值的知识或估计，这些参数通常可以由一幅给定的退化图像算出，因而具有更为广泛的应用。而且，维纳滤波是以最小化一个统计准则为基础，因此是平均意义上的最优，而约束最小二乘方滤波则对每幅图像都会产生最优估计</li><li>与维纳滤波相比，最小二乘方滤波对于高噪声和中等噪声处理效果更好，对于低噪声二者处理结果基本相同。当手工选择参数以取得更好的视觉效果时，约束最小二乘方滤波的效果有可能比维纳滤波的效果更好<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getMotionDsf</span>(<span class="params">shape, angle, dist</span>):</span><br><span class="line">	xCenter = (shape[<span class="number">0</span>] - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">	yCenter = (shape[<span class="number">1</span>] - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">	sinVal = np.sin(angle * np.pi / <span class="number">180</span>)</span><br><span class="line">	cosVal = np.cos(angle * np.pi / <span class="number">180</span>)</span><br><span class="line">	PSF = np.zeros(shape)  <span class="comment"># 点扩散函数</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dist):  <span class="comment"># 将对应角度上motion_dis个点置成1</span></span><br><span class="line">		xOffset = <span class="built_in">round</span>(sinVal * i)</span><br><span class="line">		yOffset = <span class="built_in">round</span>(cosVal * i)</span><br><span class="line">		PSF[<span class="built_in">int</span>(xCenter - xOffset), <span class="built_in">int</span>(yCenter + yOffset)] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> PSF / PSF.<span class="built_in">sum</span>()  <span class="comment"># 归一化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeBlurred</span>(<span class="params">image, PSF, eps</span>):  <span class="comment"># 对图片进行运动模糊</span></span><br><span class="line">	fftImg = np.fft.fft2(image)  <span class="comment"># 进行二维数组的傅里叶变换</span></span><br><span class="line">	fftPSF = np.fft.fft2(PSF) + eps</span><br><span class="line">	fftBlur = np.fft.ifft2(fftImg * fftPSF)</span><br><span class="line">	fftBlur = np.<span class="built_in">abs</span>(np.fft.fftshift(fftBlur))</span><br><span class="line">	<span class="keyword">return</span> fftBlur</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wienerFilter</span>(<span class="params"><span class="built_in">input</span>, PSF, eps, K=<span class="number">0.01</span></span>):  <span class="comment"># 维纳滤波，K=0.01</span></span><br><span class="line">	fftImg = np.fft.fft2(<span class="built_in">input</span>)</span><br><span class="line">	fftPSF = np.fft.fft2(PSF) + eps</span><br><span class="line">	fftWiener = np.conj(fftPSF) / (np.<span class="built_in">abs</span>(fftPSF)**<span class="number">2</span> + K)</span><br><span class="line">	imgWienerFilter = np.fft.ifft2(fftImg * fftWiener)</span><br><span class="line">	imgWienerFilter = np.<span class="built_in">abs</span>(np.fft.fftshift(imgWienerFilter))</span><br><span class="line">	<span class="keyword">return</span> imgWienerFilter</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getPuv</span>(<span class="params">image</span>):</span><br><span class="line">	h, w = image.shape[:<span class="number">2</span>]</span><br><span class="line">	hPad, wPad = h - <span class="number">3</span>, w - <span class="number">3</span></span><br><span class="line">	pxy = np.array([[<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">4</span>, -<span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">	pxyPad = np.pad(pxy, ((hPad//<span class="number">2</span>, hPad - hPad//<span class="number">2</span>), (wPad//<span class="number">2</span>, wPad - wPad//<span class="number">2</span>)), mode=<span class="string">'constant'</span>)</span><br><span class="line">	fftPuv = np.fft.fft2(pxyPad)</span><br><span class="line">	<span class="keyword">return</span> fftPuv</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leastSquareFilter</span>(<span class="params">image, PSF, eps, gamma=<span class="number">0.01</span></span>):  <span class="comment"># 约束最小二乘方滤波</span></span><br><span class="line">	fftImg = np.fft.fft2(image)</span><br><span class="line">	fftPSF = np.fft.fft2(PSF)</span><br><span class="line">	conj = fftPSF.conj()</span><br><span class="line">	fftPuv = getPuv(image)</span><br><span class="line">	<span class="comment"># absConj = np.abs(fftPSF) ** 2</span></span><br><span class="line">	Huv = conj / (np.<span class="built_in">abs</span>(fftPSF)**<span class="number">2</span> + gamma * (np.<span class="built_in">abs</span>(fftPuv)**<span class="number">2</span>))</span><br><span class="line">	ifftImg = np.fft.ifft2(fftImg * Huv)</span><br><span class="line">	ifftShift = np.<span class="built_in">abs</span>(np.fft.fftshift(ifftImg))</span><br><span class="line">	imgLSFilter = np.uint8(cv2.normalize(np.<span class="built_in">abs</span>(ifftShift), <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX))  <span class="comment"># 归一化为 [0,255]</span></span><br><span class="line">	<span class="keyword">return</span> imgLSFilter</span><br><span class="line"><span class="comment"># # 读取原始图像</span></span><br><span class="line">img = cv2.imread(<span class="string">"../images/Fig0526a.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">hImg, wImg = img.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 带有噪声的运动模糊</span></span><br><span class="line">PSF = getMotionDsf((hImg, wImg), <span class="number">45</span>, <span class="number">100</span>)  <span class="comment"># 运动模糊函数</span></span><br><span class="line">imgBlurred = np.<span class="built_in">abs</span>(makeBlurred(img, PSF, <span class="number">1e-6</span>))  <span class="comment"># 生成不含噪声的运动模糊图像</span></span><br><span class="line">scale = <span class="number">0.01</span>  <span class="comment"># 噪声方差</span></span><br><span class="line">noisy = imgBlurred.std() * np.random.normal(loc=<span class="number">0.0</span>, scale=scale, size=imgBlurred.shape)  <span class="comment"># 添加高斯噪声</span></span><br><span class="line">imgBlurNoisy = imgBlurred + noisy  <span class="comment"># 带有噪声的运动模糊</span></span><br><span class="line">imgWienerFilter = wienerFilter(imgBlurNoisy, PSF, scale, K=<span class="number">0.01</span>)  <span class="comment"># 对含有噪声的模糊图像进行维纳滤波</span></span><br><span class="line">imgLSFilter = leastSquareFilter(imgBlurNoisy, PSF, scale, gamma=<span class="number">0.01</span>)  <span class="comment"># 约束最小二乘方滤波</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="几何均值滤波"><a class="markdownIt-Anchor" href="#几何均值滤波"></a> 几何均值滤波？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412913.png" alt=""></li><li>几何均值滤波器是维纳滤波的推广，其传递函数由括号内幂次分别为 α 和 1 − α 的两个表达式组成<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getMotionDsf</span>(<span class="params">shape, angle, dist</span>):</span><br><span class="line">	xCenter = (shape[<span class="number">0</span>] - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">	yCenter = (shape[<span class="number">1</span>] - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">	sinVal = np.sin(angle * np.pi / <span class="number">180</span>)</span><br><span class="line">	cosVal = np.cos(angle * np.pi / <span class="number">180</span>)</span><br><span class="line">	PSF = np.zeros(shape)  <span class="comment"># 点扩散函数</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dist):  <span class="comment"># 将对应角度上motion_dis个点置成1</span></span><br><span class="line">		xOffset = <span class="built_in">round</span>(sinVal * i)</span><br><span class="line">		yOffset = <span class="built_in">round</span>(cosVal * i)</span><br><span class="line">		PSF[<span class="built_in">int</span>(xCenter - xOffset), <span class="built_in">int</span>(yCenter + yOffset)] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> PSF / PSF.<span class="built_in">sum</span>()  <span class="comment"># 归一化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeBlurred</span>(<span class="params">image, PSF, eps</span>):  <span class="comment"># 对图片进行运动模糊</span></span><br><span class="line">	fftImg = np.fft.fft2(image)  <span class="comment"># 进行二维数组的傅里叶变换</span></span><br><span class="line">	fftPSF = np.fft.fft2(PSF) + eps</span><br><span class="line">	fftBlur = np.fft.ifft2(fftImg * fftPSF)</span><br><span class="line">	fftBlur = np.<span class="built_in">abs</span>(np.fft.fftshift(fftBlur))</span><br><span class="line">	<span class="keyword">return</span> fftBlur</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wienerFilter</span>(<span class="params"><span class="built_in">input</span>, PSF, eps, K=<span class="number">0.01</span></span>):  <span class="comment"># 维纳滤波，K=0.01</span></span><br><span class="line">	fftImg = np.fft.fft2(<span class="built_in">input</span>)</span><br><span class="line">	fftPSF = np.fft.fft2(PSF) + eps</span><br><span class="line">	fftWiener = np.conj(fftPSF) / (np.<span class="built_in">abs</span>(fftPSF)**<span class="number">2</span> + K)</span><br><span class="line">	imgWienerFilter = np.fft.ifft2(fftImg * fftWiener)</span><br><span class="line">	imgWienerFilter = np.<span class="built_in">abs</span>(np.fft.fftshift(imgWienerFilter))</span><br><span class="line">	<span class="keyword">return</span> imgWienerFilter</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">geometricMeanFilter</span>(<span class="params">image, PSF, eps, K=<span class="number">1</span>, alpha=<span class="number">1</span>, beta=<span class="number">1</span></span>):  <span class="comment"># 几何均值滤波器</span></span><br><span class="line">	fftImg = np.fft.fft2(image)</span><br><span class="line">	fftPSF = np.fft.fft2(PSF)</span><br><span class="line">	conj = fftPSF.conj()</span><br><span class="line">	squarePSF = (fftPSF * conj).real</span><br><span class="line">	Huv = np.power(conj / (squarePSF), alpha) * np.power(conj / (squarePSF + beta * K), <span class="number">1</span>-alpha)</span><br><span class="line">	ifftImg = np.fft.ifft2(fftImg * Huv)</span><br><span class="line">	ifftShift = np.<span class="built_in">abs</span>(np.fft.fftshift(ifftImg))</span><br><span class="line">	imgGMFilter = np.uint8(cv2.normalize(np.<span class="built_in">abs</span>(ifftShift), <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX))  <span class="comment"># 归一化为 [0,255]</span></span><br><span class="line">	<span class="keyword">return</span> imgGMFilter</span><br><span class="line"><span class="comment"># # 读取原始图像</span></span><br><span class="line">img = cv2.imread(<span class="string">"../images/Fig0526a.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">hImg, wImg = img.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 带有噪声的运动模糊</span></span><br><span class="line">PSF = getMotionDsf((hImg, wImg), <span class="number">45</span>, <span class="number">100</span>)  <span class="comment"># 运动模糊函数</span></span><br><span class="line">imgBlurred = np.<span class="built_in">abs</span>(makeBlurred(img, PSF, <span class="number">1e-6</span>))  <span class="comment"># 生成不含噪声的运动模糊图像</span></span><br><span class="line">scale = <span class="number">0.01</span>  <span class="comment"># 噪声方差</span></span><br><span class="line">noisy = imgBlurred.std() * np.random.normal(loc=<span class="number">0.0</span>, scale=scale, size=imgBlurred.shape)  <span class="comment"># 添加高斯噪声</span></span><br><span class="line">imgBlurNoisy = imgBlurred + noisy  <span class="comment"># 带有噪声的运动模糊</span></span><br><span class="line">imgWienerFilter = wienerFilter(imgBlurNoisy, PSF, scale, K=<span class="number">0.01</span>)  <span class="comment"># 对含有噪声的模糊图像进行维纳滤波</span></span><br><span class="line">imgGMFilter = geometricMeanFilter(imgBlurNoisy, PSF, scale, K=<span class="number">0.01</span>, alpha=<span class="number">0.5</span>, beta=<span class="number">1</span>)  <span class="comment"># 约束最小二乘方滤波</span></span><br><span class="line">show_images([imgBlurNoisy,imgWienerFilter,imgGMFilter])</span><br><span class="line">scale = <span class="number">0.1</span>  <span class="comment"># 噪声方差</span></span><br><span class="line">noisy = imgBlurred.std() * np.random.normal(loc=<span class="number">0.0</span>, scale=scale, size=imgBlurred.shape)  <span class="comment"># 添加高斯噪声</span></span><br><span class="line">imgBlurNoisy = imgBlurred + noisy  <span class="comment"># 带有噪声的运动模糊</span></span><br><span class="line">imgWienerFilter = wienerFilter(imgBlurNoisy, PSF, scale, K=<span class="number">0.01</span>)  <span class="comment"># 维纳滤波</span></span><br><span class="line">imgGMFilter = geometricMeanFilter(imgBlurNoisy, PSF, scale, K=<span class="number">0.01</span>, alpha=<span class="number">0</span>, beta=<span class="number">1</span>)  <span class="comment"># 约束最小二乘方滤波</span></span><br><span class="line">show_images([imgBlurNoisy,imgWienerFilter,imgGMFilter])</span><br></pre></td></tr></tbody></table></figure></li></ul><p>%% 图像重建 %%</p><h3 id="什么是图像的重建"><a class="markdownIt-Anchor" href="#什么是图像的重建"></a> 什么是图像的重建？</h3><ul><li>通过探测物体的投影数据，重建物体的实际内部构造</li><li>X 射线计算机断层成像的基本原理是：使用 X 射线从多个不同方向和角度对物体进行扫描，通过反投影算法获取物体内部结构的切片，堆叠这些切片就可以得到人体的三维表示</li></ul><h3 id="投影和雷登变换radon-transform"><a class="markdownIt-Anchor" href="#投影和雷登变换radon-transform"></a> 投影和雷登变换（Radon transform）？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412732.png" alt=""></li><li>雷登变换常被用于医学影像处理，利用反雷登变换可以进行三维图像重建<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">discreteRadonTransform</span>(<span class="params">image, steps</span>):</span><br><span class="line">	channels = image.shape[<span class="number">0</span>]</span><br><span class="line">	res = np.zeros((channels, channels), dtype=np.float32)</span><br><span class="line">	<span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(steps):</span><br><span class="line">		rotation = ndimage.rotate(image, -s * <span class="number">180</span>/steps, reshape=<span class="literal">False</span>).astype(np.float32)</span><br><span class="line">		res[:, s] = <span class="built_in">sum</span>(rotation)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># # 读取原始图像</span></span><br><span class="line">plt.figure(figsize=(<span class="number">9</span>, <span class="number">7</span>))</span><br><span class="line">fileImg = [<span class="string">"Fig0534a.tif"</span>, <span class="string">"Fig0534b.tif"</span>, <span class="string">"Fig0534c.tif"</span>]  <span class="comment"># 原始图像 文件名</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fileImg)):</span><br><span class="line">	img = cv2.imread(<span class="string">"../images/"</span>+fileImg[i], flags=<span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">	imgRadon = discreteRadonTransform(img, img.shape[<span class="number">0</span>])  <span class="comment"># Radon 变换</span></span><br><span class="line">	<span class="built_in">print</span>(img.shape, imgRadon.shape)</span><br><span class="line">	show_images([img,imgRadon])</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="雷登变换反投影重建图像"><a class="markdownIt-Anchor" href="#雷登变换反投影重建图像"></a> 雷登变换反投影重建图像？</h3><ul><li><img data-src="07-%E5%9B%BE%E5%83%8F%E5%A4%8D%E5%8E%9F%E4%B8%8E%E9%87%8D%E5%BB%BA-20230704211030.png" alt=""></li><li>反向投影是针对图像平面的基本几何元素而言的，图像平面点 m 的反投影是指在摄像机 P 的作用下具有像点 m 的所有空间点的集合<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">discreteRadonTransform</span>(<span class="params">image, steps</span>):  <span class="comment"># 离散雷登变换</span></span><br><span class="line">	channels = image.shape[<span class="number">0</span>]</span><br><span class="line">	resRadon = np.zeros((channels, channels), dtype=np.float32)</span><br><span class="line">	<span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(steps):</span><br><span class="line">		rotation = ndimage.rotate(image, -s * <span class="number">180</span>/steps, reshape=<span class="literal">False</span>).astype(np.float32)</span><br><span class="line">		resRadon[:, s] = <span class="built_in">sum</span>(rotation)</span><br><span class="line">	<span class="keyword">return</span> resRadon</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inverseRadonTransform</span>(<span class="params">image, steps</span>):  <span class="comment"># 雷登变换反投影</span></span><br><span class="line">	channels = image.shape[<span class="number">0</span>]</span><br><span class="line">	res = np.zeros((steps, channels, channels))</span><br><span class="line">	<span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(steps):</span><br><span class="line">		expandDims = np.expand_dims(image[:, s], axis=<span class="number">0</span>)</span><br><span class="line">		repeat = expandDims.repeat(channels, axis=<span class="number">0</span>)</span><br><span class="line">		res[s] = ndimage.rotate(repeat, s * <span class="number">180</span>/steps, reshape=<span class="literal">False</span>).astype(np.float32)</span><br><span class="line">	invRadon = np.<span class="built_in">sum</span>(res, axis=<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> invRadon</span><br><span class="line"><span class="comment"># 读取原始图像</span></span><br><span class="line">img1 = cv2.imread(<span class="string">"../images/Fig0534a.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">img2 = cv2.imread(<span class="string">"../images/Fig0534c.tif"</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 雷登变换</span></span><br><span class="line">imgRadon1 = discreteRadonTransform(img1, img1.shape[<span class="number">0</span>])  <span class="comment"># Radon 变换</span></span><br><span class="line">imgRadon2 = discreteRadonTransform(img2, img2.shape[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 雷登变换反投影</span></span><br><span class="line">imgInvRadon1 = inverseRadonTransform(imgRadon1, imgRadon1.shape[<span class="number">0</span>])</span><br><span class="line">imgInvRadon2 = inverseRadonTransform(imgRadon2, imgRadon2.shape[<span class="number">0</span>])</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="滤波反投影重建图像"><a class="markdownIt-Anchor" href="#滤波反投影重建图像"></a> 滤波反投影重建图像？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121412476.png" alt=""></li><li>直接由正弦图得到反投影图像，会存在严重的模糊，这是早期 CT 系统所存在的问题</li><li>傅立叶中心切片定理表明，投影的一维傅立叶变换是得到投影区域的二维傅立叶变换的切片。滤波反投影重建算法在反投影前将每一个采集投影角度下的投影进行卷积处理，从而改善点扩散函数引起的形状伪影，有效地改善了重建的图像质量<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">discreteRadonTransform</span>(<span class="params">image, steps</span>):  <span class="comment"># 离散雷登变换</span></span><br><span class="line">	channels = image.shape[<span class="number">0</span>]</span><br><span class="line">	resRadon = np.zeros((channels, channels), dtype=np.float32)</span><br><span class="line">	<span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(steps):</span><br><span class="line">		rotation = ndimage.rotate(image, -s * <span class="number">180</span>/steps, reshape=<span class="literal">False</span>).astype(np.float32)</span><br><span class="line">		resRadon[:, s] = <span class="built_in">sum</span>(rotation)</span><br><span class="line">	<span class="keyword">return</span> resRadon</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inverseRadonTransform</span>(<span class="params">image, steps</span>):  <span class="comment"># 雷登变换反投影重建图像</span></span><br><span class="line">	channels = image.shape[<span class="number">0</span>]</span><br><span class="line">	backproject = np.zeros((steps, channels, channels))</span><br><span class="line">	<span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(steps):</span><br><span class="line">		expandDims = np.expand_dims(image[:, s], axis=<span class="number">0</span>)</span><br><span class="line">		repeat = expandDims.repeat(channels, axis=<span class="number">0</span>)</span><br><span class="line">		backproject[s] = ndimage.rotate(repeat, s * <span class="number">180</span>/steps, reshape=<span class="literal">False</span>).astype(np.float32)</span><br><span class="line">	invRadon = np.<span class="built_in">sum</span>(backproject, axis=<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> invRadon</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SLFilter</span>(<span class="params">N, d</span>):  <span class="comment"># SL 滤波器, Sinc 函数对斜坡滤波器进行截断</span></span><br><span class="line">	filterSL = np.zeros((N,))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">		filterSL[i] = - <span class="number">2</span> / (np.pi**<span class="number">2</span> * d**<span class="number">2</span> * (<span class="number">4</span> * (i-N/<span class="number">2</span>)**<span class="number">2</span> - <span class="number">1</span>))</span><br><span class="line">	<span class="keyword">return</span> filterSL</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">filterInvRadonTransform</span>(<span class="params">image, steps</span>):  <span class="comment"># 滤波反投影重建图像</span></span><br><span class="line">	channels = <span class="built_in">len</span>(image[<span class="number">0</span>])</span><br><span class="line">	backproject = np.zeros((steps, channels, channels))  <span class="comment"># 反投影</span></span><br><span class="line">	<span class="built_in">filter</span> = SLFilter(channels, <span class="number">1</span>)  <span class="comment"># SL 滤波器</span></span><br><span class="line">	<span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(steps):</span><br><span class="line">		value = image[:, s]  <span class="comment"># 投影值</span></span><br><span class="line">		valueFiltered = np.convolve(<span class="built_in">filter</span>, value, <span class="string">"same"</span>)  <span class="comment"># 投影值和 SL 滤波器进行卷积</span></span><br><span class="line">		filterExpandDims = np.expand_dims(valueFiltered, axis=<span class="number">0</span>)</span><br><span class="line">		filterRepeat = filterExpandDims.repeat(channels, axis=<span class="number">0</span>)</span><br><span class="line">		backproject[s] = ndimage.rotate(filterRepeat, s * <span class="number">180</span>/steps, reshape=<span class="literal">False</span>).astype(np.float32)</span><br><span class="line">	filterInvRadon = np.<span class="built_in">sum</span>(backproject, axis=<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> filterInvRadon</span><br><span class="line"><span class="comment"># 读取原始图像</span></span><br><span class="line">img1 = cv2.imread(<span class="string">"../images/Fig0534a.tif"</span>, <span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">img2 = cv2.imread(<span class="string">"../images/Fig0534c.tif"</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 雷登变换</span></span><br><span class="line">imgRadon1 = discreteRadonTransform(img1, img1.shape[<span class="number">0</span>])  <span class="comment"># Radon 变换</span></span><br><span class="line">imgRadon2 = discreteRadonTransform(img2, img2.shape[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 雷登变换反投影重建图像</span></span><br><span class="line">imgInvRadon1 = inverseRadonTransform(imgRadon1, imgRadon1.shape[<span class="number">0</span>])</span><br><span class="line">imgInvRadon2 = inverseRadonTransform(imgRadon2, imgRadon2.shape[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 滤波反投影重建图像</span></span><br><span class="line">imgFilterInvRadon1 = filterInvRadonTransform(imgRadon1, imgRadon1.shape[<span class="number">0</span>])</span><br><span class="line">imgFilterInvRadon2 = filterInvRadonTransform(imgRadon2, imgRadon2.shape[<span class="number">0</span>])</span><br></pre></td></tr></tbody></table></figure></li></ul><p>参考：</p><ol><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/122787861">【OpenCV 例程 200 篇】91. 高斯噪声、瑞利噪声、爱尔兰噪声_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/122795650">【OpenCV 例程 200 篇】92. 指数噪声、均匀噪声、椒盐噪声_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40446557/article/details/81451651">常见的噪声：高斯、泊松和椒盐噪声_噪声分布_哗啦呼啦嘿的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/122795669">【OpenCV 例程 200 篇】93. 噪声模型的直方图_高斯噪声直方图_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/122834762">【OpenCV 例程 200 篇】94. 算术平均滤波器_算术均值滤波器_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/122834842">【OpenCV 例程 200 篇】95. 几何均值滤波器_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/579416400">加性噪声和乘性噪声的区别是什么？ - 知乎</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/122834865">【OpenCV 例程 200 篇】96. 谐波平均滤波器_谐波均值滤波器_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/122835182">【OpenCV 例程 200 篇】97. 反谐波平均滤波器_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/122839428">【OpenCV 例程 200 篇】98. 统计排序滤波器_排序统计滤波器_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/122839469">【OpenCV 例程 200 篇】99. 修正阿尔法均值滤波器_修正后的阿尔法均值滤波器_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/122839495">【OpenCV 例程 200 篇】100. 自适应局部降噪滤波器_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/122839526">【OpenCV 例程 300 篇】101. 自适应中值滤波器_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123027195">【OpenCV 例程 300 篇】104. 运动模糊退化模型_opencv 运动模糊_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123027287">【OpenCV 例程 300 篇】105. 湍流模糊退化模型_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123027356">【OpenCV 例程 300 篇】106. 退化图像的逆滤波_python opencv 逆向滤波法_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123062695">【OpenCV 例程 300 篇】107. 退化图像的维纳滤波_opencv 维纳滤波_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123062903">【OpenCV 例程 300 篇】108. 约束最小二乘方滤波_约束最小二乘方滤波优缺点_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123063149">【OpenCV 例程 300 篇】109. 几何均值滤波_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123088031">【OpenCV 例程 300 篇】110. 投影和雷登变换_opencv radon_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123088322">【OpenCV 例程 300 篇】111. 雷登变换反投影重建图像_opencvradon 变换_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123088438">【OpenCV 例程 300 篇】112. 滤波反投影重建图像_反投影法图像重建 youcans_youcans_的博客 - CSDN 博客</a></li></ol></div><footer class="post-footer"><div class="reward-container"><div>请我一杯咖啡吧！</div><button>赞赏</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="Shaogui 微信"> <span>微信</span></div><div><img src="/images/alipay.png" alt="Shaogui 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Shaogui</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.shaogui.life/posts/4192546070.html" title="E01 - 图像复原与重建">https://www.shaogui.life/posts/4192546070.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://www.zhihu.com/people/mu-zhi-zhi-tian"><span class="icon"><i class="fab fa-zhihu"></i> </span><span class="label">知乎</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div></div></div><div class="post-tags"><a href="/tags/opencv/" rel="tag"><i class="fa fa-tag"></i> opencv</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/836420954.html" rel="prev" title="CSPNet：A New Backbone that can Enhance Learning Capability of CNN"><i class="fa fa-angle-left"></i> CSPNet：A New Backbone that can Enhance Learning Capability of CNN</a></div><div class="post-nav-item"><a href="/posts/1037344397.html" rel="next" title="ConvNeXt V2：Co-designing and Scaling ConvNets with Masked Autoencoders">ConvNeXt V2：Co-designing and Scaling ConvNets with Masked Autoencoders <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Shaogui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.9m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">28:48</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a href="https://github.com/WuShaogui" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js","integrity":"sha256-G8ouPAnw4zzMbnAenHnVz6h9XpKbNdOkrqTh7AadyHs="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"WuShaogui/wushaogui.github.io","issue_term":"pathname","theme":"github-light"}</script><script src="/js/third-party/comments/utterances.js"></script></body></html>