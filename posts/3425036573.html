<!DOCTYPE html><html lang="zh-CN"><head><style type="text/css">.douban-card-block{display:flex;justify-content:center;align-items:center;width:100%;max-height:400px}.douban-card{display:flex;margin:30px 10px;padding:15px;border-radius:15px;position:relative;justify-content:center;align-items:center;overflow:hidden;color:#faebd7;text-decoration:none}.douban-card:hover{text-decoration:none}.douban-card-bgimg{position:absolute;width:115%;height:115%;filter:blur(15px) brightness(.6);background-size:100%;background-position:center;background-repeat:no-repeat}.douban-card-img{position:relative;height:130px;width:80px;background-size:100%;background-position:center;background-repeat:no-repeat}.douban-card-left:hover .douban-card-img{filter:blur(5px) brightness(.6);transform:perspective(800px) rotateX(180deg)}.douban-card-left .douban-card-img{transition:all .5s ease}.douban-card-left{position:relative;display:flex;flex-direction:column;align-items:center}.douban-card-left .douban-card-status{height:130px;width:80px;text-align:center;font-weight:700;position:absolute;left:0;top:30%;transform:rotateX(180deg);backface-visibility:hidden;transition:all .5s ease}.douban-card-left:hover .douban-card-status{transform:perspective(800px) rotateX(0)}.douban-card-right{position:relative;display:flex;flex-direction:column;margin-left:12px;font-size:16px;font-family:"Courier New",Courier,monospace;line-height:1.3;color:#faebd7}.douban-card-item{margin-top:4px}</style><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Roboto+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=PT+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.shaogui.life","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat","show_result":true},"fold":{"enable":true,"height":200},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="本文总结如何在 CSharp 调用动态链接库"><meta property="og:type" content="article"><meta property="og:title" content="CSharp 调用动态链接库 DLL"><meta property="og:url" content="https://www.shaogui.life/posts/3425036573.html"><meta property="og:site_name" content="年轻人起来冲"><meta property="og:description" content="本文总结如何在 CSharp 调用动态链接库"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353873.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353874.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353875.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353876.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353877.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353878.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353880.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353881.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353882.png"><meta property="article:published_time" content="2022-10-28T11:07:25.000Z"><meta property="article:modified_time" content="2025-01-19T05:55:03.042Z"><meta property="article:author" content="Shaogui"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353873.png"><link rel="canonical" href="https://www.shaogui.life/posts/3425036573.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.shaogui.life/posts/3425036573.html","path":"posts/3425036573.html","title":"CSharp 调用动态链接库 DLL"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>CSharp 调用动态链接库 DLL | 年轻人起来冲</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><link rel="alternate" href="/atom.xml" title="年轻人起来冲" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">年轻人起来冲</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">77</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">70</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">544</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E9%9D%9E%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E7%9A%842%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%96%B9%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">托管代码调用非托管代码的 2 种方式方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFpinvoke%E5%B9%B3%E5%8F%B0%E8%B0%83%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">什么是 P&#x2F;Invoke (平台调用)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E9%80%9A%E8%BF%87dllimport%E5%AF%BC%E5%85%A5c%E7%9A%84dll%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">托管代码通过 DllImport 导入 C++ 的 DLL 的过程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E9%80%9A%E8%BF%87pinvoke%E5%B9%B3%E5%8F%B0%E8%B0%83%E7%94%A8%E4%BD%BF%E7%94%A8c%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">托管代码通过 P&#x2F;Invoke (平台调用) 使用 C++ 函数的过程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%B0%81%E9%80%81"><span class="nav-number">5.</span> <span class="nav-text">什么是数据封送？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E5%92%8C%E9%9D%9E%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%B0%81%E9%80%81"><span class="nav-number">6.</span> <span class="nav-text">托管代码和非托管代码的数据传递为什么要进行封送？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-pinvoke-%E5%A6%82%E4%BD%95%E5%B0%81%E9%80%81%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">通过 P&#x2F;Invoke 如何封送 “基础数据类型”？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-pinvoke-%E6%96%B9%E5%BC%8F%E5%A6%82%E4%BD%95%E5%B0%81%E9%80%81%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="nav-number">8.</span> <span class="nav-text">通过 P&#x2F;Invoke 方式如何封送数组 &#x2F; 指针？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-pinvoke-%E6%96%B9%E5%BC%8F%E5%A6%82%E4%BD%95%E5%B0%81%E9%80%81%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">9.</span> <span class="nav-text">通过 P&#x2F;Invoke 方式如何封送结构体？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-pinvoke-%E6%96%B9%E5%BC%8F%E5%A6%82%E4%BD%95%E5%B0%81%E9%80%81%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84%E5%8D%95%E5%B1%82%E6%8C%87%E9%92%88"><span class="nav-number">10.</span> <span class="nav-text">通过 P&#x2F;Invoke 方式如何封送结构数组（单层指针）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-pinvoke-%E6%96%B9%E5%BC%8F%E5%A6%82%E4%BD%95%E5%B0%81%E9%80%81%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84%E5%B5%8C%E5%A5%97%E6%8C%87%E9%92%88"><span class="nav-number">11.</span> <span class="nav-text">通过 P&#x2F;Invoke 方式如何封送结构数组（嵌套指针）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87pinvoke%E6%96%B9%E5%BC%8Fc%E5%A6%82%E4%BD%95%E6%8E%A5%E5%8F%97c%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E"><span class="nav-number">12.</span> <span class="nav-text">通过 P&#x2F;Invoke 方式 C# 如何接受 C++ 的” 结构体 &quot; 函数返回？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87pinvoke%E6%96%B9%E5%BC%8Fc%E5%A6%82%E4%BD%95%E4%BA%92%E9%80%81c%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E5%86%85%E5%90%AB%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">13.</span> <span class="nav-text">通过 P&#x2F;Invoke 方式 C# 如何互送 C++ 的” 结构体数组 (内含基础类型一维数组)“？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87pinvoke%E6%96%B9%E5%BC%8Fc%E5%A6%82%E4%BD%95%E4%BA%92%E9%80%81c%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E5%86%85%E5%90%AB%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">14.</span> <span class="nav-text">通过 P&#x2F;Invoke 方式 C# 如何互送 C++ 的” 结构体数组 (内含基础类型二维数组)“？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87pinvoke%E6%96%B9%E5%BC%8Fc%E5%A6%82%E4%BD%95%E4%BA%92%E9%80%81c%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%90%AB%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88"><span class="nav-number">15.</span> <span class="nav-text">通过 P&#x2F;Invoke 方式 C# 如何互送 C++ 的” 结构体 (内含字符串指针)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87pinvoke%E6%96%B9%E5%BC%8Fc%E5%A6%82%E4%BD%95%E4%BA%92%E9%80%81c%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E4%BA%8C%E7%BB%B4%E6%8C%87%E9%92%88"><span class="nav-number">16.</span> <span class="nav-text">通过 P&#x2F;Invoke 方式 C# 如何互送 C++ 的” 结构体二维指针 &quot;？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87pinvoke%E5%A6%82%E4%BD%95%E5%B0%81%E9%80%81%E5%B5%8C%E5%A5%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">17.</span> <span class="nav-text">通过 P&#x2F;Invoke 如何封送” 嵌套的结构体 “？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87pinvoke%E6%96%B9%E5%BC%8Fc%E5%A6%82%E4%BD%95%E5%B0%81%E9%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%B0c"><span class="nav-number">18.</span> <span class="nav-text">通过 P&#x2F;Invoke 方式 C# 如何封送 “字符串” 到 C++?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87pinvoke%E6%96%B9%E5%BC%8Fc%E5%A6%82%E4%BD%95%E6%8E%A5%E5%8F%97c%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E8%BF%94%E5%9B%9E"><span class="nav-number">19.</span> <span class="nav-text">通过 P&#x2F;Invoke 方式 C# 如何接受 C++“字符串” 作为参数返回？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87pinvoke%E5%A6%82%E4%BD%95%E5%B0%81%E9%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">20.</span> <span class="nav-text">通过 P&#x2F;Invoke 如何封送” 函数指针 “？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E7%BB%99c%E7%9A%84dll"><span class="nav-number">21.</span> <span class="nav-text">C# 读取图片如何传递给 C++ 的 DLL?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E8%B0%83%E7%94%A8%E6%89%98%E7%AE%A1%E7%9A%84dll%E6%97%B6%E5%87%BA%E7%8E%B0-%E5%BC%95%E7%94%A8%E6%97%A0%E6%95%88%E6%88%96%E4%B8%8D%E6%94%AF%E6%8C%81%E8%AF%A5%E5%BC%95%E7%94%A8-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">22.</span> <span class="nav-text">C# 调用托管的 DLL 时，出现 “引用无效或不支持该引用” 的问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E9%9D%99%E6%80%81%E8%B0%83%E7%94%A8dll%E4%B8%AD%E9%9D%9E%E6%89%98%E7%AE%A1%E5%87%BD%E6%95%B0%E6%97%B6%E5%87%BA%E7%8E%B0-systementrypointnotfoundexception"><span class="nav-number">23.</span> <span class="nav-text">C# 静态调用 DLL 中非托管函数时，出现 “System.EntryPointNotFoundException” ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFmarshal%E7%B1%BB"><span class="nav-number">24.</span> <span class="nav-text">什么是 Marshal 类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#marshal%E7%B1%BB%E7%9A%84allochglobal%E6%96%B9%E6%B3%95"><span class="nav-number">25.</span> <span class="nav-text">Marshal 类的 AllocHGlobal () 方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#marshal%E7%B1%BB%E7%9A%84copy-%E6%96%B9%E6%B3%95"><span class="nav-number">26.</span> <span class="nav-text">Marshal 类的 Copy () 方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#marshal%E7%B1%BB%E7%9A%84freehglobal%E6%96%B9%E6%B3%95"><span class="nav-number">27.</span> <span class="nav-text">Marshal 类的 FreeHGlobal () 方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#marshal%E7%B1%BB%E7%9A%84ptrtostringansi%E6%96%B9%E6%B3%95"><span class="nav-number">28.</span> <span class="nav-text">Marshal 类的 PtrToStringAnsi () 方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#marshal%E7%B1%BB%E7%9A%84ptrtostructure%E6%96%B9%E6%B3%95"><span class="nav-number">29.</span> <span class="nav-text">Marshal 类的 PtrToStructure () 方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#marshal%E7%B1%BB%E7%9A%84sizeof%E6%96%B9%E6%B3%95"><span class="nav-number">30.</span> <span class="nav-text">Marshal 类的 SizeOf () 方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#marshal%E7%B1%BB%E7%9A%84stringtohglobaluni%E6%96%B9%E6%B3%95"><span class="nav-number">31.</span> <span class="nav-text">Marshal 类的 StringToHGlobalUni () 方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#marshal%E7%B1%BB%E5%A6%82%E4%BD%95%E5%B0%86void%E6%8C%87%E9%92%88%E8%BD%AC%E4%B8%BAintptr"><span class="nav-number">32.</span> <span class="nav-text">Marshal 类如何将 void * 指针转为 IntPtr？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#marshal%E7%B1%BB%E5%A6%82%E4%BD%95%E5%B0%86byte%E8%BD%ACintptr"><span class="nav-number">33.</span> <span class="nav-text">Marshal 类如何将 byte [] 转 IntPtr？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#marshal%E7%B1%BB%E5%A6%82%E4%BD%95%E5%B0%86intptr%E8%BD%ACbyte"><span class="nav-number">34.</span> <span class="nav-text">Marshal 类如何将 IntPtr 转 byte []？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87marshal%E6%96%B9%E5%BC%8Fc%E5%B0%81%E9%80%81%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%B0c%E6%8C%87%E9%92%88"><span class="nav-number">35.</span> <span class="nav-text">通过 Marshal 方式 C# 封送 “基础数据类型 (一维数组)” 到 C++ 指针？</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Shaogui" src="/images/avatar-2023.png"><p class="site-author-name" itemprop="name">Shaogui</p><div class="site-description" itemprop="description">害怕失败是本能，勇敢面对才是本事</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">544</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">77</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/WuShaogui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;WuShaogui" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/mu-zhi-zhi-tian" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;mu-zhi-zhi-tian" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>知乎</a></span></div><div class="cc-license animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://manaai.cn/" title="http:&#x2F;&#x2F;manaai.cn&#x2F;" rel="noopener" target="_blank">神力AI</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.shaogui.life/posts/3425036573.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar-2023.png"><meta itemprop="name" content="Shaogui"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="年轻人起来冲"><meta itemprop="description" content="害怕失败是本能，勇敢面对才是本事"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="CSharp 调用动态链接库 DLL | 年轻人起来冲"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">CSharp 调用动态链接库 DLL</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-28 19:07:25" itemprop="dateCreated datePublished" datetime="2022-10-28T19:07:25+08:00">2022-10-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-19 13:55:03" itemprop="dateModified" datetime="2025-01-19T13:55:03+08:00">2025-01-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/" itemprop="url" rel="index"><span itemprop="name">3-编程实践</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/D-CSharp/" itemprop="url" rel="index"><span itemprop="name">D-CSharp</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>23k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>21 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文总结如何在 CSharp 调用动态链接库</p><span id="more"></span><h3 id="托管代码调用非托管代码的2种方式方式"><a class="markdownIt-Anchor" href="#托管代码调用非托管代码的2种方式方式"></a> 托管代码调用非托管代码的 2 种方式方式？</h3><ul><li><strong>利用</strong> P/Invoke (平台调用) <strong>实现直接调用</strong>： 使用该方法在托管代码内引入非托管 DLL，但是问题是 PInvoke <strong>不能简单的实现 C++ 类的调用</strong></li><li><strong>利用</strong> C++/CLI <strong>作为代理中间层</strong>：直接使用 C++/CLI 编写托管 DLL，可以<strong>实现 C# 调用 C++ 所写的类</strong>，但是问题是 MONO 架构不支持 C++/CIL 功能，因此<strong><a target="_blank" rel="noopener" href="http://xn--Microsoft-uo4qv61gwqs5lu2kttsz.NET">无法实现脱离 Microsoft.NET</a> Framework 跨平台运行</strong></li></ul><h3 id="什么是pinvoke平台调用"><a class="markdownIt-Anchor" href="#什么是pinvoke平台调用"></a> 什么是 P/Invoke (平台调用)?</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353873.png" alt=""></li><li>P/Invoke 的全称是 Platform Invoke (平台调用) 它实际上是<strong>一种函数调用机制</strong>，通过 P/Invoke 允许从托管代码访问非托管库中的结构、回调和函数的技术。大多数 P/Invoke API 包含在两个命名空间中：System 和 System.Runtime.InteropServices</li><li><strong>PInvoke 最简单，但只能调用函数，不能直接调用类</strong>， 但有一个折衷的办法，就是在 C++ 里面定义一系列函数，里面调用相应的类，暴露给调用方（托管语言）的只有一系列的函数接口（API）<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">{</span><br><span class="line">	CPLUSPLUSTEST_API <span class="type">int</span> <span class="title function_">adjustBrightnessContrast</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* src, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> channel)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="托管代码通过dllimport导入c的dll的过程"><a class="markdownIt-Anchor" href="#托管代码通过dllimport导入c的dll的过程"></a> 托管代码通过 DllImport 导入 C++ 的 DLL 的过程？</h3><ul><li>C# 通过 P/Invoke (平台调用) 使用 C++ 的 DLL 时，需要使用 DllImport 导入</li><li><strong>DllImport</strong>：用来标识该方法是非托管的代码方法，在编译器编译的时候它能够正确的认识出被该 特性标记的是外来代码段。当到达程序运行的时候，也能够正确的认识出该代码是引用非托管的 代码，这样 CLR 会去加载非托管 DLL 文件，然后查找到入口点进行调用<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CharSet 指示用在入口点中的字符集，如：CharSet=CharSet.Ansi；</span></span><br><span class="line"><span class="comment">// SetLastError 指示方法是否保留 Win32"上一错误"，如：SetLastError=true；</span></span><br><span class="line"><span class="comment">// ExactSpelling 指示 EntryPoint 是否必须与指示的入口点的拼写完全匹配，如：ExactSpelling=false；</span></span><br><span class="line"><span class="comment">// CallingConvention指示入口点的调用约定， 如：CallingConvention=CallingConvention.Winapi；</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">"convertPython.dll"</span>, EntryPoint=<span class="string">"_startLedCheck"</span>, CallingConvention=llingConvention.Cdecl)</span>]</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="托管代码通过pinvoke平台调用使用c函数的过程"><a class="markdownIt-Anchor" href="#托管代码通过pinvoke平台调用使用c函数的过程"></a> 托管代码通过 P/Invoke (平台调用) 使用 C++ 函数的过程？</h3><ul><li><strong>(1) 定义预定于宏</strong>：用于声明 dll 中开放的函数<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXPORTDLL_EXPORTS</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> EXPORTDLL_API extern <span class="string">"C"</span> _declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> EXPORTDLL_API extern <span class="string">"C"</span> _declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//!EXPORTDLL_EXPORTS</span></span></span><br></pre></td></tr></tbody></table></figure></li><li><strong>(2) 确定调用约定</strong>：参考 DLL 函数的调用约定？<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.1 标准调用约定</span></span><br><span class="line"><span class="function">EXPORTDLL_API <span class="type">void</span> _stdcall <span class="title">CallingCvt_Stdcall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L"CallingCvt_Stdcall\n"</span>);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//1.2 C调用约定</span></span><br><span class="line"><span class="function">EXPORTDLL_API <span class="type">void</span> _cdecl <span class="title">CallingCvt_Cdecl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L"CallingCvt_Cdecl\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><strong>(3) C# 导入</strong>：使用 DllImport 导入 dll<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.1 标准调用约定</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">"ExportDll.dll"</span>, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">CallingCvt_Stdcall</span>()</span>;</span><br><span class="line">	   </span><br><span class="line"><span class="comment">//1.2 C调用约定</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">"ExportDll.dll"</span>, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">CallingCvt_Cdecl</span>()</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><strong>(4) 测试</strong>：<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.1 标准调用约定</span></span><br><span class="line">CExportDll.CallingCvt_Stdcall();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//1.2 C调用约定</span></span><br><span class="line">CExportDll.CallingCvt_Cdecl();</span><br></pre></td></tr></tbody></table></figure></li></ul><hr><h3 id="什么是数据封送"><a class="markdownIt-Anchor" href="#什么是数据封送"></a> 什么是数据封送？</h3><ul><li>托管代码使用 P/Invoke (平台调用) 使用非托管代代码函数时，设计参数的传递，但是由于他们分别基于公共语言运行时 (CLR) 、本机代码（Native Code），两者数据存储机制不一样，需要在托管代码一方进行数据封送处理。 <strong>封送指的就是托管内存和非托管内存之间传递数据的过程</strong></li><li>封送是双向的，由封送拆收器完成，其主要任务是： <strong>1. 数据类型转换</strong>。非托管数据类型到托管数据类型的相互转换（输出），或者，托管数据类型到非托管数据类型的转换（输入）； <strong>2. 内存搬运</strong>。非托管内存复制到托管内存，或者，托管内存复制到非托管内存； 3. 内存释放</li><li>对于每个 .NET Framework 类型均有一个默认非托管类型，可以使用 <strong>MarshalAs 重写默认封送处理：</strong> string 类型默认非托管类型是 LPTSTR，可以在非托管函数的 C# 声明中使用 MarshalAs 属性重写默认封送处理<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// puts 函数的参数的默认封送处理已从默认值 LPTSTR 重写为 LPSTR</span></span><br><span class="line">[<span class="meta">DllImport(<span class="string">"msvcrt.dll"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">puts</span>(<span class="params">[MarshalAs(UnmanagedType.LPStr</span>)] <span class="built_in">string</span> m)</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="托管代码和非托管代码的数据传递为什么要进行封送"><a class="markdownIt-Anchor" href="#托管代码和非托管代码的数据传递为什么要进行封送"></a> 托管代码和非托管代码的数据传递为什么要进行封送？</h3><ul><li>主要是<strong>数据存储顺序不一致</strong></li><li>在 C/C++ 中，struct 类型中的成员的一旦声明，则实例中成员在 内存中的布局 (Layout) 顺序就定下来了</li><li>在.net 托管环境中， CLR 提供了更自由的方式来控制 struct 中 Layout：我们可以在定义 struct 时，在 struct 上运用 StructLayoutAttribute 特性来控制成员的内存布局。默认情况下，struct 实例中 的字段在栈上的布局 (Layout) 顺序与声明中的顺序相同，即在 struct 上运用 StructLayoutAttribute (LayoutKind.Sequential)] 特性</li></ul><h3 id="通过-pinvoke-如何封送基础数据类型"><a class="markdownIt-Anchor" href="#通过-pinvoke-如何封送基础数据类型"></a> 通过 P/Invoke 如何封送 “基础数据类型”？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353874.png" alt=""></li><li>对于 P/Invoke (平台调用)，具有相同格式的托管和 c<ins> 本机<strong>基元类型之间不需要封送处理</strong>，但是必须<strong>对不具有相同形式的类型进行封送处理</strong>。例如在 C/C</ins> 中 long 和 int 都是 4 个字节，都对应着 C# 中的 int 类型，而 C/C++ 中的 char 类型占一个字节，用来表示一个 ASCII 码字符，在 C# 中能够表示一个字节的是 byte 类型</li><li>C++ 定义接口<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b, <span class="type">char</span> c,<span class="type">int</span>&amp; d, <span class="type">double</span>&amp; e, <span class="type">char</span>&amp; f)</span></span></span><br></pre></td></tr></tbody></table></figure></li><li>C# 调用<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">"CPPDLL.dll"</span>, EntryPoint = <span class="string">"func1"</span>, SetLastError = true, CharSet = CharSet.Ansi)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">func1</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">double</span> b, <span class="built_in">char</span> c, <span class="keyword">out</span> <span class="built_in">int</span> d,<span class="keyword">out</span> <span class="built_in">double</span> e, <span class="keyword">out</span> <span class="built_in">char</span> f</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_func1</span>()</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">int</span> a = <span class="number">1</span>; <span class="built_in">double</span> b = <span class="number">2.2</span>;<span class="built_in">char</span> c = <span class="string">'H'</span>;</span><br><span class="line">	<span class="built_in">int</span> d=<span class="number">0</span>; <span class="built_in">double</span> e=<span class="number">0</span>; <span class="built_in">char</span> f=<span class="string">' '</span>;</span><br><span class="line">	Console.WriteLine(<span class="string">"[i n]C#  :"</span>+a + <span class="string">"-"</span> + b + <span class="string">"-"</span> + c + <span class="string">"-"</span> + d + <span class="string">"-"</span> + e + <span class="string">"-"</span> + f);</span><br><span class="line">	func1(a, b, c, <span class="keyword">out</span> d, <span class="keyword">out</span> e, <span class="keyword">out</span> f);</span><br><span class="line">	Console.WriteLine(<span class="string">"[out]C#  :"</span> + a + <span class="string">"-"</span> + b + <span class="string">"-"</span> + c + <span class="string">"-"</span> + d + <span class="string">"-"</span> + e + <span class="string">"-"</span> + f);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过-pinvoke-方式如何封送数组指针"><a class="markdownIt-Anchor" href="#通过-pinvoke-方式如何封送数组指针"></a> 通过 P/Invoke 方式如何封送数组 / 指针？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353875.png" alt=""></li><li>1)- C++ 定义为指针，C# 使用 fxied 将数组转为指针封送；2）如果 C# 需要拿到 C ++ 的不定长的数组返回，需要使用 Marshal 解析封装；3）C# 可使用指针向 C ++ 发送数据，也可直接发送数组</li><li>C++ 定义开放函数<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> aNum,<span class="type">int</span>* b,<span class="type">int</span>*&amp; c, <span class="type">int</span>&amp; cNum, <span class="type">int</span>* d, <span class="type">int</span> dNum)</span> {</span><br><span class="line">	<span class="comment">// 打印C#传递过来的数组</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[in]C++/a:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; aNum; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	b[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">	b[<span class="number">1</span>] = <span class="number">12</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[out]C++/b:"</span> &lt;&lt; b[<span class="number">0</span>]  &lt;&lt; <span class="string">"-"</span> &lt;&lt; b[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	cNum = <span class="number">10</span>;</span><br><span class="line">	c = new <span class="type">int</span>[cNum];</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[out]C++/c:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cNum; i++)</span><br><span class="line">	{</span><br><span class="line">		c[i] = <span class="number">100</span> + i;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c[i] &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[in]C++/d:"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dNum; i++) {</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">		d[i] = i * <span class="number">10</span> + <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li><li>C# 传入数据<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">"CPPDLL.dll"</span>, EntryPoint = <span class="string">"func2"</span>, SetLastError = true, CharSet = CharSet.Ansi)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">func2</span>(<span class="params"><span class="built_in">int</span>* a, <span class="built_in">int</span> aNum,<span class="built_in">int</span>* b,<span class="keyword">out</span> IntPtr c, <span class="keyword">out</span> <span class="built_in">int</span> cNum,<span class="built_in">int</span>[] d,<span class="built_in">int</span> dNum</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_func2</span>()</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">int</span> aNum = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">int</span>[] a=<span class="keyword">new</span> <span class="built_in">int</span>[aNum];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;aNum;i++){a[i] = i + <span class="number">10</span>;}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span>[] b = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">int</span> dNum = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">int</span>[] d = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> cNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsafe</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">fixed</span> (<span class="built_in">int</span>* a_ptr = a)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">fixed</span> (<span class="built_in">int</span>* b_ptr = b)</span><br><span class="line">			{</span><br><span class="line">				IntPtr c;</span><br><span class="line">				func2(a_ptr, aNum, b_ptr, <span class="keyword">out</span> c, <span class="keyword">out</span> cNum,d,dNum);</span><br><span class="line"></span><br><span class="line">				Console.WriteLine(<span class="string">"[out]C#/b:"</span> + b[<span class="number">0</span>]+<span class="string">","</span>+b[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">				<span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[cNum];</span><br><span class="line">				Marshal.Copy(c, arr, <span class="number">0</span>, cNum);</span><br><span class="line">				<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; cNum; i++)</span><br><span class="line">				{</span><br><span class="line">					Console.Write(arr[i] + <span class="string">"-"</span>);</span><br><span class="line">				}</span><br><span class="line"></span><br><span class="line">				Console.WriteLine(<span class="string">""</span>);</span><br><span class="line">				<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dNum; i++)</span><br><span class="line">				{</span><br><span class="line">					Console.Write(d[i] + <span class="string">"-"</span>);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//1. 数组a：C#向C++传递数组，并使用aNum确定数量 </span></span><br><span class="line"><span class="comment">//2. 数组b：C#申请空间，C++按约定空间赋值，然后C#打印   </span></span><br><span class="line"><span class="comment">//3. 数组c：C#向C++传递IntPtr指针，C++动态返回不定长的数据，然后C#使用Marshal解析数据</span></span><br><span class="line"><span class="comment">//4. 数组d：类似数组b，C#声明不一样，使得不用使用fixed</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过-pinvoke-方式如何封送结构体"><a class="markdownIt-Anchor" href="#通过-pinvoke-方式如何封送结构体"></a> 通过 P/Invoke 方式如何封送结构体？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353876.png" alt=""></li><li><ul><li>C# 和 C++ 定义相同的数据结构，然后将数据结构当作基础数据类型使用</li></ul></li><li>需要接收 C++ 返回时，使用 out 修饰符</li><li>C++ 定义函数<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">(point a, point&amp; b)</span> {</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[in]C++/a: "</span> &lt;&lt; a.x &lt;&lt; <span class="string">","</span> &lt;&lt; a.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	b.x = <span class="number">10</span>;</span><br><span class="line">	b.y = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[out]C++/b: "</span> &lt;&lt; b.x &lt;&lt; <span class="string">","</span> &lt;&lt; b.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>C# 调用<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">"CPPDLL.dll"</span>, EntryPoint = <span class="string">"func3"</span>, SetLastError = true, CharSet = CharSet.Ansi)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">func3</span>(<span class="params">point a,<span class="keyword">out</span> point b</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_func3</span>()</span></span><br><span class="line">{</span><br><span class="line">	point a=<span class="keyword">new</span> point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">	Console.WriteLine(<span class="string">"[in]C#/a:"</span> + a.x + <span class="string">","</span> + a.y);</span><br><span class="line"></span><br><span class="line">	point b;</span><br><span class="line">	func3(a, <span class="keyword">out</span> b);</span><br><span class="line">	Console.WriteLine(<span class="string">"[out]C#/b:"</span> + b.x + <span class="string">","</span> + b.y);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//1. 结构a：C#向C++传递结构数据</span></span><br><span class="line"><span class="comment">//2. 结构b：C++声明结构变量，C++赋值，C#可以拿到其值</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过-pinvoke-方式如何封送结构数组单层指针"><a class="markdownIt-Anchor" href="#通过-pinvoke-方式如何封送结构数组单层指针"></a> 通过 P/Invoke 方式如何封送结构数组（单层指针）？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353877.png" alt=""></li><li>结构数组和基础数据类型的数组传递方法类似</li><li>C++ 定义函数<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func4</span><span class="params">(point* a, <span class="type">int</span> aNum, point* b, <span class="type">int</span> bNum)</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; aNum; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i].x &lt;&lt; <span class="string">","</span> &lt;&lt; a[i].y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bNum; i++)</span><br><span class="line">	{</span><br><span class="line">		b[i].x = (i+<span class="number">1</span>)*<span class="number">10</span>+i;</span><br><span class="line">		b[i].y = (i + <span class="number">2</span>) * <span class="number">10</span> + i;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>C# 调用<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">"CPPDLL.dll"</span>, EntryPoint = <span class="string">"func4"</span>, SetLastError = true, CharSet = CharSet.Ansi)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">func4</span>(<span class="params">point* a, <span class="built_in">int</span> aNum,point* b,<span class="built_in">int</span> bNum</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_func4</span>()</span></span><br><span class="line">{</span><br><span class="line">	point[] a =</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">new</span> point(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">		<span class="keyword">new</span> point(<span class="number">3</span>,<span class="number">4</span>),</span><br><span class="line">		<span class="keyword">new</span> point(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">	};</span><br><span class="line">	<span class="built_in">int</span> aNum = a.Length;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> bNum = <span class="number">2</span>;</span><br><span class="line">	point[] b = <span class="keyword">new</span> point[bNum];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsafe</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">fixed</span>(point* a_ptr=a)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">fixed</span> (point* b_ptr = b)</span><br><span class="line">			{</span><br><span class="line">				func4(a_ptr, aNum, b_ptr, bNum);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bNum; i++)</span><br><span class="line">				{</span><br><span class="line">					Console.WriteLine(b[i].x + <span class="string">","</span> + b[i].y);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 1. 结构指针a：既可向C++传递数据，也可向C#传递数据</span></span><br><span class="line"><span class="comment">// 2. 结构指针b：既可向C++传递数据，也可向C#传递数据</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过-pinvoke-方式如何封送结构数组嵌套指针"><a class="markdownIt-Anchor" href="#通过-pinvoke-方式如何封送结构数组嵌套指针"></a> 通过 P/Invoke 方式如何封送结构数组（嵌套指针）？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353878.png" alt=""></li><li>多重指针，最外层需要在 C# 指定空间，或者使用 IntPtr 传递</li><li>C++ 定义<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func6</span><span class="params">(point** ployPoints, <span class="type">int</span> ployNum, <span class="type">int</span>* ployPointsNum)</span></span><br><span class="line">{</span><br><span class="line">	ployPoints[<span class="number">0</span>] = new point[<span class="number">1</span>];</span><br><span class="line">	ployPoints[<span class="number">0</span>][<span class="number">0</span>].x = <span class="number">1.1</span>;</span><br><span class="line">	ployPoints[<span class="number">0</span>][<span class="number">0</span>].y = <span class="number">2.1</span>;</span><br><span class="line"></span><br><span class="line">	ployPoints[<span class="number">1</span>] = new point[<span class="number">2</span>];</span><br><span class="line">	ployPoints[<span class="number">1</span>][<span class="number">0</span>].x = <span class="number">3.1</span>;</span><br><span class="line">	ployPoints[<span class="number">1</span>][<span class="number">0</span>].y = <span class="number">3.2</span>;</span><br><span class="line">	ployPoints[<span class="number">1</span>][<span class="number">1</span>].x = <span class="number">4.1</span>;</span><br><span class="line">	ployPoints[<span class="number">1</span>][<span class="number">1</span>].y = <span class="number">4.2</span>;</span><br><span class="line"></span><br><span class="line">	ployPoints[<span class="number">2</span>] = new point[<span class="number">3</span>];</span><br><span class="line">	ployPoints[<span class="number">2</span>][<span class="number">0</span>].x = <span class="number">5.1</span>;</span><br><span class="line">	ployPoints[<span class="number">2</span>][<span class="number">0</span>].y = <span class="number">5.2</span>;</span><br><span class="line">	ployPoints[<span class="number">2</span>][<span class="number">1</span>].x = <span class="number">6.1</span>;</span><br><span class="line">	ployPoints[<span class="number">2</span>][<span class="number">1</span>].y = <span class="number">6.2</span>;</span><br><span class="line">	ployPoints[<span class="number">2</span>][<span class="number">2</span>].x = <span class="number">7.1</span>;</span><br><span class="line">	ployPoints[<span class="number">2</span>][<span class="number">2</span>].y = <span class="number">7.2</span>;</span><br><span class="line"></span><br><span class="line">	ployNum = <span class="number">3</span>;</span><br><span class="line">	ployPointsNum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	ployPointsNum[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	ployPointsNum[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>C# 调用<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">"CPPDLL.dll"</span>, EntryPoint = <span class="string">"func6"</span>, SetLastError = true, CharSet = CharSet.Ansi)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">func6</span>(<span class="params">point** ployPoints, <span class="built_in">int</span> ployNum, <span class="built_in">int</span>[] ployPointsNum</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C#申请第一层空间，C++申请第二层空间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test_func6</span>()</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">unsafe</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">int</span> ployNum = <span class="number">3</span>;</span><br><span class="line">		point*[] ployPointsList = <span class="keyword">new</span> point*[ployNum];</span><br><span class="line">		<span class="built_in">int</span>[] ployPointsNum = <span class="keyword">new</span> <span class="built_in">int</span>[ployNum];</span><br><span class="line">		<span class="keyword">fixed</span> (point** ployPoints = ployPointsList)</span><br><span class="line">		{</span><br><span class="line">			func6(ployPoints, ployNum, ployPointsNum);</span><br><span class="line">			Console.WriteLine(ployNum);</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ployNum; i++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; ployPointsNum[i]; j++)</span><br><span class="line">				{</span><br><span class="line">					Console.WriteLine(ployPointsList[i][j].x + <span class="string">","</span> + ployPointsList[i][j].y);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 1. 结构指针ployPoints：双重指针，先在C#申请第一重空间，然后在C++申请第二重空间，并返回每个二重空间的大小</span></span><br><span class="line"><span class="comment">// 2. 指针指向空间长度指针ployPointsNum：第二层空间的大小，是一个列表</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过pinvoke方式c如何接受c的结构体函数返回"><a class="markdownIt-Anchor" href="#通过pinvoke方式c如何接受c的结构体函数返回"></a> 通过 P/Invoke 方式 C# 如何接受 C++ 的” 结构体 " 函数返回？</h3><ul><li>C++ 定义开放函数<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_testStru5</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span>     iVal;</span><br><span class="line">}testStru5;</span><br><span class="line">testStru5   g_stru5;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORTDLL_API testStru5* <span class="title">Struct_Return</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">	g_stru<span class="number">5.</span>iVal = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L"Struct_Return \n"</span>);</span><br><span class="line">	<span class="keyword">return</span>(&amp;g_stru5);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>C# 接受数据<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">StructLayout</span>(LayoutKind.Sequential, CharSet=CharSet.Unicode)]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">testStru5</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>  iVal;</span><br><span class="line">};</span><br><span class="line">[<span class="built_in">DllImport</span>(<span class="string">"ExportDll.dll"</span>, CharSet = CharSet.Unicode)]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">extern</span> IntPtr <span class="title">Struct_Return</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">IntPtr struIntPtr = <span class="built_in">Struct_Return</span>();</span><br><span class="line">testStru5 stru5 = (testStru5)(Marshal.<span class="built_in">PtrToStructure</span>(struIntPtr, <span class="built_in">typeof</span>(testStru5)));</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过pinvoke方式c如何互送c的结构体数组内含基础类型一维数组"><a class="markdownIt-Anchor" href="#通过pinvoke方式c如何互送c的结构体数组内含基础类型一维数组"></a> 通过 P/Invoke 方式 C# 如何互送 C++ 的” 结构体数组 (内含基础类型一维数组)“？</h3><ul><li>C++ 定义开放函数<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmppe_submit</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">char</span> user[<span class="number">10</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">GetUser</span><span class="params">(cmppe_submit* lpSubit)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pData-&gt;data[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	pData-&gt;data[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	pData-&gt;data[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>C# 接受数据<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyData</span><br><span class="line">{</span><br><span class="line">	[<span class="meta">MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span>[] data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="string">"DLL.dll"</span>, EntryPoint = <span class="string">"GetData"</span>, CallingConvention = CallingConvention.Cdecl)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetData</span>(<span class="params"><span class="keyword">ref</span> MyData pData</span>)</span>;<span class="comment">//用ref声明结构</span></span><br><span class="line"></span><br><span class="line">MyData sd = <span class="keyword">new</span> MyData();</span><br><span class="line">sd.data = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>]; </span><br><span class="line">GetData(<span class="keyword">ref</span> sd);</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过pinvoke方式c如何互送c的结构体数组内含基础类型二维数组"><a class="markdownIt-Anchor" href="#通过pinvoke方式c如何互送c的结构体数组内含基础类型二维数组"></a> 通过 P/Invoke 方式 C# 如何互送 C++ 的” 结构体数组 (内含基础类型二维数组)“？</h3><ul><li>C++ 定义开放函数<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmppe_submit</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">char</span> user[<span class="number">10</span>][<span class="number">200</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">GetUser</span><span class="params">(cmppe_submit* lpSubit)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">strcpy</span>(lpSubit-&gt;user[<span class="number">0</span>], <span class="string">"waqerqwdsewf"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>C# 接受数据<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一维数组转写对应结构</span></span><br><span class="line"><span class="keyword">struct</span> cmppe_submit</span><br><span class="line">{</span><br><span class="line">	[<span class="meta">MarshalAs(UnmanagedType.ByValArray, SizeConst = 2000)</span>] </span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">byte</span>[] dst_addr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(@<span class="string">"Application3.dll"</span>, EntryPoint = <span class="string">"GetUser"</span>, CallingConvention = CallingConvention.Cdecl)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetUser</span>(<span class="params"><span class="keyword">ref</span> cmppe_submit lpSubmit</span>)</span>;<span class="comment">//用ref声明结构</span></span><br><span class="line"></span><br><span class="line">cmppe_submit submit;</span><br><span class="line">submit.dst_addr = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">2000</span>];</span><br><span class="line">GetUser(<span class="keyword">ref</span> submit);</span><br><span class="line"><span class="built_in">string</span> str = System.Text.Encoding.Default.GetString(submit.dst_addr, <span class="number">0</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用2个1维数组转写对应结构</span></span><br><span class="line">[<span class="meta">StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> cmppe_submit_pre</span><br><span class="line">{</span><br><span class="line">	[<span class="meta">MarshalAs(UnmanagedType.ByValArray, SizeConst=200)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span>      []m;</span><br><span class="line">};</span><br><span class="line">[<span class="meta">StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> cmppe_submit_now</span><br><span class="line">{</span><br><span class="line">	[<span class="meta">MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)</span>]</span><br><span class="line">	<span class="keyword">public</span> cmppe_submit_pre[]m;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(@<span class="string">"Application3.dll"</span>, EntryPoint = <span class="string">"GetUser"</span>, CallingConvention = CallingConvention.Cdecl)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetUser</span>(<span class="params"><span class="keyword">ref</span> cmppe_submit_now lpSubmit</span>)</span>;<span class="comment">//用ref声明结构</span></span><br><span class="line">cmppe_submit_now submit=<span class="keyword">new</span> cmppe_submit_now();</span><br><span class="line"></span><br><span class="line">GetUser(<span class="keyword">ref</span> submit);</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过pinvoke方式c如何互送c的结构体内含字符串指针"><a class="markdownIt-Anchor" href="#通过pinvoke方式c如何互送c的结构体内含字符串指针"></a> 通过 P/Invoke 方式 C# 如何互送 C++ 的” 结构体 (内含字符串指针)?</h3><ul><li>C++ 定义开放函数<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_testStru9</span></span><br><span class="line">{   </span><br><span class="line">	WCHAR   *pWChArr;</span><br><span class="line">	CHAR    *pChArr;</span><br><span class="line">	<span class="type">bool</span>    IsCbool;</span><br><span class="line">	BOOL    IsBOOL;</span><br><span class="line">}testStru9;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORTDLL_API <span class="type">void</span> <span class="title">Struct_ChangePtr</span><span class="params">( testStru9 *pStru )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pStru)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">	pStru-&gt;IsBOOL = <span class="literal">true</span>;</span><br><span class="line">	pStru-&gt;IsBOOL = TRUE;</span><br><span class="line">	pStru-&gt;pWChArr = (WCHAR*)<span class="built_in">CoTaskMemAlloc</span>(<span class="number">8</span>*<span class="built_in">sizeof</span>(WCHAR));</span><br><span class="line">	pStru-&gt;pChArr = (CHAR*)<span class="built_in">CoTaskMemAlloc</span>(<span class="number">8</span>*<span class="built_in">sizeof</span>(CHAR));</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">lstrcpynW</span>(pStru-&gt;pWChArr, <span class="string">L"ghj"</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">lstrcpynA</span>(pStru-&gt;pChArr, <span class="string">"ghj"</span>, <span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L"Struct_ChangePtr \n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>C# 接受数据<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 定义成string即可，注意BOOL与bool的不同</span></span><br><span class="line">[<span class="meta">StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> testStru9</span><br><span class="line">{</span><br><span class="line">	[<span class="meta">MarshalAs(UnmanagedType.LPWStr)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> pWChArr;</span><br><span class="line">	[<span class="meta">MarshalAs(UnmanagedType.LPStr)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> pChArr;</span><br><span class="line">	[<span class="meta">MarshalAs(UnmanagedType.U1)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">bool</span> IsCbool;</span><br><span class="line">	[<span class="meta">MarshalAs(UnmanagedType.Bool)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">bool</span> IsBOOL;</span><br><span class="line">};</span><br><span class="line">[<span class="meta">DllImport(<span class="string">"ExportDll.dll"</span>, CharSet = CharSet.Unicode)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Struct_ChangePtr</span>(<span class="params"><span class="keyword">ref</span> testStru9 pStru</span>)</span>;</span><br><span class="line"></span><br><span class="line">testStru9 stru9 = <span class="keyword">new</span> testStru9();</span><br><span class="line">Struct_ChangePtr(<span class="keyword">ref</span> stru9);</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过pinvoke方式c如何互送c的结构体二维指针"><a class="markdownIt-Anchor" href="#通过pinvoke方式c如何互送c的结构体二维指针"></a> 通过 P/Invoke 方式 C# 如何互送 C++ 的” 结构体二维指针 "？</h3><ul><li>C++ 定义开放函数<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_testStru8</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span>     m;</span><br><span class="line">}testStru8;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORTDLL_API <span class="type">void</span> <span class="title">Struct_ParameterOut</span><span class="params">( testStru8 **ppStru )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == ppStru){</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">	*ppStru = (testStru8*)<span class="built_in">CoTaskMemAlloc</span>(<span class="built_in">sizeof</span>(testStru8));</span><br><span class="line"> </span><br><span class="line">	(*ppStru)-&gt;m    = <span class="number">8</span>;</span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L"Struct_ParameterOut \n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>C# 接受数据<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> testStru8</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> m;</span><br><span class="line">};</span><br><span class="line">[<span class="meta">DllImport(<span class="string">"ExportDll.dll"</span>, CharSet = CharSet.Unicode)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Struct_ParameterOut</span>(<span class="params"><span class="keyword">ref</span> IntPtr ppStru</span>)</span>;</span><br><span class="line"></span><br><span class="line">IntPtr outPtr = IntPtr.Zero;</span><br><span class="line">Struct_ParameterOut(<span class="keyword">ref</span> outPtr);</span><br><span class="line">testStru8 stru8 = (testStru8)(Marshal.PtrToStructure(outPtr, <span class="keyword">typeof</span>(testStru8)));</span><br><span class="line">Marshal.FreeCoTaskMem(outPtr); <span class="comment">// 释放非托管的内存</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过pinvoke如何封送嵌套的结构体"><a class="markdownIt-Anchor" href="#通过pinvoke如何封送嵌套的结构体"></a> 通过 P/Invoke 如何封送” 嵌套的结构体 “？</h3><ul><li>C++ 定义开放函数<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_testStru10Pre</span></span><br><span class="line">{   </span><br><span class="line">	<span class="type">int</span>  iVal;</span><br><span class="line">}testStru10Pre;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_testStru10</span></span><br><span class="line">{   </span><br><span class="line">	testStru10Pre *pPre;</span><br><span class="line">	<span class="type">long</span>          lVal;</span><br><span class="line">	_testStru10()</span><br><span class="line">	{</span><br><span class="line">		pPre = <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line">}testStru10;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORTDLL_API <span class="type">void</span> <span class="title">Struct_NestStruct</span><span class="params">( testStru10 *pStru )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pStru)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">	pStru-&gt;lVal = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != pStru-&gt;pPre)</span><br><span class="line">	{</span><br><span class="line">		pStru-&gt;pPre-&gt;iVal = <span class="number">9</span>;</span><br><span class="line">	}</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L"Struct_NestStruct \n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>C# 接受数据<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">testStru10Pre</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> iVal;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">testStru10</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> IntPtr pPre;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> lVal;</span><br><span class="line">};</span><br><span class="line">[<span class="built_in">DllImport</span>(<span class="string">"ExportDll.dll"</span>, CharSet = CharSet.Unicode)]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">extern</span> <span class="type">void</span> <span class="title">Struct_NestStruct</span><span class="params">(ref testStru10 pStru)</span></span>;</span><br><span class="line"></span><br><span class="line">testStru10Pre str10Pre = <span class="keyword">new</span> <span class="built_in">testStru10Pre</span>();</span><br><span class="line">IntPtr intPtrStru10Pre = Marshal.<span class="built_in">AllocCoTaskMem</span>(Marshal.<span class="built_in">SizeOf</span>(str10Pre));</span><br><span class="line">Marshal.<span class="built_in">StructureToPtr</span>(str10Pre, intPtrStru10Pre, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">testStru10 stru10 = <span class="keyword">new</span> <span class="built_in">testStru10</span>();</span><br><span class="line">stru<span class="number">10.</span>pPre = intPtrStru10Pre;</span><br><span class="line"><span class="built_in">Struct_NestStruct</span>(ref stru10);</span><br><span class="line">testStru10Pre str10Pre2 = (testStru10Pre)Marshal.<span class="built_in">PtrToStructure</span>(stru<span class="number">10.</span>pPre, <span class="built_in">typeof</span>(testStru10Pre));</span><br><span class="line"> </span><br><span class="line">Marshal.<span class="built_in">DestroyStructure</span>(intPtrStru10Pre, <span class="built_in">typeof</span>(testStru10Pre));</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过pinvoke方式c如何封送字符串到c"><a class="markdownIt-Anchor" href="#通过pinvoke方式c如何封送字符串到c"></a> 通过 P/Invoke 方式 C# 如何封送 “字符串” 到 C++?</h3><ul><li>C++ 定义开放函数<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORTDLL_API <span class="type">int</span> <span class="title">Str_Output</span><span class="params">( WCHAR *pStr )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pStr)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	}</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L"Str_Output %s\n"</span>, pStr);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>C# 接受数据<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">"ExportDll.dll"</span>, CharSet=CharSet.Unicode)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">Str_Output</span>(<span class="params">[MarshalAs(UnmanagedType.LPWStr</span>)]<span class="built_in">string</span> pStr)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"hjkl;"</span>;</span><br><span class="line">CExportDll.Str_Output(str);</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过pinvoke方式c如何接受c字符串作为参数返回"><a class="markdownIt-Anchor" href="#通过pinvoke方式c如何接受c字符串作为参数返回"></a> 通过 P/Invoke 方式 C# 如何接受 C++“字符串” 作为参数返回？</h3><ul><li>C++ 定义开放函数<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORTDLL_API <span class="type">int</span> <span class="title">Str_Change</span><span class="params">( WCHAR *pStr, <span class="type">int</span> len )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pStr)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	}</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ix=<span class="number">0</span>; ix</span><br></pre></td></tr></tbody></table></figure></li><li>C# 接受数据<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">DllImport</span>(<span class="string">"ExportDll.dll"</span>, CharSet = CharSet.Unicode)]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">extern</span> <span class="type">int</span> <span class="title">Str_ChangeArr</span><span class="params">([In, Out]string[] ppStr, <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string[] strArr = <span class="keyword">new</span> string[<span class="number">4</span>] {<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">'\0'</span>, <span class="number">10</span>), </span><br><span class="line">								 <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">'\0'</span>, <span class="number">10</span>),  </span><br><span class="line">								 <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">'\0'</span>, <span class="number">10</span>), </span><br><span class="line">								 <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">'\0'</span>, <span class="number">10</span>) };</span><br><span class="line">CExportDll.<span class="built_in">Str_ChangeArr</span>(strArr, <span class="number">4</span>);</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过pinvoke如何封送函数指针"><a class="markdownIt-Anchor" href="#通过pinvoke如何封送函数指针"></a> 通过 P/Invoke 如何封送” 函数指针 “？</h3><ul><li>C# 中并没有函数指针的概念， 想要传递函数指针，首先要在 C# 中定义一个委托 (delegate)，并且在 C++ 中定义一个函数指针，同时要保证 委托和函数指针具备相同的函数原型</li><li>(1) C++ 返回函数指针<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PCALLBACKFUN)</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义返回函数指针的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PrintInt</span><span class="params">( <span class="type">int</span> i )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span>(<span class="built_in">wprintf</span>(<span class="string">L"CallBack_GetFunPtr %d\n"</span>, i));</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function">EXPORTDLL_API PCALLBACKFUN <span class="title">CallBack_GetFunPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span>(PrintInt);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>(2) C# 定义对应 C++ 函数指针的委托<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">DelegateGetFunPtrType</span>(<span class="params"><span class="built_in">int</span> i</span>)</span>;</span><br></pre></td></tr></tbody></table></figure></li><li>(3) C# 导入 C++ 的函数<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">"ExportDll.dll"</span>, CharSet = CharSet.Unicode)</span>]</span><br><span class="line">[<span class="meta">return:MarshalAs(UnmanagedType.FunctionPtr)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> DelegateGetFunPtrType <span class="title">CallBack_GetFunPtr</span>()</span>;</span><br></pre></td></tr></tbody></table></figure></li><li>(4) 测试<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CExportDll.DelegateGetFunPtrType printInt = CExportDll.CallBack_GetFunPtr();</span><br><span class="line">printInt(<span class="number">100</span>);</span><br></pre></td></tr></tbody></table></figure></li></ul><hr><h3 id="c读取图片如何传递给c的dll"><a class="markdownIt-Anchor" href="#c读取图片如何传递给c的dll"></a> C# 读取图片如何传递给 C++ 的 DLL?</h3><ul><li>C++ 定义接口<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> CPLUSPLUSTEST_API <span class="title function_">opencvtest</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* src, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> channel, <span class="type">float</span> contrastValue, <span class="type">int</span> brightValue)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (!src)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="type">int</span> format = CV_8UC3;</span><br><span class="line">	<span class="keyword">switch</span> (channel)</span><br><span class="line">	{</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		format = CV_8UC1;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		format = CV_8UC2;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		format = CV_8UC3;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	Mat <span class="title function_">img</span><span class="params">(h, w, format, src)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>C# 读图<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bmp;</span><br><span class="line">bmp = new Bitmap(<span class="string">"1.bmp"</span>);</span><br></pre></td></tr></tbody></table></figure></li><li>C# 传递图片数据到 DLL<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> stride;</span><br><span class="line">byte[] source = GetBGRValues(bmp, out stride);</span><br><span class="line"><span class="type">int</span> channel = Image.GetPixelFormatSize(bmp.PixelFormat) / <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 在原来的基础上，对比度和亮度加多少</span></span><br><span class="line">opencvtest(source, bmp.Width, bmp.Height, channel, (<span class="type">float</span>)(<span class="number">1</span>), <span class="number">0</span>); <span class="comment">//C++ opencv对内存操作</span></span><br><span class="line"></span><br><span class="line">public <span class="type">static</span> byte[] GetBGRValues(Bitmap bmp, out <span class="type">int</span> stride)</span><br><span class="line"> {</span><br><span class="line">	var rect = new Rectangle(<span class="number">0</span>, <span class="number">0</span>, bmp.Width, bmp.Height);</span><br><span class="line">	var bmpData = bmp.LockBits(rect, System.Drawing.Imaging.ImageLockMode.ReadOnly, bmp.PixelFormat);</span><br><span class="line">	stride = bmpData.Stride;</span><br><span class="line">	<span class="comment">//int channel = bmpData.Stride / bmp.Width; </span></span><br><span class="line">	var rowBytes = bmpData.Width * Image.GetPixelFormatSize(bmp.PixelFormat) / <span class="number">8</span>;</span><br><span class="line">	var imgBytes = bmp.Height * rowBytes;</span><br><span class="line">	byte[] rgbValues = new byte[imgBytes];</span><br><span class="line">	IntPtr ptr = bmpData.Scan0;</span><br><span class="line">	<span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; bmp.Height; i++)</span><br><span class="line">	{</span><br><span class="line">		Marshal.Copy(ptr, rgbValues, i * rowBytes, rowBytes);   <span class="comment">//对齐</span></span><br><span class="line">		ptr += bmpData.Stride; <span class="comment">// next row</span></span><br><span class="line">	}</span><br><span class="line">	bmp.UnlockBits(bmpData);</span><br><span class="line">	<span class="keyword">return</span> rgbValues;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="c调用托管的dll时出现-引用无效或不支持该引用-的问题"><a class="markdownIt-Anchor" href="#c调用托管的dll时出现-引用无效或不支持该引用-的问题"></a> C# 调用托管的 DLL 时，出现 “引用无效或不支持该引用” 的问题？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353880.png" alt=""></li><li>原因：编译得到的 DLL 是非托管的，不能使用引用导入</li></ul><h3 id="c静态调用dll中非托管函数时出现-systementrypointnotfoundexception"><a class="markdownIt-Anchor" href="#c静态调用dll中非托管函数时出现-systementrypointnotfoundexception"></a> C# 静态调用 DLL 中非托管函数时，出现 “System.EntryPointNotFoundException” ？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353881.png" alt=""></li><li>原因： DllImport 的 EntryPoint 属性和 DLL 的函数不一致</li><li>方法一：在 VS2019 的终端上，使用命令 dumpbin /exports convertPython.dll 查看 DLL 对外开放的函数名，然后将查到的名字填到 EntryPoint 上 <img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121353882.png" alt=""></li><li>方法二：在生成 DLL 时，按以下方式编写，设定函数对外开放接口命名格式，其他格式看 DLL 函数的调用约定？<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">{</span><br><span class="line">	_declspec(dllexport) <span class="type">char</span> _great_function(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">int</span> b);</span><br><span class="line">	_declspec(dllexport) <span class="type">void</span> _startLedCheck(byte* ImageBuffer, <span class="type">int</span> imageWedth, <span class="type">int</span> imageHeight);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><hr><h3 id="什么是marshal类"><a class="markdownIt-Anchor" href="#什么是marshal类"></a> 什么是 Marshal 类？</h3><ul><li>提供了一个方法集合，这些方法用于分配非托管内存、复制非托管内存块、将托管类型转换为非托管类型，此外还提供了在与非托管代码交互时使用的其他杂项方法</li></ul><h3 id="marshal类的allochglobal方法"><a class="markdownIt-Anchor" href="#marshal类的allochglobal方法"></a> Marshal 类的 AllocHGlobal () 方法？</h3><ul><li>从进程的非托管内存中分配内存<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Demonstrate how to call GlobalAlloc and</span></span><br><span class="line"><span class="comment">// GlobalFree using the Marshal class.</span></span><br><span class="line">IntPtr hglobal = Marshal.AllocHGlobal(<span class="number">100</span>);</span><br><span class="line">Marshal.FreeHGlobal(hglobal);</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="marshal类的copy-方法"><a class="markdownIt-Anchor" href="#marshal类的copy-方法"></a> Marshal 类的 Copy () 方法？</h3><ul><li>将数据从托管内存复制到非托管内存指针<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// Create a managed array.</span></span><br><span class="line">		<span class="built_in">byte</span>[] managedArray = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> };</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize unmanaged memory to hold the array.</span></span><br><span class="line">		<span class="built_in">int</span> size = Marshal.SizeOf(managedArray[<span class="number">0</span>]) * managedArray.Length;</span><br><span class="line"></span><br><span class="line">		IntPtr pnt = Marshal.AllocHGlobal(size);</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		{</span><br><span class="line">			<span class="comment">// Copy the array to unmanaged memory.</span></span><br><span class="line">			Marshal.Copy(managedArray, <span class="number">0</span>, pnt, managedArray.Length);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Copy the unmanaged array back to another managed array.</span></span><br><span class="line">			<span class="built_in">byte</span>[] managedArray2 = <span class="keyword">new</span> <span class="built_in">byte</span>[managedArray.Length];</span><br><span class="line"></span><br><span class="line">			Marshal.Copy(pnt, managedArray2, <span class="number">0</span>, managedArray.Length);</span><br><span class="line">			Console.WriteLine(<span class="string">"The array was copied to unmanaged memory and back."</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		{</span><br><span class="line">			<span class="comment">// Free the unmanaged memory.</span></span><br><span class="line">			Marshal.FreeHGlobal(pnt);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="marshal类的freehglobal方法"><a class="markdownIt-Anchor" href="#marshal类的freehglobal方法"></a> Marshal 类的 FreeHGlobal () 方法？</h3><ul><li>释放以前从进程的非托管内存中分配的内存<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Demonstrate how to call GlobalAlloc and</span></span><br><span class="line"><span class="comment">// GlobalFree using the Marshal class.</span></span><br><span class="line">IntPtr hglobal = Marshal.AllocHGlobal(<span class="number">100</span>);</span><br><span class="line">Marshal.FreeHGlobal(hglobal);</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="marshal类的ptrtostringansi方法"><a class="markdownIt-Anchor" href="#marshal类的ptrtostringansi方法"></a> Marshal 类的 PtrToStringAnsi () 方法？</h3><ul><li>将非托管 ANSI 或 UTF-8 字符串中第一个空字符之前的所有字符复制到托管 String，并将每个字符扩展为 UTF-16 字符<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">System</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">System</span>::<span class="title">Runtime</span>::<span class="title">InteropServices</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span>()</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Create an unmanaged c string.</span></span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">char</span> * myString = <span class="string">"Hello managed world (from the unmanaged world)!"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Convert the c string to a managed String.</span></span><br><span class="line">	String ^ myManagedString = Marshal::PtrToStringAnsi((IntPtr) (<span class="built_in">char</span> *) myString);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Display the string to the console.</span></span><br><span class="line">	Console::WriteLine(myManagedString);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="marshal类的ptrtostructure方法"><a class="markdownIt-Anchor" href="#marshal类的ptrtostructure方法"></a> Marshal 类的 PtrToStructure () 方法？</h3><ul><li>将数据从非托管内存块封送到托管对象<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Point</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// Create a point struct.</span></span><br><span class="line">		Point p;</span><br><span class="line">		p.x = <span class="number">1</span>;</span><br><span class="line">		p.y = <span class="number">1</span>;</span><br><span class="line">		Console.WriteLine(<span class="string">"The value of first point is "</span> + p.x + <span class="string">" and "</span> + p.y + <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize unmanged memory to hold the struct.</span></span><br><span class="line">		IntPtr pnt = Marshal.AllocHGlobal(Marshal.SizeOf(p));</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		{</span><br><span class="line">			<span class="comment">// Copy the struct to unmanaged memory.</span></span><br><span class="line">			Marshal.StructureToPtr(p, pnt, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Create another point.</span></span><br><span class="line">			Point anotherP;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Set this Point to the value of the</span></span><br><span class="line">			<span class="comment">// Point in unmanaged memory.</span></span><br><span class="line">			anotherP = (Point)Marshal.PtrToStructure(pnt, <span class="keyword">typeof</span>(Point));</span><br><span class="line">			Console.WriteLine(<span class="string">"The value of new point is "</span> + anotherP.x + <span class="string">" and "</span> + anotherP.y + <span class="string">"."</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		{</span><br><span class="line">			<span class="comment">// Free the unmanaged memory.</span></span><br><span class="line">			Marshal.FreeHGlobal(pnt);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="marshal类的sizeof方法"><a class="markdownIt-Anchor" href="#marshal类的sizeof方法"></a> Marshal 类的 SizeOf () 方法？</h3><ul><li>返回对象的非托管大小（以字节为单位）<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Point</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// Create a point struct.</span></span><br><span class="line">		Point p;</span><br><span class="line">		p.x = <span class="number">1</span>;</span><br><span class="line">		p.y = <span class="number">1</span>;</span><br><span class="line">		Console.WriteLine(<span class="string">"The value of first point is "</span> + p.x + <span class="string">" and "</span> + p.y + <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize unmanged memory to hold the struct.</span></span><br><span class="line">		IntPtr pnt = Marshal.AllocHGlobal(Marshal.SizeOf(p));</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		{</span><br><span class="line">			<span class="comment">// Copy the struct to unmanaged memory.</span></span><br><span class="line">			Marshal.StructureToPtr(p, pnt, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Create another point.</span></span><br><span class="line">			Point anotherP;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Set this Point to the value of the</span></span><br><span class="line">			<span class="comment">// Point in unmanaged memory.</span></span><br><span class="line">			anotherP = (Point)Marshal.PtrToStructure(pnt, <span class="keyword">typeof</span>(Point));</span><br><span class="line">			Console.WriteLine(<span class="string">"The value of new point is "</span> + anotherP.x + <span class="string">" and "</span> + anotherP.y + <span class="string">"."</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		{</span><br><span class="line">			<span class="comment">// Free the unmanaged memory.</span></span><br><span class="line">			Marshal.FreeHGlobal(pnt);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="marshal类的stringtohglobaluni方法"><a class="markdownIt-Anchor" href="#marshal类的stringtohglobaluni方法"></a> Marshal 类的 StringToHGlobalUni () 方法？</h3><ul><li>将托管 String 的内容复制到非托管内存</li></ul><h3 id="marshal类如何将void指针转为intptr"><a class="markdownIt-Anchor" href="#marshal类如何将void指针转为intptr"></a> Marshal 类如何将 void * 指针转为 IntPtr？</h3><ul><li>规定 void 类型的指针可以指向任何数据类型，只不过在 c 函数实体内强制为你的数据类型即可，比如<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数：int fnAdd(struct mybuf *p_mydata)，或者写成int fnAdd(void *p_mydata)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mybuf</span>*p = (structmybuf*)p_mydata;</span><br></pre></td></tr></tbody></table></figure></li><li>C++：接口声明<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A            </span><br><span class="line">{</span><br><span class="line">	wchar_t osdbuffer[<span class="number">100</span>];             </span><br><span class="line">	unsigned <span class="built_in">short</span> ix;                      </span><br><span class="line">	unsigned <span class="built_in">short</span> iy;                      </span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">SetConfig</span>(<span class="params"><span class="built_in">int</span> type, <span class="keyword">void</span>* p</span>)</span>; <span class="comment">// 声明接口</span></span><br></pre></td></tr></tbody></table></figure></li><li>C#：声明调用<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode，Pack = 4)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> A {</span><br><span class="line">	[<span class="meta">MarshalAs(UnmanagedType.ByValTStr, SizeConst = 100)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> osdbuffer;        </span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">ushort</span> ix;                       <span class="comment">//显示坐标x</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">ushort</span> iy;                       <span class="comment">//显示坐标y</span></span><br><span class="line">}</span><br><span class="line">A s_a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">int</span> lenght = Marshal.SizeOf(s_a);</span><br><span class="line">IntPtr pA= Marshal.AllocHGlobal(lenght);</span><br><span class="line">Marshal.StructureToPtr(s_a, pA, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">int</span> type = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> ret = SetConfig( type, pA);</span><br><span class="line">Marshal.FreeHGlobal(pA);</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="marshal类如何将byte转intptr"><a class="markdownIt-Anchor" href="#marshal类如何将byte转intptr"></a> Marshal 类如何将 byte [] 转 IntPtr？</h3><ul><li>不使用 Marshal 创建新的堆，节省内存开销，也避免忘记释放导致的问题<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(array, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="marshal类如何将intptr转byte"><a class="markdownIt-Anchor" href="#marshal类如何将intptr转byte"></a> Marshal 类如何将 IntPtr 转 byte []？</h3><ul><li><strong>Copy</strong> ：使用 Marshal 对数据进行拷贝，该操作速度较慢并且会引入新空间的开辟<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntPtr intPtr = GetBuff();</span><br><span class="line"><span class="built_in">byte</span>[] b = <span class="keyword">new</span> <span class="built_in">byte</span>[length];</span><br><span class="line">Marshal.Copy(intPtr, b, <span class="number">0</span>, length);</span><br></pre></td></tr></tbody></table></figure></li><li><strong>byte</strong>*：该操作不会开辟新的空间，速度极快，但必须在 unsafe 模块下使用<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntPtr pRet = GetBuff();</span><br><span class="line"><span class="built_in">byte</span>* memBytePtr = (<span class="built_in">byte</span>*)pRet.ToPointer();</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="通过marshal方式c封送基础数据类型一维数组到c指针"><a class="markdownIt-Anchor" href="#通过marshal方式c封送基础数据类型一维数组到c指针"></a> 通过 Marshal 方式 C# 封送 “基础数据类型 (一维数组)” 到 C++ 指针？</h3><ul><li>C++ 端定义接口<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPLUSPLUSTEST_API <span class="built_in">int</span> ParsePolygonMarkNum(<span class="built_in">int</span> w, <span class="built_in">int</span> h, <span class="built_in">int</span> drawPointNum, double* drawPoints)</span><br></pre></td></tr></tbody></table></figure></li><li>C# 调用<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double[] allDrawPoint = { <span class="number">326</span>, <span class="number">96</span>, <span class="number">141</span>, <span class="number">618</span>, <span class="number">536</span>, <span class="number">300</span>, <span class="number">127</span>, <span class="number">297</span>, <span class="number">491</span>, <span class="number">613</span> };</span><br><span class="line">double* pointPtr = (double*)Marshal.UnsafeAddrOfPinnedArrayElement(allDrawPoint, <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">int</span> rtnRs = ParsePolygonMarkNum(w, h, nowDrawPoint.Length / <span class="number">2</span>, pointPtr)</span><br></pre></td></tr></tbody></table></figure></li></ul></div><footer class="post-footer"><div class="reward-container"><div>请我一杯咖啡吧！</div><button>赞赏</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="Shaogui 微信"> <span>微信</span></div><div><img src="/images/alipay.png" alt="Shaogui 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Shaogui</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.shaogui.life/posts/3425036573.html" title="CSharp 调用动态链接库 DLL">https://www.shaogui.life/posts/3425036573.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://www.zhihu.com/people/mu-zhi-zhi-tian"><span class="icon"><i class="fab fa-zhihu"></i> </span><span class="label">知乎</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/3630477437.html" rel="prev" title="YOLACT++：Better Real-time Instance Segmentation"><i class="fa fa-angle-left"></i> YOLACT++：Better Real-time Instance Segmentation</a></div><div class="post-nav-item"><a href="/posts/1490917501.html" rel="next" title="YOLACT：Real-time Instance Segmentation">YOLACT：Real-time Instance Segmentation <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Shaogui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.9m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">28:48</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a href="https://github.com/WuShaogui" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js","integrity":"sha256-G8ouPAnw4zzMbnAenHnVz6h9XpKbNdOkrqTh7AadyHs="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"WuShaogui/wushaogui.github.io","issue_term":"pathname","theme":"github-light"}</script><script src="/js/third-party/comments/utterances.js"></script></body></html>