<!DOCTYPE html><html lang="zh-CN"><head><style type="text/css">.douban-card-block{display:flex;justify-content:center;align-items:center;width:100%;max-height:400px}.douban-card{display:flex;margin:30px 10px;padding:15px;border-radius:15px;position:relative;justify-content:center;align-items:center;overflow:hidden;color:#faebd7;text-decoration:none}.douban-card:hover{text-decoration:none}.douban-card-bgimg{position:absolute;width:115%;height:115%;filter:blur(15px) brightness(.6);background-size:100%;background-position:center;background-repeat:no-repeat}.douban-card-img{position:relative;height:130px;width:80px;background-size:100%;background-position:center;background-repeat:no-repeat}.douban-card-left:hover .douban-card-img{filter:blur(5px) brightness(.6);transform:perspective(800px) rotateX(180deg)}.douban-card-left .douban-card-img{transition:all .5s ease}.douban-card-left{position:relative;display:flex;flex-direction:column;align-items:center}.douban-card-left .douban-card-status{height:130px;width:80px;text-align:center;font-weight:700;position:absolute;left:0;top:30%;transform:rotateX(180deg);backface-visibility:hidden;transition:all .5s ease}.douban-card-left:hover .douban-card-status{transform:perspective(800px) rotateX(0)}.douban-card-right{position:relative;display:flex;flex-direction:column;margin-left:12px;font-size:16px;font-family:"Courier New",Courier,monospace;line-height:1.3;color:#faebd7}.douban-card-item{margin-top:4px}</style><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Roboto+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=PT+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"www.shaogui.life","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat","show_result":true},"fold":{"enable":true,"height":200},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="形态学的概念与应用，由膨胀腐蚀到开运算闭运算，再到顶帽黑帽运算，最终介绍这些运算在提取边界、校准光照的作用"><meta property="og:type" content="article"><meta property="og:title" content="B06 - 图像处理 - 形态转换"><meta property="og:url" content="https://www.shaogui.life/posts/1386421913.html"><meta property="og:site_name" content="年轻人起来冲"><meta property="og:description" content="形态学的概念与应用，由膨胀腐蚀到开运算闭运算，再到顶帽黑帽运算，最终介绍这些运算在提取边界、校准光照的作用"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430563.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430028.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430069.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430095.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430760.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430202.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430344.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430796.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430848.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431781.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431383.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431067.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431650.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431277.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431309.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431124.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431896.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431228.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431322.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431422.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431735.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431172.png"><meta property="og:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431980.png"><meta property="article:published_time" content="2022-04-19T16:19:51.000Z"><meta property="article:modified_time" content="2025-01-18T11:05:43.929Z"><meta property="article:author" content="Shaogui"><meta property="article:tag" content="opencv"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430563.png"><link rel="canonical" href="https://www.shaogui.life/posts/1386421913.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.shaogui.life/posts/1386421913.html","path":"posts/1386421913.html","title":"B06 - 图像处理 - 形态转换"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>B06 - 图像处理 - 形态转换 | 年轻人起来冲</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><link rel="alternate" href="/atom.xml" title="年轻人起来冲" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">年轻人起来冲</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">77</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">70</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">544</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%A2%E6%80%81%E5%AD%A6"><span class="nav-number">1.</span> <span class="nav-text">什么是形态学？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8A%E4%BB%80%E4%B9%88%E6%98%AF%E8%85%90%E8%9A%80-erode"><span class="nav-number">2.</span> <span class="nav-text">图像处理上，什么是腐蚀 (erode)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8A%E4%BB%80%E4%B9%88%E6%98%AF%E8%86%A8%E8%83%80dilate"><span class="nav-number">3.</span> <span class="nav-text">图像处理上，什么是膨胀 (dilate)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E8%85%90%E8%9A%80%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">图像腐蚀的原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E8%86%A8%E8%83%80%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">图像膨胀的原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%86%A8%E8%83%80-%E8%85%90%E8%9A%80%E4%B8%8E%E6%BB%A4%E6%B3%A2%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">6.</span> <span class="nav-text">膨胀、腐蚀与滤波的异同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%80%E8%BF%90%E7%AE%97"><span class="nav-number">7.</span> <span class="nav-text">什么是开运算？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E8%BF%90%E7%AE%97"><span class="nav-number">8.</span> <span class="nav-text">什么是闭运算？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%B6%E5%B8%BD%E5%8F%98%E6%8D%A2"><span class="nav-number">9.</span> <span class="nav-text">什么是顶帽变换？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%BB%91%E5%B8%BD%E5%8F%98%E6%8D%A2"><span class="nav-number">10.</span> <span class="nav-text">什么是黑帽变换？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%A2%E6%80%81%E5%AD%A6%E6%A2%AF%E5%BA%A6"><span class="nav-number">11.</span> <span class="nav-text">什么是形态学梯度？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BB%E4%B8%AD-%E5%87%BB%E4%B8%8D%E4%B8%AD%E5%8F%98%E6%8D%A2"><span class="nav-number">12.</span> <span class="nav-text">击中 - 击不中变换？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BB%E4%B8%AD-%E5%87%BB%E4%B8%8D%E4%B8%AD%E7%94%A8%E4%BA%8E%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB"><span class="nav-number">13.</span> <span class="nav-text">击中 - 击不中用于特征识别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E7%AE%97%E6%B3%95%E4%B9%8B%E8%BE%B9%E7%95%8C%E6%8F%90%E5%8F%96"><span class="nav-number">14.</span> <span class="nav-text">形态算法之边界提取？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E7%AE%97%E6%B3%95%E4%B9%8B%E7%A9%BA%E6%B4%9E%E5%A1%AB%E5%85%85"><span class="nav-number">15.</span> <span class="nav-text">形态算法之空洞填充？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%90%E5%8F%96%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">16.</span> <span class="nav-text">形态算法之提取联通分量？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E7%AE%97%E6%B3%95%E4%B9%8B%E5%87%B8%E5%A3%B3"><span class="nav-number">17.</span> <span class="nav-text">形态算法之凸壳？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BB%86%E5%8C%96"><span class="nav-number">18.</span> <span class="nav-text">形态算法之细化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E7%AE%97%E6%B3%95%E4%B9%8B%E9%AA%A8%E6%9E%B6"><span class="nav-number">19.</span> <span class="nav-text">形态算法之骨架？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E5%AD%A6%E4%B9%8B%E6%8F%90%E5%8F%96%E6%B0%B4%E5%B9%B3%E5%92%8C%E5%9E%82%E7%9B%B4%E7%BA%BF"><span class="nav-number">20.</span> <span class="nav-text">形态学之提取水平和垂直线？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E5%AD%A6%E4%B9%8B%E7%81%B0%E5%BA%A6%E9%A1%B6%E5%B8%BD%E5%8F%98%E6%8D%A2%E6%A0%A1%E6%AD%A3%E9%98%B4%E5%BD%B1"><span class="nav-number">21.</span> <span class="nav-text">形态学之灰度顶帽变换校正阴影？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E5%AD%A6%E4%B9%8B%E7%81%B0%E5%BA%A6%E5%BA%95%E5%B8%BD%E5%8F%98%E6%8D%A2%E6%A0%A1%E6%AD%A3%E5%85%89%E7%85%A7"><span class="nav-number">22.</span> <span class="nav-text">形态学之灰度底帽变换校正光照？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E5%AD%A6%E4%B9%8B%E6%8F%90%E5%8F%96%E6%B0%B4%E5%B9%B3%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91"><span class="nav-number">23.</span> <span class="nav-text">形态学之提取水平图像平滑？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E5%AD%A6%E4%B9%8B%E7%BA%B9%E7%90%86%E5%88%86%E5%89%B2"><span class="nav-number">24.</span> <span class="nav-text">形态学之纹理分割？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E5%AD%A6%E4%B9%8B%E8%BE%B9%E7%BC%98%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B"><span class="nav-number">25.</span> <span class="nav-text">形态学之边缘角点检测？</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Shaogui" src="/images/avatar-2023.png"><p class="site-author-name" itemprop="name">Shaogui</p><div class="site-description" itemprop="description">害怕失败是本能，勇敢面对才是本事</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">544</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">70</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">77</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/WuShaogui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;WuShaogui" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/mu-zhi-zhi-tian" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;mu-zhi-zhi-tian" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>知乎</a></span></div><div class="cc-license animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://manaai.cn/" title="http:&#x2F;&#x2F;manaai.cn&#x2F;" rel="noopener" target="_blank">神力AI</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.shaogui.life/posts/1386421913.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar-2023.png"><meta itemprop="name" content="Shaogui"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="年轻人起来冲"><meta itemprop="description" content="害怕失败是本能，勇敢面对才是本事"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="B06 - 图像处理 - 形态转换 | 年轻人起来冲"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">B06 - 图像处理 - 形态转换</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-04-20 00:19:51" itemprop="dateCreated datePublished" datetime="2022-04-20T00:19:51+08:00">2022-04-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-18 19:05:43" itemprop="dateModified" datetime="2025-01-18T19:05:43+08:00">2025-01-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/" itemprop="url" rel="index"><span itemprop="name">3-编程实践</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/E-OpenCV/" itemprop="url" rel="index"><span itemprop="name">E-OpenCV</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/E-OpenCV/OpenCV%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" itemprop="url" rel="index"><span itemprop="name">OpenCV使用指南</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>19k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>17 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>形态学的概念与应用，由膨胀腐蚀到开运算闭运算，再到顶帽黑帽运算，最终介绍这些运算在提取边界、校准光照的作用</p><span id="more"></span><h3 id="什么是形态学"><a class="markdownIt-Anchor" href="#什么是形态学"></a> 什么是形态学？</h3><ul><li>形态学是生物学的概念，主要研究动植物的形态和结构。数学形态学是建立在集合论和拓扑学基础之上的图像分析学科</li><li><strong>图像处理中的形态学</strong>：指基于形状的图像处理操作，以数学形态学为工具从图像中提取表达和描绘区域形状的图像结构信息，如边界、骨架、凸壳等</li><li><strong>形态学运算</strong>：包括：二值腐蚀和膨胀，二值开闭运算，骨架抽取，极限腐蚀，击中击不中变换，形态学梯度，顶帽变换，颗粒分析，流域变换，灰值腐蚀和膨胀，灰值开闭运算，灰值形态学梯度等</li><li><strong>形态学基本思想</strong>：利用结构元素测量或提取输入图像中的形状或特征，以便进行图像分析和目标识别。形态学操作都是基于各种形状的结构元，结构元对输入图像进行操作得到输出图像。腐蚀和膨胀是图像处理中最基本的形态学操作</li></ul><h3 id="图像处理上什么是腐蚀-erode"><a class="markdownIt-Anchor" href="#图像处理上什么是腐蚀-erode"></a> 图像处理上，什么是腐蚀 (erode)？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430563.png" alt=""></li><li>腐蚀类似于 “领域被蚕食”，将图像中的高亮区域或白色部分进行缩减细化，其运行结果图比原图的高亮区域更小<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/Fig0905a.tif"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY | cv2.THRESH_OTSU)  <span class="comment"># 二值化处理</span></span><br><span class="line"><span class="comment"># 图像腐蚀</span></span><br><span class="line">kSize = (<span class="number">3</span>, <span class="number">3</span>)  <span class="comment"># 卷积核的尺寸</span></span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)  <span class="comment"># 生成盒式卷积核</span></span><br><span class="line">imgErode1 = cv2.erode(imgBin, kernel=kernel)  <span class="comment"># 图像腐蚀</span></span><br><span class="line">kSize = (<span class="number">9</span>, <span class="number">9</span>)</span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)</span><br><span class="line">imgErode2 = cv2.erode(imgBin, kernel=kernel)</span><br><span class="line">kSize = (<span class="number">25</span>, <span class="number">25</span>)</span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)</span><br><span class="line">imgErode3 = cv2.erode(imgBin, kernel=kernel)</span><br><span class="line">show_images([imgGray,imgErode1,imgErode2,imgErode3])</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="图像处理上什么是膨胀dilate"><a class="markdownIt-Anchor" href="#图像处理上什么是膨胀dilate"></a> 图像处理上，什么是膨胀 (dilate)？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430028.png" alt=""></li><li>膨胀类似于 “领域扩张”，将图像中的高亮区域或白色部分进行扩张，其运行结果图比原图的高亮区域更大<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/handwriting01.png"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY | cv2.THRESH_OTSU)  <span class="comment"># 二值化处理</span></span><br><span class="line"><span class="comment"># 图像膨胀</span></span><br><span class="line">kSize = (<span class="number">3</span>, <span class="number">3</span>)  <span class="comment"># 卷积核的尺寸</span></span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)  <span class="comment"># 生成盒式卷积核</span></span><br><span class="line">imgDilate1 = cv2.dilate(imgBin, kernel=kernel)  <span class="comment"># 图像膨胀</span></span><br><span class="line">kSize = (<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)</span><br><span class="line">imgDilate2 = cv2.dilate(imgBin, kernel=kernel)  <span class="comment"># 图像膨胀</span></span><br><span class="line">kSize = (<span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)</span><br><span class="line">imgDilate3 = cv2.dilate(imgBin, kernel=kernel)  <span class="comment"># 图像膨胀</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="图像腐蚀的原理"><a class="markdownIt-Anchor" href="#图像腐蚀的原理"></a> 图像腐蚀的原理？</h3><ul><li>使用 cv: :getStructuringElement 定义核矩阵，将核矩阵与源矩阵对齐后，核矩阵开始遍历扫描源矩阵，<strong>核矩阵上锚点位置对应的像素值为该核矩阵对应源矩阵像素值的最小值</strong></li><li>从左到右，依次是源图像素矩阵，核矩阵，腐蚀后结果矩阵，膨胀后结果矩阵，分别记为 A，B，C，D <img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430069.png" alt=""></li><li>如图 A (2,2)=1，A (8,9)=64，</li></ul><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>9</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">C(3,3)=min(A(2,2),A(2,3),A(2,4),A(3,2),A(3,3),A(3,4),A(4,2),A(4,3),A(4,4))=min(1,2,3,2,4,6,3,6,9)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">4</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">4</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">4</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">9</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></span></p><h3 id="图像膨胀的原理"><a class="markdownIt-Anchor" href="#图像膨胀的原理"></a> 图像膨胀的原理？</h3><ul><li>使用 cv: :getStructuringElement 定义核矩阵，将核矩阵与源矩阵对齐后，核矩阵开始遍历扫描源矩阵，<strong>核矩阵上锚点位置对应的像素值为该核矩阵对应源矩阵像素值的最大值</strong></li><li>从左到右，依次是源图像素矩阵，核矩阵，腐蚀后结果矩阵，膨胀后结果矩阵，分别记为 A，B，C，D <img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430095.png" alt=""></li><li>如图 A (2,2)=1，A (8,9)=64，</li></ul><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mn>5</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>5</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>5</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mn>6</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>9</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>16</mn><mo separator="true">,</mo><mn>20</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>20</mn><mo separator="true">,</mo><mn>25</mn><mo stretchy="false">)</mo><mo>=</mo><mn>25</mn></mrow><annotation encoding="application/x-tex">D(5,5)=max(A(4,4),A(4,5),A(4,6),A(5,4),A(5,5),A(5,6),A(6,4),A(6,5),A(6,6))=min(9,12,15,12,16,20,15,20,25)=25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">D</span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">4</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">6</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">4</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">6</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">4</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">6</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">5</span></span></span></span></span></p><h3 id="膨胀-腐蚀与滤波的异同"><a class="markdownIt-Anchor" href="#膨胀-腐蚀与滤波的异同"></a> 膨胀、腐蚀与滤波的异同？</h3><ul><li>都是使用卷积核对源矩阵进行扫描，并通过卷积核与对应的源矩阵的运算决定目标矩阵在锚点位置的值</li><li>滤波是卷积核与源矩阵进行<strong>乘积和</strong>得到锚点位置的值，而腐蚀、膨胀则是卷积核对应区域的<strong>最小值或最大值</strong>，填充锚点位置的值</li></ul><h3 id="什么是开运算"><a class="markdownIt-Anchor" href="#什么是开运算"></a> 什么是开运算？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430760.png" alt=""></li><li><strong>先腐蚀后膨胀</strong>的过程，通常用于去除噪点、断开狭窄的狭颈、消除细长的突出、平滑物体边界但不改变面积<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/Fig0905a.tif"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY | cv2.THRESH_OTSU)  <span class="comment"># 二值化处理</span></span><br><span class="line"><span class="comment"># 图像腐蚀</span></span><br><span class="line">kSize = (<span class="number">3</span>, <span class="number">3</span>)  <span class="comment"># 卷积核的尺寸</span></span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)  <span class="comment"># 生成盒式卷积核</span></span><br><span class="line">imgErode = cv2.erode(imgBin, kernel=kernel)  <span class="comment"># 图像腐蚀</span></span><br><span class="line"><span class="comment"># 图像的开运算</span></span><br><span class="line">kSize = (<span class="number">3</span>, <span class="number">3</span>)  <span class="comment"># 卷积核的尺寸</span></span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)  <span class="comment"># 生成盒式卷积核</span></span><br><span class="line">imgOpen = cv2.morphologyEx(imgGray, cv2.MORPH_OPEN, kernel)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是闭运算"><a class="markdownIt-Anchor" href="#什么是闭运算"></a> 什么是闭运算？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430202.png" alt=""></li><li><strong>先膨胀后腐蚀</strong>的过程，通常用于弥合狭窄的断裂和细长的沟壑，消除小孔，填补轮廓中的缝隙，消除噪点，连接相邻的部分<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/handwriting01.png"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">mu, sigma = <span class="number">0.0</span>, <span class="number">10.0</span></span><br><span class="line">noiseGause = np.random.normal(mu, sigma, imgGray.shape)</span><br><span class="line">imgNoisy = imgGray + noiseGause</span><br><span class="line">imgNoisy = np.uint8(cv2.normalize(imgNoisy, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX))  <span class="comment"># 归一化为 [0,255]</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgNoisy, <span class="number">125</span>, <span class="number">255</span>, cv2.THRESH_BINARY | cv2.THRESH_OTSU)  <span class="comment"># 二值化处理</span></span><br><span class="line"><span class="comment"># 图像的闭运算</span></span><br><span class="line">kSize = (<span class="number">2</span>, <span class="number">2</span>)  <span class="comment"># 卷积核的尺寸</span></span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)  <span class="comment"># 生成盒式卷积核</span></span><br><span class="line">imgClose1 = cv2.morphologyEx(imgBin, cv2.MORPH_CLOSE, kernel)</span><br><span class="line">kSize = (<span class="number">3</span>, <span class="number">3</span>)  <span class="comment"># 卷积核的尺寸</span></span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)  <span class="comment"># 生成盒式卷积核</span></span><br><span class="line">imgClose2 = cv2.morphologyEx(imgBin, cv2.MORPH_CLOSE, kernel)</span><br><span class="line">kSize = (<span class="number">5</span>, <span class="number">5</span>)  <span class="comment"># 卷积核的尺寸</span></span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)  <span class="comment"># 生成盒式卷积核</span></span><br><span class="line">imgClose3 = cv2.morphologyEx(imgBin, cv2.MORPH_CLOSE, kernel)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是顶帽变换"><a class="markdownIt-Anchor" href="#什么是顶帽变换"></a> 什么是顶帽变换？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430344.png" alt=""></li><li>顶帽变换就是用<strong>源图像减去开运算</strong> 图像。因为开运算带来的结果是放大了裂缝或者局部低亮度的区域。因此，从原图中减去开运算后的图，得到的效果图突出了比原图轮廓周围区域更明亮的区域。<strong>顶帽一般用于校正不均匀光照的影响</strong><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/Fig0726a.tif"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">205</span>, <span class="number">255</span>, cv2.THRESH_BINARY | cv2.THRESH_OTSU)  <span class="comment"># 二值化处理</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)  <span class="comment"># 卷积核</span></span><br><span class="line">imgOpen = cv2.morphologyEx(imgBin, cv2.MORPH_OPEN, kernel)  <span class="comment"># 开运算</span></span><br><span class="line">imgThat = cv2.morphologyEx(imgBin, cv2.MORPH_TOPHAT, kernel)  <span class="comment"># 顶帽运算</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="什么是黑帽变换"><a class="markdownIt-Anchor" href="#什么是黑帽变换"></a> 什么是黑帽变换？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430796.png" alt=""></li><li>黑帽变换就是用<strong>闭运算减去源图像</strong>。黑帽运算后的效果图突出了比原图轮廓周围的区域更暗的区域。<strong>黑帽运算一般用来分离比邻近点暗一些的斑块</strong><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/Fig0338a.tif"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY | cv2.THRESH_OTSU)  <span class="comment"># 二值化处理</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)  <span class="comment"># 卷积核</span></span><br><span class="line">imgClose = cv2.morphologyEx(imgBin, cv2.MORPH_CLOSE, kernel)  <span class="comment"># 闭运算</span></span><br><span class="line">imgBhat = cv2.morphologyEx(imgBin, cv2.MORPH_BLACKHAT, kernel)  <span class="comment"># 底帽运算</span></span><br></pre></td></tr></tbody></table></figure></li></ul><hr><h3 id="什么是形态学梯度"><a class="markdownIt-Anchor" href="#什么是形态学梯度"></a> 什么是形态学梯度？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121430848.png" alt=""></li><li>图像的形态学梯度运算，是<strong>膨胀图像与腐蚀图像之差</strong>，可以得到图像的轮廓，通常用于提取物体边缘<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取原始图像</span></span><br><span class="line">imgGray = cv2.imread(<span class="string">"../images/handwriting03.png"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">15</span>, <span class="number">255</span>, cv2.THRESH_BINARY | cv2.THRESH_OTSU)  <span class="comment"># 二值化处理</span></span><br><span class="line"><span class="comment"># 图像的形态学梯度</span></span><br><span class="line">kSize = (<span class="number">3</span>, <span class="number">3</span>)  <span class="comment"># 卷积核的尺寸</span></span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)  <span class="comment"># 生成盒式卷积核</span></span><br><span class="line">imgGrad1 = cv2.morphologyEx(imgBin, cv2.MORPH_GRADIENT, kernel)  <span class="comment"># 形态学梯度</span></span><br><span class="line">kSize = (<span class="number">5</span>, <span class="number">5</span>)  <span class="comment"># 卷积核的尺寸</span></span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)  <span class="comment"># 生成盒式卷积核</span></span><br><span class="line">imgGrad2 = cv2.morphologyEx(imgBin, cv2.MORPH_GRADIENT, kernel)  <span class="comment"># 形态学梯度</span></span><br><span class="line">kSize = (<span class="number">3</span>, <span class="number">3</span>)  <span class="comment"># 卷积核的尺寸</span></span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)  <span class="comment"># 生成盒式卷积核</span></span><br><span class="line">imgOpen = cv2.morphologyEx(imgBin, cv2.MORPH_OPEN, kernel)  <span class="comment"># 开运算</span></span><br><span class="line">imgOpenGrad = cv2.morphologyEx(imgOpen, cv2.MORPH_GRADIENT, kernel)  <span class="comment"># 形态学梯度</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="击中-击不中变换"><a class="markdownIt-Anchor" href="#击中-击不中变换"></a> 击中 - 击不中变换？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431781.png" alt=""></li><li>击中 - 击不中是形态检测的基本工具，可以实现对象的细化和剪枝操作，常用于物体识别、图像细化<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取原始图像</span></span><br><span class="line">imgGray = cv2.imread(<span class="string">"../images/handwriting03.png"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">25</span>, <span class="number">255</span>, cv2.THRESH_BINARY | cv2.THRESH_OTSU)  <span class="comment"># 二值化处理</span></span><br><span class="line"><span class="comment"># 闭运算</span></span><br><span class="line">kernel = np.ones((<span class="number">3</span>, <span class="number">3</span>), dtype=np.uint8)  <span class="comment"># 生成盒式卷积核</span></span><br><span class="line">imgClose = cv2.morphologyEx(imgBin, cv2.MORPH_CLOSE, kernel)  <span class="comment"># 闭运算</span></span><br><span class="line"><span class="comment"># 击中击不中变换</span></span><br><span class="line">kernB1 = np.array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],[<span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=np.int32)  <span class="comment"># B1</span></span><br><span class="line">kernB2 = np.array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],[<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=np.int32)  <span class="comment"># B2</span></span><br><span class="line">imgH1 = cv2.morphologyEx(imgClose, cv2.MORPH_HITMISS, kernB1)</span><br><span class="line">imgH2 = cv2.morphologyEx(imgClose, cv2.MORPH_HITMISS, kernB2)</span><br><span class="line">imgHMT = cv2.add(imgH1, imgH2)  <span class="comment"># 击中击不中</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="击中-击不中用于特征识别"><a class="markdownIt-Anchor" href="#击中-击不中用于特征识别"></a> 击中 - 击不中用于特征识别？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431383.png" alt=""></li><li>本例使用击中 - 击不中变换进行特征识别，提取绳结特征<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/imgNetrope.png"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">25</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)  <span class="comment"># 二值化处理</span></span><br><span class="line"><span class="comment"># 击中击不中变换</span></span><br><span class="line">kernal1 = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="number">5</span>, <span class="number">5</span>), (-<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line">kernal2 = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="number">9</span>,<span class="number">9</span>), (-<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line">imgHMT1 = cv2.morphologyEx(imgBin, cv2.MORPH_HITMISS, kernal1)</span><br><span class="line">imgHMT2 = cv2.morphologyEx(imgBin, cv2.MORPH_HITMISS, kernal2)</span><br><span class="line">show_images([imgGray,imgHMT1,imgHMT2])</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="形态算法之边界提取"><a class="markdownIt-Anchor" href="#形态算法之边界提取"></a> 形态算法之边界提取？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431067.png" alt=""></li><li>形态学处理的主要应用是提取图像中用来表示和描述形状的元素和成分，例如提取边界、连通分量、凸壳和区域骨架</li><li><strong>边界提取</strong>：通过对目标图像进行腐蚀和膨胀处理，比较结果图像与原图像的差别来实现<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/imgNetrope.png"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">25</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)  <span class="comment"># 二值化处理</span></span><br><span class="line">kSize = (<span class="number">3</span>, <span class="number">3</span>)  <span class="comment"># 卷积核的尺寸</span></span><br><span class="line">kernel = np.ones(kSize, dtype=np.uint8)  <span class="comment"># 生成盒式卷积核</span></span><br><span class="line">imgErode1 = cv2.erode(imgBin, kernel=kernel)  <span class="comment"># 图像腐蚀</span></span><br><span class="line">imgBound1 = imgBin - imgErode1  <span class="comment"># 图像边界提取</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="形态算法之空洞填充"><a class="markdownIt-Anchor" href="#形态算法之空洞填充"></a> 形态算法之空洞填充？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431650.png" alt=""></li><li>孔洞是被前景像素连成的边框包围的背景区域。书法作品图像中存在孔洞，在图像分割后也经常会有一些孔洞</li><li><strong>闭运算孔洞填充：</strong> 形态学闭运算可以用来实现孔洞填充，闭运算先膨胀后腐蚀操作，膨胀使白色高亮区域增加，孔洞会被填充，但需要准确设置核大小，因此不是通用的方法</li><li><strong>约束膨胀孔洞填充：</strong> 先找到孔洞中的一个点，用结构元进行膨胀，然后用原始图像的补集进行约束（交集运算），不断迭代重复这一操作直到算法收敛，就得到孔洞填充图<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/imgBloodCell.png"</span>, flags=<span class="number">0</span>)</span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)  <span class="comment"># 二值化处理</span></span><br><span class="line">imgBinInv = cv2.bitwise_not(imgBin)  <span class="comment"># 二值图像的补集</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># 构造 3×3 十字形结构元</span></span><br><span class="line">F = np.zeros(imgBin.shape, np.uint8)  <span class="comment"># 构建阵列 F，并写入 BinInv 的边界值</span></span><br><span class="line">F[:, <span class="number">0</span>] = imgBinInv[:, <span class="number">0</span>]</span><br><span class="line">F[:, -<span class="number">1</span>] = imgBinInv[:, -<span class="number">1</span>]</span><br><span class="line">F[<span class="number">0</span>, :] = imgBinInv[<span class="number">0</span>, :]</span><br><span class="line">F[-<span class="number">1</span>, :] = imgBinInv[-<span class="number">1</span>, :]</span><br><span class="line"><span class="comment"># 循环迭代：对 F 进行膨胀，膨胀结果与 BinInv 进行 AND 操作</span></span><br><span class="line">Flast = F.copy()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">	F_dilation = cv2.dilate(F, kernel)</span><br><span class="line">	F = cv2.bitwise_and(F_dilation, imgBinInv)</span><br><span class="line">	<span class="keyword">if</span> (F==Flast).<span class="built_in">all</span>():</span><br><span class="line">		<span class="keyword">break</span>  <span class="comment"># 结束迭代算法</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		Flast = F.copy()</span><br><span class="line">	<span class="keyword">if</span> i==<span class="number">100</span>: imgF100 = F  <span class="comment"># 中间结果</span></span><br></pre></td></tr></tbody></table></figure></li><li><strong>泛洪算法孔洞填充：</strong> 也成为 “漫水填充法 “。其原理是将像素点的灰度值视为高度，整个图像就像一张高低起伏的地形图，向洼地注水将会淹没低洼区域，从而实现孔洞填充<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/imgBloodCell.png"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)  <span class="comment"># 二值化处理</span></span><br><span class="line">h, w = imgBin.shape[:<span class="number">2</span>]</span><br><span class="line">mask = np.zeros((h+<span class="number">2</span>, w+<span class="number">2</span>), np.uint8)  <span class="comment"># 掩模图像比原始图像宽 2 个像素、高 2 个像素</span></span><br><span class="line">imgFloodfill = imgBin.copy()</span><br><span class="line">cv2.floodFill(imgFloodfill, mask, (<span class="number">0</span>, <span class="number">0</span>), newVal=<span class="number">225</span>)  <span class="comment"># 算法从背景像素原点 (0, 0) 开始</span></span><br><span class="line">imgFloodfillInv = cv2.bitwise_not(imgFloodfill)  <span class="comment"># 计算补集</span></span><br><span class="line">imgHoleFilled = imgBin | imgFloodfillInv  <span class="comment"># 计算交集</span></span><br><span class="line">imgRebuild = cv2.bitwise_not(imgHoleFilled)  <span class="comment"># 计算补集</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="形态算法之提取联通分量"><a class="markdownIt-Anchor" href="#形态算法之提取联通分量"></a> 形态算法之提取联通分量？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431277.png" alt=""></li><li>提取连通分量的过程也是对连通分量的标注，通常给图像中的每个连通区分配编号，在输出图像中该连通区内的所有的像素值赋值为对应的区域编号，这样的输出图像被称为标注图像<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/Fig0918a.tif"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 读取为灰度图像</span></span><br><span class="line"><span class="comment"># 预处理</span></span><br><span class="line">ret, imgThresh = cv2.threshold(imgGray, <span class="number">200</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)  <span class="comment"># 二值化处理</span></span><br><span class="line">kernel = np.ones((<span class="number">3</span>, <span class="number">3</span>), dtype=np.uint8)  <span class="comment"># 生成盒式卷积核</span></span><br><span class="line">imgClose = cv2.morphologyEx(imgThresh, cv2.MORPH_CLOSE, kernel)  <span class="comment"># 闭运算，消除噪点</span></span><br><span class="line">imgErode = cv2.erode(imgClose, kernel=kernel)  <span class="comment"># 腐蚀运算，腐蚀亮点</span></span><br><span class="line">imgBin = imgErode</span><br><span class="line">imgBinCopy = imgBin.copy()  <span class="comment"># 复制 imgBin</span></span><br><span class="line">xBinary = np.zeros(imgBin.shape, np.uint8)  <span class="comment"># 大小与 img 相同，像素值为 0</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># 3×3结构元</span></span><br><span class="line">count = []  <span class="comment"># 为了记录连通分量中的像素个数</span></span><br><span class="line"><span class="keyword">while</span> imgBinCopy.<span class="built_in">any</span>():  <span class="comment"># 直到 imgBinCopy 中的像素值全部为0</span></span><br><span class="line">	Xa_copy, Ya_copy = np.where(imgBinCopy &gt; <span class="number">0</span>)  <span class="comment"># imgBinCopy 中值为255的像素的坐标</span></span><br><span class="line">	xBinary[Xa_copy[<span class="number">0</span>]][Ya_copy[<span class="number">0</span>]] = <span class="number">255</span>  <span class="comment"># 选取第一个点，并将 xBinary 中对应像素值改为255</span></span><br><span class="line">	<span class="comment"># 约束膨胀，先对 xBinary 膨胀，再与 imgBin 执行与操作（取交集）</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">		dilation_B = cv2.dilate(xBinary, kernel)</span><br><span class="line">		xBinary = cv2.bitwise_and(imgBin, dilation_B)</span><br><span class="line">	<span class="comment"># 取 xBinary 值为255的像素坐标，并将 imgBinCopy 中对应坐标像素值变为0</span></span><br><span class="line">	Xb, Yb = np.where(xBinary &gt; <span class="number">0</span>)</span><br><span class="line">	imgBinCopy[Xb, Yb] = <span class="number">0</span></span><br><span class="line">	<span class="comment"># 显示连通分量及其包含像素数量</span></span><br><span class="line">	count.append(<span class="built_in">len</span>(Xb))</span><br><span class="line">	lenCount = <span class="built_in">len</span>(count)</span><br><span class="line">	<span class="keyword">if</span> lenCount == <span class="number">0</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"无连通分量"</span>)</span><br><span class="line">	<span class="keyword">elif</span> lenCount == <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"第1个连通分量为{}"</span>.<span class="built_in">format</span>(count[<span class="number">0</span>]))</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"第{}个连通分量为{}"</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(count), count[-<span class="number">1</span>]-count[-<span class="number">2</span>]))</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="形态算法之凸壳"><a class="markdownIt-Anchor" href="#形态算法之凸壳"></a> 形态算法之凸壳？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431309.png" alt=""></li><li>几何中，如果连接物体 A 内任意两点的直线段都在 A 的内部，则称 A 是凸的。数字图像处理中，凸集简化为二维平面，且以离散坐标形式表达。数字集合 A 是凸的，当且仅当它的欧氏凸壳只包含属于 A 的数字点<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/imgDemo1.png"</span>, flags=<span class="number">1</span>)</span><br><span class="line">imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  <span class="comment"># 灰度图像</span></span><br><span class="line">imgBlur = cv2.blur(imgGray, (<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># 去除噪点</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgBlur, <span class="number">225</span>, <span class="number">255</span>, cv2.THRESH_BINARY)  <span class="comment"># 二值化处理</span></span><br><span class="line">img2, contours, hierarchy = cv2.findContours(imgBin, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)  <span class="comment"># 寻找所有的轮廓</span></span><br><span class="line">hullAll = []  <span class="comment"># 所有的凸包</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">	hull = cv2.convexHull(contours[i], <span class="literal">False</span>)  <span class="comment"># 计算轮廓的凸包</span></span><br><span class="line">	hullAll.append(hull)</span><br><span class="line">colorContours = (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)  <span class="comment"># 设置轮廓的颜色</span></span><br><span class="line">colorConvexHull = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)  <span class="comment"># 设置凸包的颜色</span></span><br><span class="line">imgContours = np.zeros(img.shape, np.uint8)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):  <span class="comment"># 绘制轮廓线</span></span><br><span class="line">	cv2.drawContours(imgContours, contours, i, colorContours, <span class="number">2</span>, <span class="number">8</span>, hierarchy)</span><br><span class="line">imgDrawing = imgContours.copy()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):  <span class="comment"># 绘制凸包线</span></span><br><span class="line">	cv2.drawContours(imgDrawing, hullAll, i, colorConvexHull, <span class="number">2</span>, <span class="number">8</span>)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="形态算法之细化"><a class="markdownIt-Anchor" href="#形态算法之细化"></a> 形态算法之细化？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431124.png" alt=""></li><li>细化是将图像的线条从多像素宽度减少到单位像素宽度的过程，也称为 "骨架化"、“中轴转换 "和" 对称轴转换”</li><li>形态骨架是一种细化的结构，指图像的骨骼部分，用于描述物体的几何形状和拓扑结构，是目标物体重要的拓扑描述。图像的细化是对二值图像进行骨架提取，删除不需要的轮廓点，只保留其骨架点</li><li>细化过程就是对图像不断重复地逐层边界像素的过程，目标物体随着细化的进行有规律地缩小，但是目标图像边界线的连接性，方向性和特征点不变，最终使变换图像成为单像素宽的图像骨架<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">thinning</span>(<span class="params">image</span>):</span><br><span class="line">	array = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, \</span><br><span class="line">			 <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, \</span><br><span class="line">			 <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, \</span><br><span class="line">			 <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, \</span><br><span class="line">			 <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">			 <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">			 <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, \</span><br><span class="line">			 <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">			 <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, \</span><br><span class="line">			 <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, \</span><br><span class="line">			 <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, \</span><br><span class="line">			 <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">			 <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">			 <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">			 <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">			 <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">	h, w = image.shape[<span class="number">0</span>], image.shape[<span class="number">1</span>]</span><br><span class="line">	imgThin = image.copy()</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">			<span class="keyword">if</span> image[i, j] == <span class="number">0</span>:</span><br><span class="line">				a = np.ones((<span class="number">9</span>,), dtype=np.<span class="built_in">int</span>)</span><br><span class="line">				<span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">					<span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">						<span class="keyword">if</span> -<span class="number">1</span>&lt;(i-<span class="number">1</span>+k)&lt;h <span class="keyword">and</span> -<span class="number">1</span>&lt;(j-<span class="number">1</span>+l)&lt;w <span class="keyword">and</span> imgThin[i-<span class="number">1</span>+k,j-<span class="number">1</span>+l]==<span class="number">0</span>:</span><br><span class="line">							a[k*<span class="number">3</span>+l] = <span class="number">0</span></span><br><span class="line">				<span class="built_in">sum</span> = a[<span class="number">0</span>]*<span class="number">1</span> + a[<span class="number">1</span>]*<span class="number">2</span> + a[<span class="number">2</span>]*<span class="number">4</span> + a[<span class="number">3</span>]*<span class="number">8</span> + a[<span class="number">5</span>]*<span class="number">16</span> + a[<span class="number">6</span>]*<span class="number">32</span> + a[<span class="number">7</span>]*<span class="number">64</span> + a[<span class="number">8</span>]*<span class="number">128</span></span><br><span class="line">				imgThin[i, j] = array[<span class="built_in">sum</span>] * <span class="number">255</span></span><br><span class="line">	<span class="keyword">return</span> imgThin</span><br><span class="line"><span class="comment"># 图像为灰度图像，背景为白色(255)，被细化物体为黑色(0)</span></span><br><span class="line">image = cv2.imread(<span class="string">"../images/imgNetrope.png"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 灰度图像</span></span><br><span class="line">ret, binary = cv2.threshold(image, <span class="number">205</span>, <span class="number">255</span>, cv2.THRESH_BINARY)  <span class="comment"># 二值化处理</span></span><br><span class="line">imgThin = thinning(binary)  <span class="comment"># 细化算法</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="形态算法之骨架"><a class="markdownIt-Anchor" href="#形态算法之骨架"></a> 形态算法之骨架？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431896.png" alt=""></li><li>形态骨架是一种细化的结构，指图像的骨骼部分，用于描述物体的几何形状和拓扑结构，是目标物体重要的拓扑描述。图像的细化是对二值图像进行骨架提取，删除不需要的轮廓点，只保留其骨架点</li><li><strong>步骤</strong>：1）对图像进行腐蚀，腐蚀后的物体变得更窄细；2）对腐蚀后图像做开运算，开运算处理时被删除的像素就是骨骼的一部分，将其加入骨骼图像；3）重复以上过程，直到图像被完全腐蚀<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> morphology</span><br><span class="line">imgGray = cv2.imread(<span class="string">"../images/handwriting01.png"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 灰度图像</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)  <span class="comment"># 二值化处理</span></span><br><span class="line">imgBin[imgBin==<span class="number">255</span>] = <span class="number">1</span></span><br><span class="line">skeleton01 = morphology.skeletonize(imgBin)</span><br><span class="line">skeleton = skeleton01.astype(np.uint8) * <span class="number">255</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="形态学之提取水平和垂直线"><a class="markdownIt-Anchor" href="#形态学之提取水平和垂直线"></a> 形态学之提取水平和垂直线？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431228.png" alt=""></li><li>通过自定义的结构元素，使结构元对输入图像的一些对象敏感，而对另一些对象不敏感，就会滤去敏感对象、保留不敏感对象。对于水平或垂直线，可以通过定义水平线或垂直线的结构元素去除水平线或垂直线的干扰，也可以提取水平或垂直线<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/imgLine2.png"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 灰度图像</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">205</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)  <span class="comment"># 二值化处理，反白</span></span><br><span class="line">h, w = imgBin.shape[<span class="number">0</span>], imgBin.shape[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 提取水平线</span></span><br><span class="line">hline = cv2.getStructuringElement(cv2.MORPH_RECT, ((w//<span class="number">16</span>),<span class="number">1</span>), (-<span class="number">1</span>,-<span class="number">1</span>))  <span class="comment"># 水平结构元</span></span><br><span class="line">imgOpenHline = cv2.morphologyEx(imgBin, cv2.MORPH_OPEN, hline)  <span class="comment"># 开运算提取水平结构</span></span><br><span class="line">imgHline = cv2.bitwise_not(imgOpenHline)  <span class="comment"># 恢复白色背景</span></span><br><span class="line"><span class="comment"># 提取垂直线</span></span><br><span class="line">vline = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">1</span>,(h//<span class="number">16</span>)), (-<span class="number">1</span>,-<span class="number">1</span>))  <span class="comment"># 垂直结构元</span></span><br><span class="line">imgOpenVline = cv2.morphologyEx(imgBin, cv2.MORPH_OPEN, vline)  <span class="comment"># 开运算提取垂直结构</span></span><br><span class="line">imgVline = cv2.bitwise_not(imgOpenVline)</span><br><span class="line">lineRemoved = imgBin - imgOpenHline  <span class="comment"># 删除水平线 (白底为 0)</span></span><br><span class="line">lineRemoved = lineRemoved - imgOpenVline  <span class="comment"># 删除垂直线</span></span><br><span class="line">imgRebuild = cv2.bitwise_not(lineRemoved)  <span class="comment"># 恢复白色背景</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="形态学之灰度顶帽变换校正阴影"><a class="markdownIt-Anchor" href="#形态学之灰度顶帽变换校正阴影"></a> 形态学之灰度顶帽变换校正阴影？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431322.png" alt=""></li><li>均匀光照对于从背景中提取目标十分重要，顶帽变换的重要用途就是校正不均匀光照的影响</li><li>本例图像是在非均匀光照条件下拍摄的，图像底部和右侧的暗色区域比较明显。如果直接用 Otsu 最优阈值处理方法对灰度图像进行二值化处理，在暗区域的分割出现错误，一些米粒未能从背景中提取出来，而在左上角的亮区域则把部分背景理解为米粒<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/Fig0940a.tif"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 灰度图像</span></span><br><span class="line"><span class="comment"># 直接用 Otsu 最优阈值处理方法进行二值化处理</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_OTSU)  <span class="comment"># 二值化处理，黑色背景</span></span><br><span class="line"><span class="comment"># 顶帽运算后再用 Otsu 最优阈值处理方法进行二值化处理</span></span><br><span class="line">element = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="number">50</span>, <span class="number">50</span>))  <span class="comment"># 十字交叉结构元</span></span><br><span class="line">imgThat = cv2.morphologyEx(imgGray, cv2.MORPH_TOPHAT, element)  <span class="comment"># 顶帽运算</span></span><br><span class="line">ret, imgThatBin = cv2.threshold(imgThat, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_OTSU)  <span class="comment"># 二值化处理，黑色背景</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="形态学之灰度底帽变换校正光照"><a class="markdownIt-Anchor" href="#形态学之灰度底帽变换校正光照"></a> 形态学之灰度底帽变换校正光照？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431422.png" alt=""></li><li>图像相减结合开运算和闭运算，就得到顶帽变换和底帽变换<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/imgHat01.png"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 灰度图像</span></span><br><span class="line"><span class="comment"># 直接用 Otsu 最优阈值处理方法进行二值化处理</span></span><br><span class="line">ret, imgBin = cv2.threshold(imgGray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)  <span class="comment"># 二值化处理，白色背景</span></span><br><span class="line"><span class="comment"># 底帽变换后再用 Otsu 最优阈值处理方法进行二值化处理</span></span><br><span class="line">element = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">55</span>, <span class="number">55</span>))  <span class="comment"># 圆形结构元</span></span><br><span class="line">imgBhat = cv2.morphologyEx(imgGray, cv2.MORPH_BLACKHAT, element)  <span class="comment"># 底帽运算</span></span><br><span class="line">ret, imgBhatBin = cv2.threshold(imgBhat, <span class="number">50</span>, <span class="number">255</span>, cv2.THRESH_BINARY |cv2.THRESH_OTSU)  <span class="comment"># 二值化处理，白色背景</span></span><br><span class="line"><span class="comment"># 圆环表面有很多黑色噪点，通过闭操作去除</span></span><br><span class="line">element = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 圆形结构元</span></span><br><span class="line">imgSegment = cv2.morphologyEx(imgBhatBin, cv2.MORPH_CLOSE, element)  <span class="comment"># 闭运算</span></span><br><span class="line">show_iamges([imgGray,imgBin,imgBhat,imgSegment])</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="形态学之提取水平图像平滑"><a class="markdownIt-Anchor" href="#形态学之提取水平图像平滑"></a> 形态学之提取水平图像平滑？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431735.png" alt=""></li><li>由于开运算和闭运算对亮细节和暗细节的抑制作用，对图像先后做开运算和闭运算可以有效地抑制细节，实现平滑图像和去除噪声</li><li>使用开运算和闭运算做形态平滑，就是循环交替地执行开运算和闭运算的操作，把图像像素点的灰度值视为高度，整个图像就像一张高低起伏的地形图。形态学平滑就是不断地挖掉高峰、填平低谷，因此起到了平整地形的功效<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/Fig0938a.tif"</span>, flags=<span class="number">0</span>)  <span class="comment"># flags=0 灰度图像</span></span><br><span class="line"><span class="comment"># 用不同半径圆形结构元依次交替进行开运算-闭运算实现图像平滑</span></span><br><span class="line">kSize = (<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">element = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, kSize)  <span class="comment"># 圆形结构元</span></span><br><span class="line">imgOpen1 = cv2.morphologyEx(imgGray, cv2.MORPH_OPEN, element)  <span class="comment"># 灰度开运算</span></span><br><span class="line">imgClose1 = cv2.morphologyEx(imgOpen1, cv2.MORPH_CLOSE, element)  <span class="comment"># 灰度闭运算</span></span><br><span class="line">imgIter = imgGray.copy()  <span class="comment"># 循环交替进行开运算-闭运算</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">	imgIter = cv2.morphologyEx(imgIter, cv2.MORPH_OPEN, element)</span><br><span class="line">	imgIter = cv2.morphologyEx(imgIter, cv2.MORPH_CLOSE, element)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="形态学之纹理分割"><a class="markdownIt-Anchor" href="#形态学之纹理分割"></a> 形态学之纹理分割？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431172.png" alt=""></li><li>形态学的纹理分割是以纹理内容为基础，找到两个区域的边界，将图像分割为不同的区域<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">imgGray = cv2.imread(<span class="string">"../images/Fig0943a.tif"</span>, flags=<span class="number">0</span>) </span><br><span class="line"><span class="comment"># 根据小斑点直径(25) 设计圆形结构元，用闭运算删除小斑点</span></span><br><span class="line">kSize = (<span class="number">20</span>, <span class="number">20</span>)  <span class="comment"># 结构元半径 10，小于小斑点半径</span></span><br><span class="line">element = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, kSize)  <span class="comment"># 圆形结构元</span></span><br><span class="line">imgClose1 = cv2.morphologyEx(imgGray, cv2.MORPH_CLOSE, element)  <span class="comment"># 灰度闭运算</span></span><br><span class="line">kSize = (<span class="number">60</span>, <span class="number">60</span>)  <span class="comment"># 结构元半径 30，大于小斑点半径</span></span><br><span class="line">element = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, kSize)  <span class="comment"># 圆形结构元</span></span><br><span class="line">imgClose2 = cv2.morphologyEx(imgGray, cv2.MORPH_CLOSE, element)  <span class="comment"># 灰度闭运算</span></span><br><span class="line">kSize = (<span class="number">120</span>, <span class="number">120</span>)  <span class="comment"># 结构元半径 60，大于大斑点半径</span></span><br><span class="line">element = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, kSize)  <span class="comment"># 圆形结构元</span></span><br><span class="line">imgOpen = cv2.morphologyEx(imgClose2, cv2.MORPH_OPEN, element)  <span class="comment"># 灰度开运算</span></span><br><span class="line"><span class="comment"># 形态学梯度得到区域分割的边界</span></span><br><span class="line">kSize = (<span class="number">5</span>, <span class="number">5</span>)  <span class="comment"># 结构元的尺寸</span></span><br><span class="line">element = cv2.getStructuringElement(cv2.MORPH_RECT, kSize)  <span class="comment"># 矩形结构元</span></span><br><span class="line">imgGrad = cv2.morphologyEx(imgOpen, cv2.MORPH_GRADIENT, element)  <span class="comment"># 形态学梯度</span></span><br><span class="line"><span class="comment"># 纹理分割图像重建</span></span><br><span class="line">imgRebuild = cv2.bitwise_or(imgGray, imgGrad)  <span class="comment"># 计算交集</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="形态学之边缘角点检测"><a class="markdownIt-Anchor" href="#形态学之边缘角点检测"></a> 形态学之边缘角点检测？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121431980.png" alt=""></li><li>形态学边缘检测的原理是，图像中的物体在膨胀时向周围扩张，在腐蚀时会发生收缩，变化的区域都只发生在物体的边缘。<strong>图像的形态学梯度运算，是膨胀图像与腐蚀图像之差，可以得到图像的轮廓，通常用于提取物体边缘</strong></li><li>形态学角点检测的原理是，通过十字形、菱形、方形、X 型等不同形状结构元的膨胀腐蚀，使原图像的边缘不发生变化，仅有焦点被腐蚀<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../images/imgBuilding1.png"</span>, flags=<span class="number">1</span>)</span><br><span class="line">imgSign = img.copy()</span><br><span class="line">imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  <span class="comment"># 图片格式转换：BGR(OpenCV) -&gt; Gray</span></span><br><span class="line"><span class="comment"># ret, imgBin = cv2.threshold(imgGray, 127, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)  # 二值化处理</span></span><br><span class="line"><span class="comment"># 边缘检测</span></span><br><span class="line">element = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">imgEdge = cv2.morphologyEx(imgGray, cv2.MORPH_GRADIENT, element)  <span class="comment"># 形态学梯度</span></span><br><span class="line"><span class="comment"># 构造 5×5 结构元素，十字形、菱形、方形、X 型</span></span><br><span class="line">cross = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 十字型结构元</span></span><br><span class="line">square = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 矩形结构元</span></span><br><span class="line">xShape = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># X 形结构元</span></span><br><span class="line">diamond = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 构造菱形结构元</span></span><br><span class="line">diamond[<span class="number">1</span>, <span class="number">1</span>] = diamond[<span class="number">3</span>, <span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">diamond[<span class="number">1</span>, <span class="number">3</span>] = diamond[<span class="number">3</span>, <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(diamond)</span><br><span class="line">imgDilate1 = cv2.dilate(imgGray, cross)  <span class="comment"># 用十字型结构元膨胀原图像</span></span><br><span class="line">imgErode1 = cv2.erode(imgDilate1, diamond)  <span class="comment"># 用菱形结构元腐蚀图像</span></span><br><span class="line">imgDilate2 = cv2.dilate(imgGray, xShape)  <span class="comment"># 使用 X 形结构元膨胀原图像</span></span><br><span class="line">imgErode2 = cv2.erode(imgDilate2, square)  <span class="comment"># 使用方形结构元腐蚀图像</span></span><br><span class="line">imgDiff = cv2.absdiff(imgErode2, imgErode1)  <span class="comment"># 将两幅闭运算的图像相减获得角点</span></span><br><span class="line">retval, thresh = cv2.threshold(imgDiff, <span class="number">40</span>, <span class="number">255</span>, cv2.THRESH_BINARY)  <span class="comment"># # 二值化处理</span></span><br><span class="line"><span class="comment"># 在原图上用半径为 5 的圆圈标记角点</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(thresh.size):</span><br><span class="line">	y = <span class="built_in">int</span>(j / thresh.shape[<span class="number">0</span>])</span><br><span class="line">	x = <span class="built_in">int</span>(j % thresh.shape[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> (thresh[x, y] == <span class="number">255</span>):</span><br><span class="line">		cv2.circle(imgSign, (y, x), <span class="number">5</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br></pre></td></tr></tbody></table></figure></li></ul><p>参考：</p><ol><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123225087">【youcans 的 OpenCV 例程 200 篇】113. 形态学操作之腐蚀_opencv 可以单通道腐蚀操作吗_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123251108">【youcans 的 OpenCV 例程 200 篇】114. 形态学操作之膨胀_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123264366">【youcans 的 OpenCV 例程 200 篇】115. 形态学操作之开运算_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123286023">【youcans 的 OpenCV 例程 200 篇】116. 形态学操作之闭运算_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123305803">【youcans 的 OpenCV 例程 200 篇】117. 形态学操作之顶帽运算_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123306045">【youcans 的 OpenCV 例程 200 篇】118. 形态学操作之底帽运算_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123344496">【youcans 的 OpenCV 例程 200 篇】119. 图像的形态学梯度_图像形态学梯度 opencv linux_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123345073">Site Unreachable</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123368039">【youcans 的 OpenCV 例程 200 篇】121. 击中 - 击不中用于特征识别_opencv 击中击不中_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123415801">【youcans 的 OpenCV 例程 200 篇】122. 形态算法之边界提取_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123415835">【youcans 的 OpenCV 例程 200 篇】123. 形态算法之孔洞填充_数字图像处理孔洞填充的算法_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123415880">【youcans 的 OpenCV 例程 200 篇】124. 孔洞填充的泛洪算法_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123457160">【youcans 的 OpenCV 例程 200 篇】127. 形态算法之细化_deutch 细化算法_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123457114">【youcans 的 OpenCV 例程 200 篇】126. 形态算法之凸壳（Convex hull）_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123457062">【youcans 的 OpenCV 例程 200 篇】125. 形态算法之提取连通分量_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123497811">【youcans 的 OpenCV 例程 200 篇】128. 形态算法之骨架 (skimage)_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123498231">【youcans 的 OpenCV 例程 200 篇】130. 形态学之提取水平和垂直线_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123565771">【youcans 的 OpenCV 例程 200 篇】139. 灰度顶帽变换校正阴影_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123565844">【youcans 的 OpenCV 例程 200 篇】140. 灰度底帽变换校正光照_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123566062">【youcans 的 OpenCV 例程 200 篇】142. 基于灰度形态学的图像平滑_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123786155">【youcans 的 OpenCV 例程 200 篇】144. 基于灰度形态学的纹理分割_opencv 纹理分割_youcans_的博客 - CSDN 博客</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youcans/article/details/123786190">【youcans 的 OpenCV 例程 200 篇】145. 形态学之边缘和角点检测_youcans_的博客 - CSDN 博客</a></li><li></li></ol></div><footer class="post-footer"><div class="reward-container"><div>请我一杯咖啡吧！</div><button>赞赏</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="Shaogui 微信"> <span>微信</span></div><div><img src="/images/alipay.png" alt="Shaogui 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Shaogui</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.shaogui.life/posts/1386421913.html" title="B06 - 图像处理 - 形态转换">https://www.shaogui.life/posts/1386421913.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://www.zhihu.com/people/mu-zhi-zhi-tian"><span class="icon"><i class="fab fa-zhihu"></i> </span><span class="label">知乎</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div></div></div><div class="post-tags"><a href="/tags/opencv/" rel="tag"><i class="fa fa-tag"></i> opencv</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/1727814178.html" rel="prev" title="深度学习的损失函数"><i class="fa fa-angle-left"></i> 深度学习的损失函数</a></div><div class="post-nav-item"><a href="/posts/551539468.html" rel="next" title="深度学习的数学基础">深度学习的数学基础 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Shaogui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">1.9m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">28:48</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a href="https://github.com/WuShaogui" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js","integrity":"sha256-G8ouPAnw4zzMbnAenHnVz6h9XpKbNdOkrqTh7AadyHs="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"WuShaogui/wushaogui.github.io","issue_term":"pathname","theme":"github-light"}</script><script src="/js/third-party/comments/utterances.js"></script></body></html>