<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>年轻人起来冲</title>
  
  
  <link href="https://www.shaogui.life/atom.xml" rel="self"/>
  
  <link href="https://www.shaogui.life/"/>
  <updated>2025-01-19T06:11:19.319Z</updated>
  <id>https://www.shaogui.life/</id>
  
  <author>
    <name>Shaogui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>推荐系统基本认识</title>
    <link href="https://www.shaogui.life/posts/3185024266.html"/>
    <id>https://www.shaogui.life/posts/3185024266.html</id>
    <published>2025-01-16T09:48:00.000Z</published>
    <updated>2025-01-19T06:11:19.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是推荐系统"><a class="markdownIt-Anchor" href="#什么是推荐系统"></a> 什么是推荐系统？</h3><ul><li>推荐系统是信息过滤系统的一个子类，它根据用户的偏好和行为，来向用户呈现他 (或她) 可能感兴趣的物品</li><li>利用众人的数据协助推断。在实际数据上，这种方法效果一般，原因是类似于亚马逊等网站的商品太多了，用户之间很少能找到有很多重复的商品项，所以相似用户的构造会不准确。因而类似的规则便有很多噪声</li></ul><span id="more"></span><h3 id="推荐系统有几类"><a class="markdownIt-Anchor" href="#推荐系统有几类"></a> 推荐系统有几类？</h3><ul><li>协同过滤</li><li>基于内容的推荐系统</li><li>基于知识的推荐系统</li></ul><h3 id="什么是协同过滤"><a class="markdownIt-Anchor" href="#什么是协同过滤"></a> 什么是协同过滤？</h3><ul><li>是首次被用于推荐系统上的技术，至今仍是最简单且最有效的</li><li>协同过滤的过程分为这三步<ul><li>收集用户信息</li><li>生成矩阵来计算用户关联</li><li>作出高可信度的推荐</li></ul></li><li>这种技术分为两大类： 基于用户和基于物品</li></ul><h3 id="什么是基于用户的协同过滤"><a class="markdownIt-Anchor" href="#什么是基于用户的协同过滤"></a> 什么是基于用户的协同过滤？</h3><ul><li>基于用户的协同过滤本质上是寻找与我们的目标用户具有相似品味的用户。 如果 Jean-Pierre 和 Jason 曾对几部电影给出了相似的评分，那么我们认为他们就是相似的用户，接着我们就可以使用 Jean Pierre 的评分来预测 Jason 的未知评分。例如，如果 Jean-Pierre 喜欢星球大战 3: 绝地武士归来和星球大战 5: 帝国反击战，Jason 也喜欢绝地武士归来，那么帝国反击战对 Jason 来说是就是一个很好的推荐。一般来说，你只需要一小部分与 Jason 相似的用户来预测他的评价<img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86-20230704223607.png" alt=""></li><li>可能出现的问题<ul><li>用户偏好会随时间的推移而改变，推荐系统生成的许多推荐可能会随之变得过时</li><li>用户的数量越多，生成推荐的时间就越长</li><li>基于用户会导致对托攻击敏感，这种攻击方法是指恶意人员通过绕过推荐系统，使得特定物品的排名高于其他物品。(托攻击即 Shilling Attack, 是一种针对协同过滤根据近邻偏好产生推荐的特点，恶意注入伪造的用户模型，推高或打压目标排名，从而达到改变推荐系统结果的攻击方式)</li></ul></li></ul><h3 id="什么是基于物品的协同过滤"><a class="markdownIt-Anchor" href="#什么是基于物品的协同过滤"></a> 什么是基于物品的协同过滤？</h3><ul><li>基于物品的协同过滤过程很简单。两个物品的相似性基于用户给出的评分来算出，这里的相似度是根据列而不是行来计算的。 回到 Jean-Pierre 与 Jason 的例子，他们两人都喜欢 “绝地武士归来” 和 “帝国反击战”。 因此可以推断，喜欢第一部电影的大多数用户也可能会喜欢第二部电影。所以，对于喜欢 “绝地武士归来” 的第三个人 Larry 来说，” 帝国反击战 “的推荐将是有意义的<img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86-20230704223608.png" alt=""></li><li>相比较基于用户的协同过滤，有以下优点<ul><li>系统中的物品 (电影) 不会随着时间的推移而改变，所以推荐会越来越具有关联性</li><li>通常推荐系统中的物品都会比用户少，这减少了推荐的处理时间</li><li>考虑到没有用户能够改变系统中的物品，这种系统要更难于被欺骗或攻击</li></ul></li></ul><h3 id="什么是基于内容的推荐系统"><a class="markdownIt-Anchor" href="#什么是基于内容的推荐系统"></a> 什么是基于内容的推荐系统？</h3><ul><li>在基于内容的推荐系统中，元素的描述性属性被用来构成推荐。举个例子，根据 Sophie 的听歌历史，推荐系统注意到她似乎喜欢乡村音乐。因此，系统可以推荐相同或相似类型的歌曲。更复杂的推荐系统能够发现多个属性之间的关系，从而产生更高质量的推荐</li></ul><h3 id="什么是基于知识的推荐系统"><a class="markdownIt-Anchor" href="#什么是基于知识的推荐系统"></a> 什么是基于知识的推荐系统？</h3><ul><li>基于知识的推荐系统不使用评价来作出推荐。相反，推荐过程是基于顾客的需求和商品描述之间的相似度，或是对特定用户的需求使用约束来进行的</li><li>基于知识的推荐系统在物品购买频率很低的情况下特别适用</li></ul><h3 id="什么是推荐系统中的冷启动问题"><a class="markdownIt-Anchor" href="#什么是推荐系统中的冷启动问题"></a> 什么是推荐系统中的冷启动问题？</h3><ul><li>推荐系统中的主要问题之一是最初可用的评价数量相对较小。此时， 协同过滤模型：比较困难基于内容和基于知识的推荐算法：比协同过滤更具有鲁棒性，但基于内容和基于知识并不总是可用的，因此，一些新方法，比如混合系统，已经被设计出用来解决这个问题了</li></ul><h3 id="什么是混合推荐系统"><a class="markdownIt-Anchor" href="#什么是混合推荐系统"></a> 什么是混合推荐系统？</h3><ul><li>一些推荐系统，如基于知识的推荐系统，在数据量有限的冷启动环境下最为有效。其他系统，如协同过滤，在有大量数据可用时则更加有效。可以结合多种不同技术的推荐来提高整个系统的推荐质量。</li><li>加权：为推荐系统中的每种算法都赋予不同的权重，使得推荐偏向某种算法</li><li>交叉：将所有的推荐结果集合在一起展现，没有偏重</li><li>增强：一个系统的推荐将作为下一个系统的输入，循环直至最后一个系统为止</li><li>切换：随机选择一种推荐方法</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是推荐系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是推荐系统&quot;&gt;&lt;/a&gt; 什么是推荐系统？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;推荐系统是信息过滤系统的一个子类，它根据用户的偏好和行为，来向用户呈现他 (或她) 可能感兴趣的物品&lt;/li&gt;
&lt;li&gt;利用众人的数据协助推断。在实际数据上，这种方法效果一般，原因是类似于亚马逊等网站的商品太多了，用户之间很少能找到有很多重复的商品项，所以相似用户的构造会不准确。因而类似的规则便有很多噪声&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="I-推荐系统" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/I-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>RePaint</title>
    <link href="https://www.shaogui.life/posts/562488584.html"/>
    <id>https://www.shaogui.life/posts/562488584.html</id>
    <published>2025-01-12T08:18:00.000Z</published>
    <updated>2025-01-19T06:22:14.020Z</updated>
    
    <content type="html"><![CDATA[<ul><li></li></ul><span id="more"></span><h3 id="什么是-repaint"><a class="markdownIt-Anchor" href="#什么是-repaint"></a> 什么是 RePaint ？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121618751.png" alt=""></li><li>利用 DDPM 模型做图像修复 (Inpainting) 的算法，其原理是利用已知部分预测未知部分，核心操作是基于已知部分加躁，然后在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{t-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 时拆分为估计已知部分和未知部分，通过线性组合这部分完成图像修复</li></ul><h3 id="repaint-的原理"><a class="markdownIt-Anchor" href="#repaint-的原理"></a> RePaint 的原理？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121618752.png" alt=""></li><li>在第 t 步时，上半图的上边 pipeline 表示由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>x</mi><mn>0</mn><mrow><mi>k</mi><mi>n</mi><mi>o</mi><mi>w</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">x_0^{know}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.097216em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span> 加躁得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>k</mi><mi>n</mi><mi>o</mi><mi>w</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">x_{t-1}^{know}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1555469999999999em;vertical-align:-0.30643899999999996em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-2.451892em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30643899999999996em;"><span></span></span></span></span></span></span></span></span></span>，而下边 pipeline 表示由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mu_{\theta}(x_{t})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>u</mi><mi>n</mi><mi>k</mi><mi>n</mi><mi>o</mi><mi>w</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">x_{t-1}^{unknow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1555469999999999em;vertical-align:-0.30643899999999996em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-2.451892em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30643899999999996em;"><span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><mi>q</mi><mo stretchy="false">(</mo><msubsup><mi>x</mi><mi>t</mi><mrow><mi>k</mi><mi>n</mi><mi>o</mi><mi>w</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x_t=q(x_t^{know})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 最后将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>k</mi><mi>n</mi><mi>o</mi><mi>w</mi></mrow></msubsup><mtext>、</mtext><msubsup><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>u</mi><mi>n</mi><mi>k</mi><mi>n</mi><mi>o</mi><mi>w</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">x_{t-1}^{know}、x_{t-1}^{unknow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1555469999999999em;vertical-align:-0.30643899999999996em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-2.451892em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30643899999999996em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-2.451892em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30643899999999996em;"><span></span></span></span></span></span></span></span></span></span> 进行线性组合，得到前一时刻的去躁结果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{t-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，重复以上步骤，就能得到修复后的图片</li><li>发现，如果单纯执行上述步骤，恢复的结果还是不太和谐，因此又提出了 ** 重采样（Resampling）** 的操作。具体而言，对于每一步&nbsp;t ，利用上图算法生成&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{t-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 后，再对其进行加噪得到&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">x_{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&nbsp;，进而再执行一次图 1 算法再次得到&nbsp;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{t-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>&nbsp;，这样的操作称为重采样</li><li>线性组合使用了 m 进行加权，这是 Mask 图</li></ul><h3 id="repaint-的重采样"><a class="markdownIt-Anchor" href="#repaint-的重采样"></a> RePaint 的重采样？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121618753.png" alt=""></li><li>上图是分别使用 1-20 次重采样的结果，可以看出重采样越多，结果越好</li></ul><h3 id="repaint-的类别引导修复"><a class="markdownIt-Anchor" href="#repaint-的类别引导修复"></a> RePaint 的类别引导修复？</h3><ul><li><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/202501121618754.png" alt=""></li><li>修复过程中，加入类别引导，生成了类似图片</li></ul><p>参考：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/650347229">基于 DDPM 的简单的 Inpainting——RePaint 和 RePaint+ - 知乎</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="B-视觉模型" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/B-%E8%A7%86%E8%A7%89%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="2-高级视觉任务GAN" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/B-%E8%A7%86%E8%A7%89%E6%A8%A1%E5%9E%8B/2-%E9%AB%98%E7%BA%A7%E8%A7%86%E8%A7%89%E4%BB%BB%E5%8A%A1GAN/"/>
    
    <category term="图像修复" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/B-%E8%A7%86%E8%A7%89%E6%A8%A1%E5%9E%8B/2-%E9%AB%98%E7%BA%A7%E8%A7%86%E8%A7%89%E4%BB%BB%E5%8A%A1GAN/%E5%9B%BE%E5%83%8F%E4%BF%AE%E5%A4%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 llm 提升信息密度</title>
    <link href="https://www.shaogui.life/posts/2491556860.html"/>
    <id>https://www.shaogui.life/posts/2491556860.html</id>
    <published>2024-12-17T13:54:30.000Z</published>
    <updated>2025-01-18T10:54:21.371Z</updated>
    
    <content type="html"><![CDATA[<p>在处理原始数据时，无关信息或不相关的内容，可能会给检索过程带来干扰，通过 LLM 可以从原始数据中提取有用的信息，总结过于冗长的文本，或隔离关键事实，从而提高信息密度。甚至可以将原始数据转为更密集、更清晰的知识图谱</p><span id="more"></span><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/%E4%BD%BF%E7%94%A8llm%E6%8F%90%E5%8D%87%E4%BF%A1%E6%81%AF%E5%AF%86%E5%BA%A6-20241216113438.png" alt="使用llm提升信息密度-20241216113438"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在处理原始数据时，无关信息或不相关的内容，可能会给检索过程带来干扰，通过 LLM 可以从原始数据中提取有用的信息，总结过于冗长的文本，或隔离关键事实，从而提高信息密度。甚至可以将原始数据转为更密集、更清晰的知识图谱&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="RAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/"/>
    
    <category term="NextRAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/NextRAG/"/>
    
    
  </entry>
  
  <entry>
    <title>MetaGPT-Tools</title>
    <link href="https://www.shaogui.life/posts/1537122907.html"/>
    <id>https://www.shaogui.life/posts/1537122907.html</id>
    <published>2024-12-17T08:47:23.000Z</published>
    <updated>2025-01-18T10:53:09.996Z</updated>
    
    <content type="html"><![CDATA[<p>MetaGPT 通过 3 个步骤创建工具：</p><ol><li><strong>创建预提供的函数或类</strong>：编写专门用于与外部环境进行特定交互的函数或类，并将它们放置在 metagpt/tools/libs 目录中</li><li><strong>使用谷歌风格的文档字符串（Docstring）</strong>：为每个函数或类配备谷歌风格的文档字符串。这作为一个简洁而全面的参考资料，详细说明其用途、输入参数和预期输出</li><li><strong>应用 @register_tool 装饰器</strong>：使用 @register_tool 装饰器以确保在工具注册表中准确注册。这个装饰器简化了函数或类与 DataInterpreter</li></ol><span id="more"></span><h2 id="创建预提供的函数"><a class="markdownIt-Anchor" href="#创建预提供的函数"></a> 创建预提供的函数</h2><p>在 MetaGPT 的安装路径的 <code>metagpt\\tools\</code> 目录下新建函数，并使用 <code>@register_tool()</code> 注册工具</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># metagpt/tools/libs/calculate_factorial.py</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> metagpt.tools.tool_registry <span class="keyword">import</span> register_tool</span><br><span class="line"><span class="comment"># 使用装饰器注册工具</span></span><br><span class="line"><span class="meta">@register_tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_factorial</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算非负整数的阶乘</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"输入必须是非负整数"</span>)</span><br><span class="line">    <span class="keyword">return</span> math.factorial(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> nest_asyncio</span><br><span class="line">nest_asyncio.apply()</span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> metagpt.roles.di.data_interpreter <span class="keyword">import</span> DataInterpreter</span><br><span class="line"><span class="keyword">from</span> metagpt.tools.libs <span class="keyword">import</span> calculate_factorial</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">requirement: <span class="built_in">str</span></span>):</span><br><span class="line">    role = DataInterpreter(tools=[<span class="string">"calculate_factorial"</span>]) <span class="comment"># 集成工具</span></span><br><span class="line">    <span class="keyword">await</span> role.run(requirement)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    requirement = <span class="string">"请计算 5 的阶乘"</span></span><br><span class="line">    asyncio.run(main(requirement))</span><br></pre></td></tr></tbody></table></figure><p>metaGPT 会自己生成以下代码</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/MetaGPT-Tools-20250115191104.png" alt="MetaGPT-Tools-20250115191104"></p><h2 id="创建预提供的类"><a class="markdownIt-Anchor" href="#创建预提供的类"></a> 创建预提供的类</h2><p>同样的方式，将装饰器注册参数改为以下：<code>@register_tool(tags=["math"], include_functions=["__init__", "add", "subtract", "multiply", "divide", "factorial"])</code></p><h2 id="tools-与-action-的关系"><a class="markdownIt-Anchor" href="#tools-与-action-的关系"></a> Tools 与 Action 的关系</h2><p>在自定义 Tools 后，会使用 <code>DataInterpreter</code> 封装工具以初始化 Role，就内部函数来说，两者地位等同，只是：</p><ul><li>Action：通过 run 函数执行</li><li> Tool：通过运行代码执行</li></ul><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/MetaGPT-Tools-20250111104023.png" alt="MetaGPT-Tools-20250111104023"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MetaGPT 通过 3 个步骤创建工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;创建预提供的函数或类&lt;/strong&gt;：编写专门用于与外部环境进行特定交互的函数或类，并将它们放置在 metagpt/tools/libs 目录中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用谷歌风格的文档字符串（Docstring）&lt;/strong&gt;：为每个函数或类配备谷歌风格的文档字符串。这作为一个简洁而全面的参考资料，详细说明其用途、输入参数和预期输出&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用 @register_tool 装饰器&lt;/strong&gt;：使用 @register_tool 装饰器以确保在工具注册表中准确注册。这个装饰器简化了函数或类与 DataInterpreter&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="MetaGPT" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/MetaGPT/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 llm 删除冗余信息</title>
    <link href="https://www.shaogui.life/posts/3504928170.html"/>
    <id>https://www.shaogui.life/posts/3504928170.html</id>
    <published>2024-12-15T03:51:30.000Z</published>
    <updated>2025-01-18T10:54:21.370Z</updated>
    
    <content type="html"><![CDATA[<p>如果多个文档存在类似内容时，在返回 top 可相近文档时，会存在冗余内容，并且导致检索到其他相关文档能力下降，因此需要对冗余数据进行删除</p><span id="more"></span><p>考虑一个公司文档存储库的示例，其中包含与客户相关的多个策略文档。相同的信息可能以以下方式显示：</p><p>文档 1：“员工必须确保所有客户数据都得到安全存储。未经同意，不得共享客户数据。<br>文档 2：“所有客户数据都必须加密。分享前需要征得同意。<br>文档 3：“确保客户数据得到安全存储。未经正确利益相关者同意，请勿共享客户数据。</p><p>已删除重复数据的文本将为：</p><p>合并文本：“客户数据必须安全地加密和存储，未经明确同意，禁止共享客户数据。</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/%E4%BD%BF%E7%94%A8llm%E5%88%A0%E9%99%A4%E5%86%97%E4%BD%99%E4%BF%A1%E6%81%AF-20241216113932.png" alt="使用llm删除冗余信息-20241216113932"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果多个文档存在类似内容时，在返回 top 可相近文档时，会存在冗余内容，并且导致检索到其他相关文档能力下降，因此需要对冗余数据进行删除&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="RAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/"/>
    
    <category term="NextRAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/NextRAG/"/>
    
    
  </entry>
  
  <entry>
    <title>利用 llamaIndex 搭建文档问答助手</title>
    <link href="https://www.shaogui.life/posts/834744281.html"/>
    <id>https://www.shaogui.life/posts/834744281.html</id>
    <published>2024-12-15T02:26:50.000Z</published>
    <updated>2025-01-18T10:54:01.966Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://tianchi.aliyun.com/competition/entrance/532154/information">2023 全球智能汽车 AI 挑战赛 —— 赛道一：AI 大模型检索问答</a>中，提供一份汽车使用手册文件，要求针对文件创建智能问答助手</p><span id="more"></span><p>本文通过使用 llamaIndex 完成这个 RAG 过程，和普通 RAG 不同的是：生成的答案包含图片及引用</p><p>搭建这个问答系统一共分为 3 步</p><ul><li>预处理文档：基于标题层级对 pdf 进行分块处理，便于后续图片及引文的使用</li><li>构建索引：通过 llamaIndex 构建索引，本次使用 bm25 及向量检索的方式</li><li>构建检索生成引擎：通过 llamaIndex 构建查询引擎</li></ul><h2 id="预处理文档"><a class="markdownIt-Anchor" href="#预处理文档"></a> 预处理文档</h2><p>通过 pymupdf 库按标题切分 pdf 文档，最终生成类似文档</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/%E5%88%A9%E7%94%A8llamaIndex%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3%E9%97%AE%E7%AD%94%E5%8A%A9%E6%89%8B-20250116101837.png" alt="利用llamaIndex搭建文档问答助手-20250116101837"></p><h2 id="构建索引"><a class="markdownIt-Anchor" href="#构建索引"></a> 构建索引</h2><p>通过尝试不同的索引，确定使用 BM 25 Retriever+VectorStoreIndex 的混合索引的方式，以下是不同索引的评估效果</p><table><thead><tr><th>检索器</th><th> topK</th><th>hit_rate</th><th>mrr</th><th>precision</th><th>recall</th><th>ap</th><th>ndcg</th><th> 备注</th></tr></thead><tbody><tr><td> VectorStoreIndex</td><td>2</td><td>0.779751</td><td>0.708703</td><td>0.400829</td><td>0.779751</td><td>0.708703</td><td>0.727308</td><td></td></tr><tr><td>VectorStoreIndex</td><td>5</td><td>0.885731</td><td>0.73954</td><td>0.184162</td><td>0.885731</td><td>0.73954</td><td>0.776535</td><td></td></tr><tr><td>SummaryIndex</td><td>5</td><td>0.971581</td><td>0.012225</td><td>0.001776</td><td>0.971581</td><td>0.012225</td><td>0.134562</td><td></td></tr><tr><td>BM25Retriever</td><td>2</td><td>0.092954</td><td>0.086738</td><td>0.048253</td><td>0.092954</td><td>0.086738</td><td>0.088366</td><td> 官方</td></tr><tr><td> BM25Retriever</td><td>2</td><td>0.871522</td><td>0.806986</td><td>0.448194</td><td>0.871522</td><td>0.806986</td><td>0.823886</td><td> 自定义</td></tr><tr><td> BM25Retriever+VectorStoreIndex</td><td>2,2,2</td><td>0.872114</td><td>0.809355</td><td>0.44701</td><td>0.872114</td><td>0.809355</td><td>0.825789</td><td> 自定义 + QueryFusionRetriever</td></tr><tr><td>BM25Retriever+VectorStoreIndex</td><td>3,5,3</td><td>0.910006</td><td>0.799092</td><td>0.303335</td><td>0.910006</td><td>0.799092</td><td>0.82779</td><td>num_queries=2</td></tr></tbody></table><h2 id="构建检索生成引擎"><a class="markdownIt-Anchor" href="#构建检索生成引擎"></a> 构建检索生成引擎</h2><p>通过结构化 llm 的输出，输出引文，然后提取引文的图片，生成最终答案，效果如下</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/%E5%88%A9%E7%94%A8llamaIndex%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3%E9%97%AE%E7%AD%94%E5%8A%A9%E6%89%8B-20250116101837-1.png" alt="利用llamaIndex搭建文档问答助手-20250116101837-1"></p><p>项目地址：<a href="https://github.com/WuShaogui/DocumentsIntelligentAssistant/tree/main">GitHub - WuShaogui/DocumentsIntelligentAssistant: 对文档使用 RAG 生成回答</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 &lt;a href=&quot;https://tianchi.aliyun.com/competition/entrance/532154/information&quot;&gt;2023 全球智能汽车 AI 挑战赛 —— 赛道一：AI 大模型检索问答&lt;/a&gt;中，提供一份汽车使用手册文件，要求针对文件创建智能问答助手&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="RAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/"/>
    
    
  </entry>
  
  <entry>
    <title>MetaGPT-Memory</title>
    <link href="https://www.shaogui.life/posts/2936212541.html"/>
    <id>https://www.shaogui.life/posts/2936212541.html</id>
    <published>2024-12-14T14:57:16.000Z</published>
    <updated>2025-01-18T10:53:09.995Z</updated>
    
    <content type="html"><![CDATA[<p>在 Meta 中，每个 Role 拥有自己的记忆，存储在 <code>self.rc.memory</code>, 其中的 <code>memory</code> 是 role 实例化 <code>Memory</code> 类得到的，关系如下图所示</p><span id="more"></span><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/MetaGPT-Memory-20250111110751.png" alt="MetaGPT-Memory-20250111110751"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nest_asyncio</span><br><span class="line">nest_asyncio.apply()</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> metagpt.actions <span class="keyword">import</span> Action</span><br><span class="line"><span class="keyword">from</span> metagpt.logs <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleWriteCode</span>(<span class="title class_ inherited__">Action</span>):</span><br><span class="line">    PROMPT_TEMPLATE: <span class="built_in">str</span> = <span class="string">"""</span></span><br><span class="line"><span class="string">    Write a python function that can {instruction} and provide two runnnable test cases.</span></span><br><span class="line"><span class="string">    Return ```python your_code_here ``` with NO other texts,</span></span><br><span class="line"><span class="string">    your code:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    name:<span class="built_in">str</span> =<span class="string">'SimpleWriteCode'</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,instruction: <span class="built_in">str</span></span>):</span><br><span class="line">        prompt=<span class="variable language_">self</span>.PROMPT_TEMPLATE.<span class="built_in">format</span>(instruction=instruction)</span><br><span class="line">        rsp=<span class="keyword">await</span> <span class="variable language_">self</span>._aask(prompt)</span><br><span class="line">        code_text=SimpleWriteCode.parse_code(rsp)</span><br><span class="line">        <span class="keyword">return</span> code_text</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_code</span>(<span class="params">rsp</span>):</span><br><span class="line">        pattern = <span class="string">r"```python(.*)```"</span></span><br><span class="line">        <span class="keyword">match</span>=re.search(pattern,rsp,re.DOTALL)</span><br><span class="line">        code_text=<span class="keyword">match</span>.group(<span class="number">1</span>) <span class="keyword">if</span> <span class="keyword">match</span> <span class="keyword">else</span> rsp</span><br><span class="line">        <span class="keyword">return</span> code_text</span><br></pre></td></tr></tbody></table></figure><blockquote><p>2024-12-13 13:42:14.821 | INFO     | metagpt.const:get_metagpt_package_root:29 - Package root set to c:\CodeRepos\python\MyCode\Learnning_MetaGPT</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> metagpt.roles <span class="keyword">import</span> Role</span><br><span class="line"><span class="keyword">from</span> metagpt.schema <span class="keyword">import</span> Message</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCoder</span>(<span class="title class_ inherited__">Role</span>):</span><br><span class="line">    name: <span class="built_in">str</span> = <span class="string">"Alice"</span></span><br><span class="line">    profile: <span class="built_in">str</span> = <span class="string">"SimpleCoder"</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line">        <span class="variable language_">self</span>.set_actions([SimpleWriteCode])</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_act</span>(<span class="params">self</span>) -&gt; Message:</span><br><span class="line">        logger.info(<span class="string">f"<span class="subst">{self._setting}</span>: to do <span class="subst">{self.rc.todo}</span>(<span class="subst">{self.rc.todo.name}</span>)"</span>)</span><br><span class="line">        todo = <span class="variable language_">self</span>.rc.todo               <span class="comment"># 从RoleContext取下一个Action</span></span><br><span class="line">        msg = <span class="variable language_">self</span>.rc.memory.get(k=<span class="number">1</span>)[<span class="number">0</span>]  <span class="comment"># 从RoleContext取最近的K个Message</span></span><br><span class="line">        code_text = <span class="keyword">await</span> todo.run(msg.content)</span><br><span class="line">        msg = Message(content=code_text, role=<span class="variable language_">self</span>.profile, cause_by=<span class="built_in">type</span>(todo))</span><br><span class="line">        <span class="variable language_">self</span>.rc.memory.add(message=msg)   <span class="comment"># 保存本次Message</span></span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> metagpt.context <span class="keyword">import</span> Context</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    msg = <span class="string">"编写一个函数，计算数组的和"</span></span><br><span class="line">    context = Context()</span><br><span class="line">    role = SimpleCoder(context=context)</span><br><span class="line">    logger.info(<span class="string">f'1-todo:<span class="subst">{role.rc.todo}</span>\nmemory:<span class="subst">{role.rc.memory}</span>'</span>)</span><br><span class="line">    result = <span class="keyword">await</span> role.run(msg)</span><br><span class="line">    logger.info(<span class="string">f'2-todo:<span class="subst">{role.rc.todo}</span>\nmemory:<span class="subst">{role.rc.memory}</span>'</span>)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></tbody></table></figure><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">2024-12-13 13:42:21.304 | INFO     | <span class="strong">__main__</span>:main:9 - 1-todo:None</span><br><span class="line">memory:storage=[] index=defaultdict(<span class="language-xml"><span class="tag">&lt;<span class="name">class</span> '<span class="attr">list</span>'&gt;</span></span>, {}) ignore<span class="emphasis">_id=False</span></span><br><span class="line"><span class="emphasis">2024-12-13 13:42:21.307 | INFO     | <span class="strong">__main__</span>:_</span>act:13 - Alice(SimpleCoder): to do SimpleWriteCode(SimpleWriteCode)</span><br><span class="line"><span class="code">```python</span></span><br><span class="line"><span class="code">def calculate_array_sum(arr):</span></span><br><span class="line"><span class="code">    return sum(arr)</span></span><br><span class="line"><span class="code"># Test case 1: Positive integers</span></span><br><span class="line"><span class="code">assert calculate_array_sum([1, 2, 3, 4]) == 10</span></span><br><span class="line"><span class="code"># Test case 2: Including negative numbers and zero</span></span><br><span class="line"><span class="code">assert calculate_array_sum([-5, 1,</span></span><br><span class="line"><span class="code">2024-12-13 13:42:26.482 | WARNING  | metagpt.utils.cost_manager:update_cost:49 - Model qwen2.5:14b not found in TOKEN_COSTS.</span></span><br><span class="line"><span class="code">2024-12-13 13:42:26.483 | INFO     | __main__:main:13 - 2-todo:None</span></span><br><span class="line"><span class="code">memory:storage=[user: 编写一个函数，计算数组的和, SimpleCoder: </span></span><br><span class="line"><span class="code">def calculate_array_sum(arr):</span></span><br><span class="line"><span class="code">    return sum(arr)</span></span><br><span class="line"><span class="code"># Test case 1: Positive integers</span></span><br><span class="line"><span class="code">assert calculate_array_sum([1, 2, 3, 4]) == 10</span></span><br><span class="line"><span class="code"># Test case 2: Including negative numbers and zero</span></span><br><span class="line"><span class="code">assert calculate_array_sum([-5, 1, -1, 6]) == 1</span></span><br><span class="line"><span class="code">] index=defaultdict(&lt;class 'list'&gt;, {'metagpt.actions.add_requirement.UserRequirement': [user: 编写一个函数，计算数组的和], '__main__.SimpleWriteCode': [SimpleCoder: </span></span><br><span class="line"><span class="code">def calculate_array_sum(arr):</span></span><br><span class="line"><span class="code">    return sum(arr)</span></span><br><span class="line"><span class="code"># Test case 1: Positive integers</span></span><br><span class="line"><span class="code">assert calculate_array_sum([1, 2, 3, 4]) == 10</span></span><br><span class="line"><span class="code"># Test case 2: Including negative numbers and zero</span></span><br><span class="line"><span class="code">assert calculate_array_sum([-5, 1, -1, 6]) == 1</span></span><br><span class="line"><span class="code">]}) ignore_id=False</span></span><br><span class="line"><span class="code"> -1, 6]) == 1</span></span><br><span class="line"><span class="code">\```</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Meta 中，每个 Role 拥有自己的记忆，存储在 &lt;code&gt;self.rc.memory&lt;/code&gt;, 其中的 &lt;code&gt;memory&lt;/code&gt; 是 role 实例化 &lt;code&gt;Memory&lt;/code&gt; 类得到的，关系如下图所示&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="MetaGPT" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/MetaGPT/"/>
    
    
  </entry>
  
  <entry>
    <title>SemanticKernel-GetStart</title>
    <link href="https://www.shaogui.life/posts/2547889567.html"/>
    <id>https://www.shaogui.life/posts/2547889567.html</id>
    <published>2024-12-13T13:45:31.000Z</published>
    <updated>2025-01-18T10:53:18.294Z</updated>
    
    <content type="html"><![CDATA[<p>一个类似 langchian 的框架，但是比 langchian 框架抽象程度更高，这就意味着：开发更容易上手，但是定制能力下降，核心区别是 SemanticKernel 可以使用 C#、Java 开发</p><span id="more"></span><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> nest_asyncio</span><br><span class="line">nest_asyncio.apply()</span><br><span class="line"><span class="keyword">from</span> semantic_kernel <span class="keyword">import</span> Kernel</span><br><span class="line"><span class="keyword">from</span> semantic_kernel.utils.logging <span class="keyword">import</span> setup_logging</span><br><span class="line"><span class="keyword">from</span> semantic_kernel.functions <span class="keyword">import</span> kernel_function</span><br><span class="line"><span class="keyword">from</span> semantic_kernel.connectors.ai.ollama <span class="keyword">import</span> OllamaChatCompletion</span><br><span class="line"><span class="keyword">from</span> semantic_kernel.connectors.ai.function_choice_behavior <span class="keyword">import</span> FunctionChoiceBehavior</span><br><span class="line"><span class="keyword">from</span> semantic_kernel.connectors.ai.chat_completion_client_base <span class="keyword">import</span> ChatCompletionClientBase</span><br><span class="line"><span class="keyword">from</span> semantic_kernel.contents.chat_history <span class="keyword">import</span> ChatHistory</span><br><span class="line"><span class="keyword">from</span> semantic_kernel.functions.kernel_arguments <span class="keyword">import</span> KernelArguments</span><br><span class="line"><span class="keyword">from</span> semantic_kernel.connectors.ai.ollama.ollama_prompt_execution_settings <span class="keyword">import</span> OllamaChatPromptExecutionSettings</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Annotated</span><br><span class="line"><span class="keyword">from</span> semantic_kernel.functions <span class="keyword">import</span> kernel_function</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightsPlugin</span>:</span><br><span class="line">    lights = [</span><br><span class="line">        {<span class="string">"id"</span>: <span class="number">1</span>, <span class="string">"name"</span>: <span class="string">"台灯"</span>, <span class="string">"is_on"</span>: <span class="literal">False</span>},</span><br><span class="line">        {<span class="string">"id"</span>: <span class="number">2</span>, <span class="string">"name"</span>: <span class="string">"玄关灯"</span>, <span class="string">"is_on"</span>: <span class="literal">False</span>},</span><br><span class="line">        {<span class="string">"id"</span>: <span class="number">3</span>, <span class="string">"name"</span>: <span class="string">"吊灯"</span>, <span class="string">"is_on"</span>: <span class="literal">True</span>},</span><br><span class="line">    ]</span><br><span class="line"><span class="meta">    @kernel_function(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">        name=<span class="string">"get_lights"</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">        description=<span class="string">"Gets a list of lights and their current state"</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    </span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_state</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">    </span>) -&gt; Annotated[<span class="built_in">str</span>, <span class="string">"the output is a string"</span>]:</span><br><span class="line">        <span class="string">"""Gets a list of lights and their current state."""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.lights</span><br><span class="line"><span class="meta">    @kernel_function(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">        name=<span class="string">"change_state"</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">        description=<span class="string">"Changes the state of the light"</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    </span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change_state</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        <span class="built_in">id</span>: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">        is_on: <span class="built_in">bool</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; Annotated[<span class="built_in">str</span>, <span class="string">"the output is a string"</span>]:</span><br><span class="line">        <span class="string">"""Changes the state of the light."""</span></span><br><span class="line">        <span class="keyword">for</span> light <span class="keyword">in</span> <span class="variable language_">self</span>.lights:</span><br><span class="line">            <span class="keyword">if</span> light[<span class="string">"id"</span>] == <span class="built_in">id</span>:</span><br><span class="line">                light[<span class="string">"is_on"</span>] = is_on</span><br><span class="line">                <span class="keyword">return</span> light</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Initialize the kernel</span></span><br><span class="line">    kernel = Kernel()</span><br><span class="line">    <span class="comment"># Add Azure OpenAI chat completion</span></span><br><span class="line">    chat_completion = OllamaChatCompletion(</span><br><span class="line">        ai_model_id =<span class="string">"qwen2.5:latest"</span>,</span><br><span class="line">        host =<span class="string">"http://192.168.3.155:11434"</span>,</span><br><span class="line">    )</span><br><span class="line">    kernel.add_service(chat_completion)</span><br><span class="line">    <span class="comment"># Set the logging level for  semantic_kernel.kernel to DEBUG.</span></span><br><span class="line">    setup_logging()</span><br><span class="line">    logging.getLogger(<span class="string">"kernel"</span>).setLevel(logging.DEBUG)</span><br><span class="line">    <span class="comment"># Add a plugin (the LightsPlugin class is defined below)</span></span><br><span class="line">    kernel.add_plugin(</span><br><span class="line">        LightsPlugin(),</span><br><span class="line">        plugin_name=<span class="string">"Lights"</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># Enable planning</span></span><br><span class="line">    execution_settings = OllamaChatPromptExecutionSettings()</span><br><span class="line">    execution_settings.function_choice_behavior=FunctionChoiceBehavior.Auto()</span><br><span class="line">    <span class="comment"># Create a history of the conversation</span></span><br><span class="line">    history = ChatHistory()</span><br><span class="line">    <span class="comment"># Initiate a back-and-forth chat</span></span><br><span class="line">    userInput = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Collect user input</span></span><br><span class="line">        userInput = <span class="built_in">input</span>(<span class="string">"User &gt; "</span>)</span><br><span class="line">        <span class="comment"># Terminate the loop if the user says "exit"</span></span><br><span class="line">        <span class="keyword">if</span> userInput == <span class="string">"exit"</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Add user input to the history</span></span><br><span class="line">        history.add_user_message(userInput)</span><br><span class="line">        <span class="comment"># Get the response from the AI</span></span><br><span class="line">        result = <span class="keyword">await</span> chat_completion.get_chat_message_content(</span><br><span class="line">            chat_history=history,</span><br><span class="line">            settings=execution_settings,</span><br><span class="line">            kernel=kernel,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># Print the results</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Assistant &gt; "</span> + <span class="built_in">str</span>(result))</span><br><span class="line">        <span class="comment"># Add the message from the agent to the chat history</span></span><br><span class="line">        history.add_message(result)</span><br><span class="line"><span class="comment"># Run the main function</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></tbody></table></figure><pre><code>User &gt;  我是小五，住在广州Assistant &gt; 很高兴认识你，小五！我叫Qwen，是一名来自阿里云的智能助手。如果你在广州有任何需要帮助的地方，都可以告诉我哦！比如你需要找附近的餐厅、景点推荐或者是天气查询等等。有什么我可以帮到你的吗？User &gt;  家里的灯都开着吗？Assistant &gt; 目前你家的灯光状态如下：- 台灯是关闭的- 玄关灯是关闭的- 吊灯是开启的需要我帮你调整灯光的状态吗？比如关闭开着的灯或者打开关闭的灯。User &gt;  打开台灯，关闭吊灯Assistant &gt; 好的，已经调整好了灯光状态：- 台灯现在是开着的。- 吊灯现在是关着的。还有其他需要帮忙的地方吗？比如再调整其他灯或者是查询其他信息。User &gt;  灯光状态Assistant &gt; 当前家里的灯光状态如下：- 台灯：开启- 玄关灯：关闭- 吊灯：关闭如果你还需要进一步的操作或者其他帮助，请告诉我！User &gt;  我是谁？Assistant &gt; 你是小五，你住在广州。有什么其他问题或者需要帮助的吗？比如天气查询、生活建议等，都可以告诉我哦！User &gt;  exit</code></pre><p>很有意思的对话，类似 langchain 绑定的函数，作为工具，Semantic 绑定的是类，不仅有一批函数，还有持久变量，感觉 Semantic 更能落地具体场景，因为在对话过程中维护了场景的状态，类似 Dify 在构建 RAG 流程时，也提供全局变量的定义</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/e85c1e0d-af9e-4178-9e12-e04f9909ef50.png" alt="e85c1e0d-af9e-4178-9e12-e04f9909ef50"></p><p>在官方文档中，SemanticKernel 的设计核心思想是：内核，内核拥有运行本机代码和 AI 服务所需的所有服务和插件，这和 langchian 的多组件不同，langchian 将多个组件写在不同模块上，而 SemanticKernel 将组件及组件使用，抽象成一个类，即 Kernel ()</p><p>看代码，Semantic 构建过程有以下步骤</p><ol><li>添加模型推理服务 </li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Initialize the kernel</span></span><br><span class="line">kernel = Kernel()</span><br><span class="line"><span class="comment"># Add Azure OpenAI chat completion</span></span><br><span class="line">chat_completion = OllamaChatCompletion(</span><br><span class="line">    ai_model_id =<span class="string">"qwen2.5:latest"</span>,</span><br><span class="line">    host =<span class="string">"http://192.168.3.155:11434"</span>,</span><br><span class="line">)</span><br><span class="line">kernel.add_service(chat_completion)</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>设置企业组件<br>Semantic Kernel 的主要好处之一是支持企业级服务。在此示例中，我们将日志记录服务添加到内核中，以帮助调试 AI 代理 </li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the logging level for  semantic_kernel.kernel to DEBUG.</span></span><br><span class="line">setup_logging()</span><br><span class="line">logging.getLogger(<span class="string">"kernel"</span>).setLevel(logging.DEBUG)</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>设置插件<br>这里绑定的插件是类的实例 </li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add a plugin (the LightsPlugin class is defined below)</span></span><br><span class="line">kernel.add_plugin(</span><br><span class="line">    LightsPlugin(),</span><br><span class="line">    plugin_name=<span class="string">"Lights"</span>,</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>设置规划<br>包括设置提示 </li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable planning</span></span><br><span class="line">execution_settings = OllamaChatPromptExecutionSettings()</span><br><span class="line">execution_settings.function_choice_behavior=FunctionChoiceBehavior.Auto()</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>调用<br>非流式调用 </li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the response from the AI</span></span><br><span class="line">result = <span class="keyword">await</span> chat_completion.get_chat_message_content(</span><br><span class="line">    chat_history=history,</span><br><span class="line">    settings=execution_settings,</span><br><span class="line">    kernel=kernel,</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>Semantic Kernel 的关键是 kernel 类，其中包含不同的组件：</p><ul><li>AI Service Connectors：Semantic 提供了一个抽象层，以统一的接口提供不同类型的 AI 服务，如 openai、ollama 等，支持的服务包括聊天、文本生成、文本 &lt;-&gt; 图片，文本 &lt;-&gt; 音频</li><li> Vector Store (Memory) Connectors：同样是抽象层，统一的接口接入不同的向量数据库</li><li> Functions and Plugins：插件被命名为函数容器。每个 API 可以包含一个或多个函数</li><li> Prompt Templates：允许开发人员或提示工程师创建一个模板，该模板将 AI 的上下文和指令与用户输入和函数输出混合在一起。</li><li>Filters：提供了一种在聊天完成流程中特定事件之前和之后执行自定义操作的方法</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个类似 langchian 的框架，但是比 langchian 框架抽象程度更高，这就意味着：开发更容易上手，但是定制能力下降，核心区别是 SemanticKernel 可以使用 C#、Java 开发&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="SemanticKernel" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/SemanticKernel/"/>
    
    
  </entry>
  
  <entry>
    <title>MetaGPT-Flow</title>
    <link href="https://www.shaogui.life/posts/1029037900.html"/>
    <id>https://www.shaogui.life/posts/1029037900.html</id>
    <published>2024-12-10T06:53:12.000Z</published>
    <updated>2025-01-18T10:53:09.995Z</updated>
    
    <content type="html"><![CDATA[<p>单个智能体可以执行一个或多个动作，那是不是一直使用一个智能体即可呢？存在以下两个问题：</p><ul><li><strong>Prompt 依赖</strong>：动作越多，要求 Prompt 越精细，才能准确控制其动作，尤其是有相似动作时</li><li><strong>动作选择上限</strong>：Openai 建议一个 agent 绑定不超过 20 个动作，动作太多，agent 选择工具能力下降  <a href="https://platform.openai.com/docs/guides/function-calling#best-practices-for-defining-functions">Function calling - OpenAI API</a></li><li><strong>SOP (标准作业流程) 问题</strong>：在现实工作中，常常存在一个标准流程，如果每次节点都依赖 llm 去选择后续的逻辑分支，软件变得不可控</li></ul><span id="more"></span><p>基于以上问题，提出<strong>多 agent</strong>，不同的 agent 有自己的 prompt、动作，多个 agent，降低了多 prompt 的依赖，并且按照不同工作的 SOP 限定 agent 的先后顺序</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nest_asyncio</span><br><span class="line">nest_asyncio.apply()</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> metagpt.actions <span class="keyword">import</span> Action</span><br><span class="line"><span class="keyword">from</span> metagpt.logs <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置模型花费，避免出现警告</span></span><br><span class="line"><span class="keyword">from</span> metagpt.utils.cost_manager <span class="keyword">import</span> TOKEN_COSTS</span><br><span class="line">TOKEN_COSTS.update({<span class="string">'qwen2.5:latest'</span>:{<span class="string">'prompt'</span>: <span class="number">0.0015</span>, <span class="string">'completion'</span>: <span class="number">0.002</span>}})</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_code</span>(<span class="params">rsp</span>):</span><br><span class="line">        pattern = <span class="string">r"```python(.*)```"</span></span><br><span class="line">        <span class="keyword">match</span>=re.search(pattern,rsp,re.DOTALL)</span><br><span class="line">        code_text=<span class="keyword">match</span>.group(<span class="number">1</span>) <span class="keyword">if</span> <span class="keyword">match</span> <span class="keyword">else</span> rsp</span><br><span class="line">        <span class="keyword">return</span> code_text</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleWriteCode</span>(<span class="title class_ inherited__">Action</span>):</span><br><span class="line">    PROMPT_TEMPLATE: <span class="built_in">str</span> = <span class="string">"""</span></span><br><span class="line"><span class="string">    Write a python function that can {instruction}.</span></span><br><span class="line"><span class="string">    Return ```python your_code_here ``` with NO other texts,</span></span><br><span class="line"><span class="string">    your code:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    name: <span class="built_in">str</span> = <span class="string">"SimpleWriteCode"</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, instruction: <span class="built_in">str</span></span>):</span><br><span class="line">        prompt = <span class="variable language_">self</span>.PROMPT_TEMPLATE.<span class="built_in">format</span>(instruction=instruction)</span><br><span class="line">        rsp = <span class="keyword">await</span> <span class="variable language_">self</span>._aask(prompt)</span><br><span class="line">        code_text = parse_code(rsp)</span><br><span class="line">        <span class="keyword">return</span> code_text</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleWriteTest</span>(<span class="title class_ inherited__">Action</span>):</span><br><span class="line">    PROMPT_TEMPLATE: <span class="built_in">str</span> = <span class="string">"""</span></span><br><span class="line"><span class="string">    Context: {context}</span></span><br><span class="line"><span class="string">    Write {k} unit tests using pytest for the given function, assuming you have imported it.</span></span><br><span class="line"><span class="string">    Return ```python your_code_here ``` with NO other texts,</span></span><br><span class="line"><span class="string">    your code:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    name: <span class="built_in">str</span> = <span class="string">"SimpleWriteTest"</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, context: <span class="built_in">str</span>, k: <span class="built_in">int</span> = <span class="number">3</span></span>):</span><br><span class="line">        prompt = <span class="variable language_">self</span>.PROMPT_TEMPLATE.<span class="built_in">format</span>(context=context, k=k)</span><br><span class="line">        rsp = <span class="keyword">await</span> <span class="variable language_">self</span>._aask(prompt)</span><br><span class="line">        code_text = parse_code(rsp)</span><br><span class="line">        <span class="keyword">return</span> code_text</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleWriteReview</span>(<span class="title class_ inherited__">Action</span>):</span><br><span class="line">    PROMPT_TEMPLATE: <span class="built_in">str</span> = <span class="string">"""</span></span><br><span class="line"><span class="string">    Context: {context}</span></span><br><span class="line"><span class="string">    Review the test cases and provide one critical comments:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    name: <span class="built_in">str</span> = <span class="string">"SimpleWriteReview"</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, context: <span class="built_in">str</span></span>):</span><br><span class="line">        prompt = <span class="variable language_">self</span>.PROMPT_TEMPLATE.<span class="built_in">format</span>(context=context)</span><br><span class="line">        rsp = <span class="keyword">await</span> <span class="variable language_">self</span>._aask(prompt)</span><br><span class="line">        <span class="keyword">return</span> rsp</span><br></pre></td></tr></tbody></table></figure><blockquote><p>2024-12-13 10:50:43.508 | INFO     | metagpt.const:get_metagpt_package_root:29 - Package root set to c:\CodeRepos\python\MyCode\Learnning_MetaGPT</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> metagpt.roles <span class="keyword">import</span> Role</span><br><span class="line"><span class="keyword">from</span> metagpt.schema <span class="keyword">import</span> Message</span><br><span class="line"><span class="keyword">from</span> metagpt.actions <span class="keyword">import</span> UserRequirement</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCoder</span>(<span class="title class_ inherited__">Role</span>):</span><br><span class="line">    name: <span class="built_in">str</span> = <span class="string">"Alice"</span></span><br><span class="line">    profile: <span class="built_in">str</span> = <span class="string">"SimpleCoder"</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line">        <span class="variable language_">self</span>._watch([UserRequirement])</span><br><span class="line">        <span class="variable language_">self</span>.set_actions([SimpleWriteCode])</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleTester</span>(<span class="title class_ inherited__">Role</span>):</span><br><span class="line">    name: <span class="built_in">str</span> = <span class="string">"Bob"</span></span><br><span class="line">    profile: <span class="built_in">str</span> = <span class="string">"SimpleTester"</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line">        <span class="variable language_">self</span>.set_actions([SimpleWriteTest])</span><br><span class="line">        <span class="variable language_">self</span>._watch([SimpleWriteCode])</span><br><span class="line">        <span class="comment"># self._watch([SimpleWriteCode, SimpleWriteReview])  # feel free to try this too</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_act</span>(<span class="params">self</span>) -&gt; Message:</span><br><span class="line">        logger.info(<span class="string">f"<span class="subst">{self._setting}</span>: to do <span class="subst">{self.rc.todo}</span>(<span class="subst">{self.rc.todo.name}</span>)"</span>)</span><br><span class="line">        todo = <span class="variable language_">self</span>.rc.todo</span><br><span class="line">        <span class="comment"># context = self.get_memories(k=1)[0].content # use the most recent memory as context</span></span><br><span class="line">        context = <span class="variable language_">self</span>.get_memories()  <span class="comment"># use all memories as context</span></span><br><span class="line">        code_text = <span class="keyword">await</span> todo.run(context, k=<span class="number">5</span>)  <span class="comment"># specify arguments</span></span><br><span class="line">        msg = Message(content=code_text, role=<span class="variable language_">self</span>.profile, cause_by=<span class="built_in">type</span>(todo))</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleReviewer</span>(<span class="title class_ inherited__">Role</span>):</span><br><span class="line">    name: <span class="built_in">str</span> = <span class="string">"Charlie"</span></span><br><span class="line">    profile: <span class="built_in">str</span> = <span class="string">"SimpleReviewer"</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line">        <span class="variable language_">self</span>.set_actions([SimpleWriteReview])</span><br><span class="line">        <span class="variable language_">self</span>._watch([SimpleWriteTest])    </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"><span class="keyword">from</span> metagpt.logs <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> metagpt.team <span class="keyword">import</span> Team</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>(<span class="params"></span></span><br><span class="line"><span class="params">    idea: <span class="built_in">str</span> = <span class="string">"write a function that calculates the product of a list"</span>,</span></span><br><span class="line"><span class="params">    investment: <span class="built_in">float</span> = <span class="number">3.0</span>,</span></span><br><span class="line"><span class="params">    n_round: <span class="built_in">int</span> = <span class="number">5</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    logger.info(idea)</span><br><span class="line">    team = Team()</span><br><span class="line">    team.hire(</span><br><span class="line">        [</span><br><span class="line">            SimpleCoder(),</span><br><span class="line">            SimpleTester(),</span><br><span class="line">            SimpleReviewer(),</span><br><span class="line">            <span class="comment"># SimpleReviewer(is_human=True),</span></span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    team.invest(investment=investment)</span><br><span class="line">    team.run_project(idea)</span><br><span class="line">    <span class="keyword">await</span> team.run(n_round=n_round)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    fire.Fire(main)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2024-12-13 11:18:07.884 | INFO     | metagpt.const:get<span class="emphasis">_metagpt_</span>package<span class="emphasis">_root:29 - Package root set to C:\CodeRepos\python\MyCode\Learnning_</span>MetaGPT</span><br><span class="line">2024-12-13 11:18:11.354 | INFO     | <span class="strong">__main__</span>:main:127 - 写一个函数，能计算列表所有元素的乘积</span><br><span class="line">2024-12-13 11:18:11.367 | INFO     | metagpt.team:invest:90 - Investment: $3.0.</span><br><span class="line">2024-12-13 11:18:11.375 | INFO     | metagpt.roles.role:<span class="emphasis">_act:391 - Alice(SimpleCoder): to do SimpleWriteCode(SimpleWriteCode)</span></span><br><span class="line"><span class="emphasis">2024-12-13 11:19:01.147 | WARNING  | metagpt. Utils. Cost_</span>manager:update<span class="emphasis">_cost: 49 - Model qwen 2.5:14b not found in TOKEN_</span>COSTS. </span><br><span class="line">2024-12-13 11:19:01.156 | INFO     | <span class="strong">__main__</span>:<span class="emphasis">_act: 96 - Bob (SimpleTester): to do SimpleWriteTest (SimpleWriteTest)</span></span><br><span class="line"><span class="emphasis">2024-12-13 11:19:03.656 | WARNING  | metagpt. Utils. Cost_</span>manager:update<span class="emphasis">_cost: 49 - Model qwen 2.5:14b not found in TOKEN_</span>COSTS.</span><br><span class="line">2024-12-13 11:19:03.662 | INFO     | metagpt. Roles. Role:<span class="emphasis">_act: 391 - Charlie (SimpleReviewer): to do SimpleWriteReview (SimpleWriteReview)</span></span><br><span class="line"><span class="emphasis">测试用例覆盖了多种情况，包括正数、负数、包含零的列表以及空列表和单元素列表。这有助于确保函数在各种输入下的正确性。</span></span><br><span class="line"><span class="emphasis">一个关键性的评论是：测试用例应该考虑到列表中可能存在的非整数值（如浮点数或复数），以验证函数是否能够处理这些情况并返回正确的</span></span><br><span class="line"><span class="emphasis">结果。例如，可以添加如下测试案例：</span></span><br><span class="line"><span class="emphasis">这将确保函数不仅限于整数列表，还能处理更广泛的数据类型。</span></span><br><span class="line"><span class="emphasis">2024-12-13 11:19:06.484 | WARNING  | metagpt. Utils. Cost_</span>manager:update<span class="emphasis">_cost: 49 - Model qwen 2.5:14b not found in TOKEN_</span>COSTS. </span><br></pre></td></tr></tbody></table></figure><p>在多 Agent 中，Meta 定义多个角色，并通过<code>_watch</code> 监视某个动作是否出现执行结果，这就类似构建一个流程，自身的执行依赖被监视的结果出现，和 llamaIndex 构建 Flow 时，使用的 @listen () 一个道理<br>在人工构建_watch 逻辑过程中，相当于构建了多 Agent 的执行流程，也就是构建了处理任务的 SOP，类似下图：用户需求 -&gt;SimpleCodeer-&gt;SimpleTester-&gt;SimpleReviewer，但是虽然有流程，但是 llm 会根据输出，存在回环的问题，比如 SimpleReviewer-&gt;SimpleTester。</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/MetaGPT-Flow-20250115191734.png" alt="MetaGPT-Flow-20250115191734"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;单个智能体可以执行一个或多个动作，那是不是一直使用一个智能体即可呢？存在以下两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Prompt 依赖&lt;/strong&gt;：动作越多，要求 Prompt 越精细，才能准确控制其动作，尤其是有相似动作时&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动作选择上限&lt;/strong&gt;：Openai 建议一个 agent 绑定不超过 20 个动作，动作太多，agent 选择工具能力下降  &lt;a href=&quot;https://platform.openai.com/docs/guides/function-calling#best-practices-for-defining-functions&quot;&gt;Function calling - OpenAI API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SOP (标准作业流程) 问题&lt;/strong&gt;：在现实工作中，常常存在一个标准流程，如果每次节点都依赖 llm 去选择后续的逻辑分支，软件变得不可控&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="MetaGPT" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/MetaGPT/"/>
    
    
  </entry>
  
  <entry>
    <title>RAG 的 Generator 优化之 Verification</title>
    <link href="https://www.shaogui.life/posts/1119887092.html"/>
    <id>https://www.shaogui.life/posts/1119887092.html</id>
    <published>2024-12-10T05:52:43.000Z</published>
    <updated>2025-01-18T10:54:21.370Z</updated>
    
    <content type="html"><![CDATA[<p>通过 llm 评估模型的生成结果</p><span id="more"></span><h3 id="knowledge-base"><a class="markdownIt-Anchor" href="#knowledge-base"></a> Knowledge-base</h3><p>通过外部知识验证 LLM 生成的答案。通常首先从生成的答案中提取特定的陈述或三元组，然后从验证过的知识库（如维基百科或知识图谱）中检索相关证据。最后将每个陈述与证据进行对比，以确定该陈述是被支持、被驳斥，还是缺乏足够的证据</p><h3 id="model-based"><a class="markdownIt-Anchor" href="#model-based"></a> Model-based</h3><p>使用小型语言模型来验证 LLM 生成的答案。根据输入的问题、检索到的知识和生成的答案，训练一个小型语言模型来判断生成的答案是否正确反映了检索到的信息。该过程类似于多项选择题，验证器需判断答案是否正确反映了相关内容。如果答案不正确，可以重新生成答案，直到验证器确认答案正确</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过 llm 评估模型的生成结果&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="RAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/"/>
    
    <category term="NextRAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/NextRAG/"/>
    
    
  </entry>
  
  <entry>
    <title>RAG 的 Indexing 优化之 StructuralOrganization</title>
    <link href="https://www.shaogui.life/posts/3172040910.html"/>
    <id>https://www.shaogui.life/posts/3172040910.html</id>
    <published>2024-12-09T13:45:49.000Z</published>
    <updated>2025-01-18T10:54:21.370Z</updated>
    
    <content type="html"><![CDATA[<p>ChunkOptimization 是直接修改 Chunk 的内容，而 StructuralOrganization 集中在如何通过组织 Chunk，实现更加高效的检索</p><span id="more"></span><h3 id="分层indexing"><a class="markdownIt-Anchor" href="#分层indexing"></a> 分层 Indexing</h3><p>建立分层结构是增强信息检索的一种有效方法。通过构建文档的分层结构，可以加快相关数据的检索与处理</p><p>检索过程从较宽的数据块或父节点开始，然后在链接到所选父节点的较小数据块或子节点中进行更集中的搜索。分层索引不仅可以提高检索效率，还可以最大限度地减少最终输出中包含不相关的数据</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/%E5%88%86%E5%B1%82Indexing-20241216133406.png" alt="分层Indexing-20241216133406"></p><p>构建结构化索引的方法主要包括：</p><ul><li>1）基于段落和句子分割的结构感知；</li><li>2）基于 PDF、HTML 和 Latex 等内在结构的内容感知；</li><li>3）基于语义识别和分割的语义感知</li></ul><h3 id="知识图谱检索"><a class="markdownIt-Anchor" href="#知识图谱检索"></a> 知识图谱检索</h3><p>图形搜索利用知识图谱来增强信息检索。通过将数据表示为图形，其中节点表示实体，边缘表示关系，您可以发现关键字搜索或语义搜索方法可能会遗漏的复杂联系。当您输入查询时，图形搜索算法会导航这些关系，从而允许您根据数据的互连性检索直接匹配项和上下文相关信息</p><p>此方法对于涉及复杂数据集的应用程序特别有用，在这些应用程序中，了解关系是获得见解的关键。要使用 Graph Search，您必须首先使用 LLM 将数据转换为知识图谱，然后使用 Cypher 查询根据用户查询检索数据</p><p>知识图谱能解决一些全局性的复杂问题</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ChunkOptimization 是直接修改 Chunk 的内容，而 StructuralOrganization 集中在如何通过组织 Chunk，实现更加高效的检索&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="RAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/"/>
    
    <category term="NextRAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/NextRAG/"/>
    
    
  </entry>
  
  <entry>
    <title>文档分块处理准则</title>
    <link href="https://www.shaogui.life/posts/2706962146.html"/>
    <id>https://www.shaogui.life/posts/2706962146.html</id>
    <published>2024-12-07T15:13:36.000Z</published>
    <updated>2025-01-18T10:54:12.276Z</updated>
    
    <content type="html"><![CDATA[<p>在构建 rag 应用时，读取文档后的下一步是对文档进行分块，之所以分块。理由如下：</p><ul><li><strong>llms 一次输入有限</strong>：prompt 无法接受太多输入，拿 4 K 大小的模型来说，大概可以输入 4 K*1.5=6000 左右的汉字，过长的上下文不仅会出现截断问题，还导致推理耗时增加</li><li><strong>语义混乱</strong>：一次性输入过长的上下文，llms 可能回答不准确，通过语义筛选相关文档后，使得上下文的语义更集中</li></ul><p>一个合理的切分方式，每个 chunk 语义完整，长度适中，<strong>过长</strong>：虽然 chunk 减少，使得向量数据库检索更快，但是 llm 推理成本上升，<strong>过短</strong>：语义被切割，一些精准的问题无法召回 chunk</p><span id="more"></span><p>目前没有一套通用的分块方式，但是一般使用以下方法</p><p><img data-src="https://cdn.sanity.io/images/tf66morw/production/9f74cf3fa45aa3c2cde2e0dcc7e7e285dd3ec5c1-2398x1254.png?rect=0,1,2398,1253&amp;w=1366&amp;h=714&amp;auto=format" alt=""></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.node_parser <span class="keyword">import</span> TokenTextSplitter </span><br><span class="line">text=<span class="string">"""东汉末年，朝政腐败，再加上连年灾荒，老百姓的日子非常困苦。</span></span><br><span class="line"><span class="string">巨鹿人张角见人民怨恨官府，便与他的弟弟张梁、张宝在河北、河南、山东、湖北、江苏等地，招收了五十万人，举行起义，一起向官兵进攻。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">text_splitter=TokenTextSplitter(chunk_size=<span class="number">30</span>,chunk_overlap=<span class="number">10</span>)</span><br><span class="line">text_splitter.split_text(text)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">['东汉末年，朝政腐败，再加上连年灾荒，老百姓',</span><br><span class="line"> '灾荒，老百姓的日子非常困苦。\n巨鹿人张角见',</span><br><span class="line"> '巨鹿人张角见人民怨恨官府，便与他的弟弟',</span><br><span class="line"> '，便与他的弟弟张梁、张宝在河北、河南、山东、',</span><br><span class="line"> '北、河南、山东、湖北、江苏等地，招收了五十万人，举',</span><br><span class="line"> '收了五十万人，举行起义，一起向官兵进攻。']</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line">text_splitter=RecursiveCharacterTextSplitter(separators=[<span class="string">"。"</span>,<span class="string">""</span>],chunk_size=<span class="number">30</span>,chunk_overlap=<span class="number">10</span>)</span><br><span class="line">text_splitter.split_text(text)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">['东汉末年，朝政腐败，再加上连年灾荒，老百姓的日子非常困苦',</span><br><span class="line"> '。\n巨鹿人张角见人民怨恨官府，便与他的弟弟张梁、张宝在河北、',</span><br><span class="line"> '弟张梁、张宝在河北、河南、山东、湖北、江苏等地，招收了五十万',</span><br><span class="line"> '苏等地，招收了五十万人，举行起义，一起向官兵进攻',</span><br><span class="line"> '。']</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> llama_index.core.text_splitter <span class="keyword">import</span> SentenceSplitter</span><br><span class="line">text_splitter=SentenceSplitter(chunk_size=<span class="number">30</span>,chunk_overlap=<span class="number">10</span>)</span><br><span class="line">text_splitter.split_text(text)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">['东汉末年，朝政腐败，再加上连年灾荒，老百姓',</span><br><span class="line"> '灾荒，老百姓的日子非常困苦。\n巨鹿人张角见',</span><br><span class="line"> '巨鹿人张角见人民怨恨官府，便与他的弟弟',</span><br><span class="line"> '，便与他的弟弟张梁、张宝在河北、河南、山东、',</span><br><span class="line"> '北、河南、山东、湖北、江苏等地，招收了五十万人，举',</span><br><span class="line"> '收了五十万人，举行起义，一起向官兵进攻。']</span><br></pre></td></tr></tbody></table></figure><p><a href="https://chunkviz.up.railway.app/">ChunkViz</a>  提供一种可视化的方式查看切分效果，效果如下</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/%E6%96%87%E6%A1%A3%E5%88%86%E5%9D%97%E5%A4%84%E7%90%86%E5%87%86%E5%88%99-20250115213849.png" alt="文档分块处理准则-20250115213849"></p><p><strong>总结</strong>：针对不同的文档有不同的切分方案，比如文档包含：图片、表格、公式时，就不能使用简单的切分思路。一个是要考虑切分效果，另一个要考虑构建索引的效率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在构建 rag 应用时，读取文档后的下一步是对文档进行分块，之所以分块。理由如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;llms 一次输入有限&lt;/strong&gt;：prompt 无法接受太多输入，拿 4 K 大小的模型来说，大概可以输入 4 K*1.5=6000 左右的汉字，过长的上下文不仅会出现截断问题，还导致推理耗时增加&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语义混乱&lt;/strong&gt;：一次性输入过长的上下文，llms 可能回答不准确，通过语义筛选相关文档后，使得上下文的语义更集中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个合理的切分方式，每个 chunk 语义完整，长度适中，&lt;strong&gt;过长&lt;/strong&gt;：虽然 chunk 减少，使得向量数据库检索更快，但是 llm 推理成本上升，&lt;strong&gt;过短&lt;/strong&gt;：语义被切割，一些精准的问题无法召回 chunk&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="RAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/"/>
    
    <category term="NaiveRAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/NaiveRAG/"/>
    
    
  </entry>
  
  <entry>
    <title>MetaGPT-Agent</title>
    <link href="https://www.shaogui.life/posts/2549080241.html"/>
    <id>https://www.shaogui.life/posts/2549080241.html</id>
    <published>2024-12-07T07:12:22.000Z</published>
    <updated>2025-01-18T10:53:09.994Z</updated>
    
    <content type="html"><![CDATA[<p>MetaGPT 是多 Agent 框架，通过定义不同的角色及其动作，组件团队去解决问题</p><span id="more"></span><p>如果使用自定义模型，在初始使用时需要在项目根目录下，新建 config 文件夹，并创建 config2.yaml 文件，假设使用 ollama 模型，写入如下模型，如果使用网页搜索、网页浏览、语音转换工具，也需要在这个文件配置 api_key 等信息</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">llm:</span></span><br><span class="line">  <span class="attr">api_type:</span> <span class="string">'ollama'</span></span><br><span class="line">  <span class="attr">base_url:</span> <span class="string">'http://192.168.3.155:11434/api'</span></span><br><span class="line">  <span class="attr">model:</span> <span class="string">'llama3.1:latest'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="配置文件说明"><a class="markdownIt-Anchor" href="#配置文件说明"></a> 配置文件说明</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nest_asyncio</span><br><span class="line">nest_asyncio.apply()</span><br><span class="line"><span class="comment"># 查看-修改配置</span></span><br><span class="line"><span class="keyword">from</span> metagpt.config2 <span class="keyword">import</span> Config</span><br><span class="line">config=Config.default()</span><br><span class="line"><span class="built_in">print</span>(config)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2024-12-13 10:48:56.569 | INFO     | metagpt.const:get<span class="emphasis">_metagpt_</span>package<span class="emphasis">_root:29 - Package root set to c:\CodeRepos\python\MyCode\Learnning_</span>MetaGPT</span><br><span class="line">extra<span class="emphasis">_fields=None project_</span>path='' project<span class="emphasis">_name='' inc=False reqa_</span>file='' max<span class="emphasis">_auto_</span>summarize<span class="emphasis">_code=0 git_</span>reinit=False llm=LLMConfig(extra<span class="emphasis">_fields=None, api_</span>key='sk-', api<span class="emphasis">_type=<span class="language-xml"><span class="tag">&lt;<span class="name">LLMType.OLLAMA:</span> '<span class="attr">ollama</span>'&gt;</span></span>, base_</span>url='http://192.168.3.155:11434/api', api<span class="emphasis">_version=None, model='qwen2.5:latest', pricing_</span>plan=None, access<span class="emphasis">_key=None, secret_</span>key=None, endpoint=None, app<span class="emphasis">_id=None, api_</span>secret=None, domain=None, max<span class="emphasis">_token=4096, temperature=0.0, top_</span>p=1.0, top<span class="emphasis">_k=0, repetition_</span>penalty=1.0, stop=None, presence<span class="emphasis">_penalty=0.0, frequency_</span>penalty=0.0, best<span class="emphasis">_of=None, n=None, stream=False, logprobs=None, top_</span>logprobs=None, timeout=600, proxy=None, calc<span class="emphasis">_usage=True) proxy='' search=SearchConfig(extra_</span>fields=None, api<span class="emphasis">_type=<span class="language-xml"><span class="tag">&lt;<span class="name">SearchEngineType.DUCK_DUCK_GO:</span> '<span class="attr">ddg</span>'&gt;</span></span>, api_</span>key='', cse<span class="emphasis">_id='', search_</span>func=None, params={'engine': 'google', 'google<span class="emphasis">_domain': 'google.com', 'gl': 'us', 'hl': 'en'}) browser=BrowserConfig(extra_</span>fields=None, engine=<span class="language-xml"><span class="tag">&lt;<span class="name">WebBrowserEngineType.PLAYWRIGHT:</span> '<span class="attr">playwright</span>'&gt;</span></span>, browser<span class="emphasis">_type='chromium') mermaid=MermaidConfig(extra_</span>fields=None, engine='nodejs', path='mmdc', puppeteer<span class="emphasis">_config='', pyppeteer_</span>path='/usr/bin/google-chrome-stable') s3=None redis=None repair<span class="emphasis">_llm_</span>output=False prompt<span class="emphasis">_schema='json' workspace=WorkspaceConfig(extra_</span>fields=None, path=WindowsPath('c:/CodeRepos/python/MyCode/Learnning<span class="emphasis">_MetaGPT/workspace'), use_</span>uid=False, uid='') enable<span class="emphasis">_longterm_</span>memory=False code<span class="emphasis">_review_</span>k<span class="emphasis">_times=2 metagpt_</span>tti<span class="emphasis">_url='' language='zh_</span>cn' redis<span class="emphasis">_key='placeholder' iflytek_</span>app<span class="emphasis">_id='' iflytek_</span>api<span class="emphasis">_secret='' iflytek_</span>api<span class="emphasis">_key='' azure_</span>tts<span class="emphasis">_subscription_</span>key='' azure<span class="emphasis">_tts_</span>region=''</span><br></pre></td></tr></tbody></table></figure><h2 id="创建-agent"><a class="markdownIt-Anchor" href="#创建-agent"></a> 创建 Agent</h2><p>在 Meta 中，工具 (tool) 和角色 (role) 是核心概念，一个 role 代表一个 agent，以下代码通过创建 role，创建智能体 (agent)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> metagpt.context <span class="keyword">import</span> Context</span><br><span class="line"><span class="keyword">from</span> metagpt.roles.product_manager <span class="keyword">import</span> ProductManager</span><br><span class="line"><span class="keyword">from</span> metagpt.logs <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    msg=<span class="string">'编写贪吃蛇游戏的产品需求文档'</span></span><br><span class="line">    context=Context()</span><br><span class="line">    <span class="comment"># print('context:\n',context)</span></span><br><span class="line">    role=ProductManager(context=context)</span><br><span class="line">    <span class="keyword">while</span> msg:</span><br><span class="line">        msg=<span class="keyword">await</span> role.run(msg)</span><br><span class="line">        logger.info(<span class="built_in">str</span>(msg))</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></tbody></table></figure><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">2024-12-13 10:49:04.332 | INFO     | metagpt.roles.role:<span class="emphasis">_act:391 - Alice(Product Manager): to do PrepareDocuments(PrepareDocuments)</span></span><br><span class="line"><span class="emphasis">2024-12-13 10:49:04.715 | INFO     | metagpt.utils.file_</span>repository:save:57 - save to: C:\CodeRepos\python\MyCode\Learnning<span class="emphasis">_MetaGPT\workspace\20241213104904\docs\requirement.txt</span></span><br><span class="line"><span class="emphasis">2024-12-13 10:49:04.717 | INFO     | <span class="strong">__main__</span>:main:16 - Alice(Product Manager): {'root_</span>path': 'docs', 'filename': 'requirement.txt', 'content': '编写贪吃蛇游戏的产品需求文档'}</span><br><span class="line">2024-12-13 10:49:04.718 | INFO     | metagpt.roles.role:<span class="emphasis">_act:391 - Alice(Product Manager): to do WritePRD(WritePRD)</span></span><br><span class="line"><span class="emphasis">2024-12-13 10:49:04.720 | INFO     | metagpt.actions.write_</span>prd:run:86 - New requirement detected: 编写贪吃蛇游戏的产品需求文档</span><br><span class="line">[CONTENT]</span><br><span class="line">{</span><br><span class="line"><span class="code">    "Language": "zh_cn",</span></span><br><span class="line"><span class="code">    "Programming Language": "Python",</span></span><br><span class="line"><span class="code">    "Original Requirements": "编写贪吃蛇游戏的产品需求文档",</span></span><br><span class="line"><span class="code">    "Project Name": "snake_game",</span></span><br><span class="line"><span class="code">    "Product Goals": [</span></span><br><span class="line"><span class="code">        "提供流畅的游戏体验",</span></span><br><span class="line"><span class="code">        "提高可访问性，确保响应迅速",</span></span><br><span class="line"><span class="code">        "设计美观的用户界面"</span></span><br><span class="line"><span class="code">    ],</span></span><br><span class="line"><span class="code">    "User Stories": [</span></span><br><span class="line"><span class="code">        "作为玩家，我希望可以选择不同的难度级别",</span></span><br><span class="line"><span class="code">        "作为玩家，我希望在游戏结束后可以看到得分",</span></span><br><span class="line"><span class="code">        "作为玩家，我希望在失败后可以重新开始游戏",</span></span><br><span class="line"><span class="code">        "作为玩家，我希望看到一个美观且舒适的UI",</span></span><br><span class="line"><span class="code">        "作为玩家，我希望可以在手机上玩这款游戏"</span></span><br><span class="line"><span class="code">    ],</span></span><br><span class="line"><span class="code">    "Competitive Analysis": [</span></span><br><span class="line"><span class="code">        "贪吃蛇游戏A：界面简单，缺乏响应性功能",</span></span><br><span class="line"><span class="code">        "SnakeGame.com: 美观且响应迅速的UI，显示最高得分",</span></span><br><span class="line"><span class="code">        "SnakeOnline.net: 响应迅速的UI，显示最高得分，但有大量广告",</span></span><br><span class="line"><span class="code">        "SnakeWorld.org: 丰富的关卡设计和奖励系统，但界面较为复杂",</span></span><br><span class="line"><span class="code">        "SnakeChallenge.io: 高度定制化的游戏体验，但操作较难上手"</span></span><br><span class="line"><span class="code">    ],</span></span><br><span class="line"><span class="code">    "Competitive Quadrant Chart": "quadrantChart\n    title \"用户参与度与吸引力分析\"\n    x-axis \"低吸引力\" --&gt; \"高吸引力\"\n    y-axis \"低参与度\" --&gt; \"高参与度\"\n    quadrant-1 \"我们应扩大市场\"\n    quadrant-2 \"需要推广\"\n    quadrant-3 \"重新评估\"\n    quadrant-4 \"可能改进\"\n    \"游戏A\": [0.3, 0.6]\n    \"游戏B\": [0.5, 0.4]\n    \"游戏C\": [0.7, 0.8]\n    \"游戏D\": [0.2, 0.1]\n    \"游戏E\": [0.9, 0.3]\n    \"我们的目标产品\": [0.65, 0.7]",</span></span><br><span class="line"><span class="code">    "Requirement Analysis": "",</span></span><br><span class="line"><span class="code">    "Requirement Pool": [</span></span><br><span class="line"><span class="code">        ["P0", "实现基本的游戏逻辑"],</span></span><br><span class="line"><span class="code">        ["P0", "设计游戏界面和交互"],</span></span><br><span class="line"><span class="code">        ["P1", "添加不同难度级别的选择"],</span></span><br><span class="line"><span class="code">        ["P2", "实现得分显示功能"],</span></span><br><span class="line"><span class="code">        ["P2", "加入重新开始按钮"]</span></span><br><span class="line"><span class="code">    ],</span></span><br><span class="line"><span class="code">    "UI Design draft": "设计简洁的界面布局，使用清新舒适的色彩</span></span><br><span class="line"><span class="code">2024-12-13 10:49:13.369 | INFO     | metagpt.utils.cost_manager:update_cost:57 - Total running cost: $0.003 | Max budget: $10.000 | Current cost: $0.003, prompt_tokens: 948, completion_tokens: 546</span></span><br><span class="line"><span class="code">2024-12-13 10:49:13.377 | INFO     | metagpt.utils.git_repository:rename_root:203 - Delete directory C:\CodeRepos\python\MyCode\Learnning_MetaGPT\workspace\snake_game</span></span><br><span class="line"><span class="code">搭配。",</span></span><br><span class="line"><span class="code">    "Anything UNCLEAR": ""</span></span><br><span class="line"><span class="code">}</span></span><br><span class="line"><span class="code">[/CONTENT]</span></span><br><span class="line"><span class="code">2024-12-13 10:49:13.459 | WARNING  | metagpt.utils.git_repository:rename_root:214 - Move C:\CodeRepos\python\MyCode\Learnning_MetaGPT\workspace\20241213104904 to C:\CodeRepos\python\MyCode\Learnning_MetaGPT\workspace\snake_game error: [WinError 32] 另一个程序正在使用此文件，进程无法访问。: 'C:\\CodeRepos\\python\\MyCode\\Learnning_MetaGPT\\workspace\\20241213104904'</span></span><br><span class="line"><span class="code">2024-12-13 10:49:13.460 | INFO     | metagpt.utils.git_repository:rename_root:219 - Rename directory C:\CodeRepos\python\MyCode\Learnning_MetaGPT\workspace\20241213104904 to C:\CodeRepos\python\MyCode\Learnning_MetaGPT\workspace\snake_game</span></span><br><span class="line"><span class="code">2024-12-13 10:49:13.722 | INFO     | metagpt.utils.file_repository:save:57 - save to: C:\CodeRepos\python\MyCode\Learnning_MetaGPT\workspace\snake_game\docs\prd\20241213104913.json</span></span><br><span class="line"><span class="code">2024-12-13 10:49:13.823 | WARNING  | metagpt.utils.mermaid:mermaid_to_file:35 - RUN `npm install -g @mermaid-js/mermaid-cli` to install mmdc,or consider changing engine to `playwright`, `pyppeteer`, or `ink`.</span></span><br><span class="line"><span class="code">2024-12-13 10:49:13.826 | INFO     | metagpt.utils.file_repository:save:57 - save to: C:\CodeRepos\python\MyCode\Learnning_MetaGPT\workspace\snake_game\resources\prd\20241213104913.md</span></span><br><span class="line"><span class="code">2024-12-13 10:49:13.827 | INFO     | __main__:main:16 - Alice(Product Manager): {'docs': {'20241213104913.json': {'root_path': 'docs\\prd', 'filename': '20241213104913.json', 'content': '{"Language":"zh_cn","Programming Language":"Python","Original Requirements":"编写贪吃蛇游戏的产品需求文档","Project Name":"snake_game","Product Goals":["提供流畅的游戏体验","提高可访问性，确保响应迅速","设计美观的用户界面"],"User Stories":["作为玩家，我希望可以选择不同的难度级别","作为玩家，我希望在游戏结束后可以看到得分","作为玩家，我希望在失败后可以重新开始游戏","作为玩家，我希望看到一个美观且舒适的UI","作为玩家，我希望可以在手机上玩这款游戏"],"Competitive Analysis":["贪吃蛇游戏A：界面简单，缺乏响应性功能","SnakeGame.com: 美观且响应迅速的UI，显示最高得分","SnakeOnline.net: 响应迅速的UI，显示最高得分，但有大量广告","SnakeWorld.org: 丰富的关卡设计和奖励系统，但界面较为复杂","SnakeChallenge.io: 高度定制化的游戏体验，但操作较难上手"],"Competitive Quadrant Chart":"quadrantChart\\n    title \\"用户参与度与吸引力分析\\"\\n    x-axis \\"低吸引力\\" --&gt; \\"高吸引力\\"\\n    y-axis \\"低参与度\\" --&gt; \\"高参与度\\"\\n    quadrant-1 \\"我们应扩大市场\\"\\n    quadrant-2 \\"需要推广\\"\\n    quadrant-3 \\"重新评估\\"\\n    quadrant-4 \\"可能改进\\"\\n    \\"游戏A\\": [0.3, 0.6]\\n    \\"游戏B\\": [0.5, 0.4]\\n    \\"游戏C\\": [0.7, 0.8]\\n    \\"游戏D\\": [0.2, 0.1]\\n    \\"游戏E\\": [0.9, 0.3]\\n    \\"我们的目标产品\\": [0.65, 0.7]","Requirement Analysis":"","Requirement Pool":"P0","实现基本的游戏逻辑"],["P0","设计游戏界面和交互"],["P1","添加不同难度级别的选择"],["P2","实现得分显示功能"],["P2","加入重新开始按钮","UI Design draft":"设计简洁的界面布局，使用清新舒适的色彩搭配。","Anything UNCLEAR":""}'}}}</span></span><br><span class="line"><span class="code">2024-12-13 10:49:13.829 | INFO     | __main__:main:16 - None</span></span><br></pre></td></tr></tbody></table></figure><p>运行后，结果以文件形式保存，保存位置：docs\prd\*. Json</p><h2 id="为-agent-绑定动作"><a class="markdownIt-Anchor" href="#为-agent-绑定动作"></a> 为 Agent 绑定动作</h2><p>单纯的智能体只能简单地回答问题，我们需要一些能力更强的 Agent，可以调用工具去完成任务，这就涉及 MetaGPT 的另一个核心概念：动作 (Action)<br>在 MetaGPT 中，类 Action 是动作的逻辑抽象。用户可以通过简单地调用 self._aask 函数让 LLM 拥有这个动作的能力</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nest_asyncio</span><br><span class="line">nest_asyncio.apply()</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> metagpt.actions <span class="keyword">import</span> Action</span><br><span class="line"><span class="keyword">from</span> metagpt.logs <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleWriteCode</span>(<span class="title class_ inherited__">Action</span>):</span><br><span class="line">    PROMPT_TEMPLATE: <span class="built_in">str</span> = <span class="string">"""</span></span><br><span class="line"><span class="string">    Write a python function that can {instruction} and provide two runnnable test cases.</span></span><br><span class="line"><span class="string">    Return ```python your_code_here ``` with NO other texts,</span></span><br><span class="line"><span class="string">    your code:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    name:<span class="built_in">str</span> =<span class="string">'SimpleWriteCode'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,instruction: <span class="built_in">str</span></span>):</span><br><span class="line">        prompt=<span class="variable language_">self</span>.PROMPT_TEMPLATE.<span class="built_in">format</span>(instruction=instruction)</span><br><span class="line">        rsp=<span class="keyword">await</span> <span class="variable language_">self</span>._aask(prompt)</span><br><span class="line">        code_text=SimpleWriteCode.parse_code(rsp)</span><br><span class="line">        <span class="keyword">return</span> code_text</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_code</span>(<span class="params">rsp</span>):</span><br><span class="line">        pattern = <span class="string">r"```python(.*)```"</span></span><br><span class="line">        <span class="keyword">match</span>=re.search(pattern,rsp,re.DOTALL)</span><br><span class="line">        code_text=<span class="keyword">match</span>.group(<span class="number">1</span>) <span class="keyword">if</span> <span class="keyword">match</span> <span class="keyword">else</span> rsp</span><br><span class="line">        <span class="keyword">return</span> code_text</span><br></pre></td></tr></tbody></table></figure><blockquote><p>2024-12-13 09:20:49.717 | INFO     | metagpt.const:get_metagpt_package_root: 29 - Package root set to c:\CodeRepos\python\MyCode\Learnning_MetaGPT</p></blockquote><p>定义了动作，需要指定能执行动作的角色 (role)，除了前文通过 <code>ProductManager</code> 创建角色外，还可以自定义 role。类似 Action 的定义，role 也有一个抽象类，通过继承这个抽象类，并实现其中的 <code>_act</code> 函数</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> metagpt.roles <span class="keyword">import</span> Role</span><br><span class="line"><span class="keyword">from</span> metagpt.schema <span class="keyword">import</span> Message</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCoder</span>(<span class="title class_ inherited__">Role</span>):</span><br><span class="line">    name: <span class="built_in">str</span> = <span class="string">"Alice"</span></span><br><span class="line">    profile: <span class="built_in">str</span> = <span class="string">"SimpleCoder"</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line">        <span class="variable language_">self</span>.set_actions([SimpleWriteCode])</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_act</span>(<span class="params">self</span>) -&gt; Message:</span><br><span class="line">        logger.info(<span class="string">f"<span class="subst">{self._setting}</span>: to do <span class="subst">{self.rc.todo}</span>(<span class="subst">{self.rc.todo.name}</span>)"</span>)</span><br><span class="line">        todo = <span class="variable language_">self</span>.rc.todo  <span class="comment"># todo will be SimpleWriteCode()</span></span><br><span class="line">        msg = <span class="variable language_">self</span>.get_memories(k=<span class="number">1</span>)[<span class="number">0</span>]  <span class="comment"># find the most recent messages</span></span><br><span class="line">        code_text = <span class="keyword">await</span> todo.run(msg.content)</span><br><span class="line">        msg = Message(content=code_text, role=<span class="variable language_">self</span>.profile, cause_by=<span class="built_in">type</span>(todo))</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> metagpt.context <span class="keyword">import</span> Context</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    msg = <span class="string">"编写一个函数，计算数组的和"</span></span><br><span class="line">    context = Context()</span><br><span class="line">    role = SimpleCoder(context=context)</span><br><span class="line">    logger.info(msg)</span><br><span class="line">    result = <span class="keyword">await</span> role.run(msg)</span><br><span class="line">    logger.info(result)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></tbody></table></figure><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">2024-12-13 08:22:17.427 | INFO     | <span class="strong">__main__</span>:main:9 - 编写一个函数，计算数组的和</span><br><span class="line">   2024-12-13 08:22:17.428 | INFO     | <span class="strong">__main__</span>:<span class="emphasis">_act:13 - Alice(SimpleCoder): to do SimpleWriteCode(SimpleWriteCode)</span></span><br><span class="line"><span class="emphasis">   ```python</span></span><br><span class="line"><span class="emphasis">   def calculate_</span>sum(arr):</span><br><span class="line"><span class="code">       return sum(arr)</span></span><br><span class="line"><span class="code">   # Test case 1: Empty list</span></span><br><span class="line"><span class="code">   print(calculate_sum([]))  # Expected output: 0</span></span><br><span class="line"><span class="code">   # Test case 2: List with elements</span></span><br><span class="line"><span class="code">   print(calculate_sum([1, 2, 3, 4, 5]))</span></span><br><span class="line"><span class="code">   2024-12-13 08:22:18.405 | WARNING  | metagpt.utils.cost_manager:update_cost:49 - Model qwen2.5:latest not found in TOKEN_COSTS.</span></span><br><span class="line"><span class="code">   2024-12-13 08:22:18.406 | INFO     | __main__:main:11 - SimpleCoder: </span></span><br><span class="line"><span class="code">   def calculate_sum(arr):</span></span><br><span class="line"><span class="code">       return sum(arr)</span></span><br><span class="line"><span class="code">   # Test case 1: Empty list</span></span><br><span class="line"><span class="code">   print(calculate_sum([]))  # Expected output: 0</span></span><br><span class="line"><span class="code">   # Test case 2: List with elements</span></span><br><span class="line"><span class="code">   print(calculate_sum([1, 2, 3, 4, 5]))  # Expected output: 15</span></span><br><span class="line"><span class="code">     # Expected output: 15</span></span><br><span class="line"><span class="code">   \```</span></span><br></pre></td></tr></tbody></table></figure><h2 id="为-agent-绑定多个动作"><a class="markdownIt-Anchor" href="#为-agent-绑定多个动作"></a> 为 Agent 绑定多个动作</h2><p>以上例子，agent 只绑定一个动作，智能体对这个动作只有 2 个判断：是否选择使用工具，实际上 agent 可以更智能，能绑定多个动作，此时判断逻辑为：不执行动作 + 选择一个动作执行<br>前面例子已经定义了生成 Python 代码的动作，下面再为 agent 绑定运行代码的动作</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleRunCode</span>(<span class="title class_ inherited__">Action</span>):</span><br><span class="line">    name:<span class="built_in">str</span>=<span class="string">"SimpleRunCode"</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self,code_text:<span class="built_in">str</span></span>):</span><br><span class="line">        result=subprocess.run([<span class="string">"python"</span>,<span class="string">"-c"</span>,code_text],capture_output=<span class="literal">True</span>,text=<span class="literal">True</span>)</span><br><span class="line">        code_result=result.stdout</span><br><span class="line">        <span class="comment"># logger.info(f'{code_result=}')</span></span><br><span class="line">        <span class="keyword">return</span> code_result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新定义角色，绑定两个工具</span></span><br><span class="line"><span class="keyword">from</span> metagpt.roles <span class="keyword">import</span> Role</span><br><span class="line"><span class="keyword">from</span> metagpt.schema <span class="keyword">import</span> Message</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableCoder</span>(<span class="title class_ inherited__">Role</span>):</span><br><span class="line">    name: <span class="built_in">str</span> = <span class="string">"Alice"</span></span><br><span class="line">    profile: <span class="built_in">str</span> = <span class="string">"RunnableCoder"</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line">        <span class="variable language_">self</span>.set_actions([SimpleWriteCode, SimpleRunCode])</span><br><span class="line">        <span class="variable language_">self</span>._set_react_mode(react_mode=<span class="string">"by_order"</span>)  <span class="comment"># 按顺序执行动作</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_act</span>(<span class="params">self</span>) -&gt; Message:</span><br><span class="line">        logger.info(<span class="string">'---'</span>*<span class="number">5</span>)</span><br><span class="line">        logger.info(<span class="string">f"<span class="subst">{self._setting}</span>: to do <span class="subst">{self.rc.todo}</span>(<span class="subst">{self.rc.todo.name}</span>)"</span>)</span><br><span class="line">        logger.info(<span class="string">'---'</span>*<span class="number">5</span>)</span><br><span class="line">        <span class="comment"># By choosing the Action by order under the hood</span></span><br><span class="line">        todo = <span class="variable language_">self</span>.rc.todo</span><br><span class="line">        msg = <span class="variable language_">self</span>.get_memories(k=<span class="number">1</span>)[<span class="number">0</span>]  <span class="comment"># find the most k recent messages</span></span><br><span class="line">        result = <span class="keyword">await</span> todo.run(msg.content)</span><br><span class="line">        msg = Message(content=result, role=<span class="variable language_">self</span>.profile, cause_by=<span class="built_in">type</span>(todo))</span><br><span class="line">        <span class="variable language_">self</span>.rc.memory.add(msg)</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> metagpt.context <span class="keyword">import</span> Context</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    msg = <span class="string">"编写一个函数，计算数组的和"</span></span><br><span class="line">    context = Context()</span><br><span class="line">    role = RunnableCoder(context=context)</span><br><span class="line">    logger.info(msg)</span><br><span class="line">    result = <span class="keyword">await</span> role.run(msg)</span><br><span class="line">    logger.info(result)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></tbody></table></figure><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">2024-12-13 09:30:14.197 | INFO     | <span class="strong">__main__</span>:main:9 - 编写一个函数，计算数组的和</span><br><span class="line">2024-12-13 09:31:19.557 | INFO     | <span class="strong">__main__</span>:<span class="emphasis">_act:15 - ---------------</span></span><br><span class="line"><span class="emphasis">2024-12-13 09:31:19.559 | INFO     | <span class="strong">__main__</span>:_</span>act:16 - Alice(RunnableCoder): to do SimpleWriteCode(SimpleWriteCode)</span><br><span class="line">2024-12-13 09:31:19.561 | INFO     | <span class="strong">__main__</span>:<span class="emphasis">_act:17 - ---------------</span></span><br><span class="line"><span class="emphasis">```python</span></span><br><span class="line"><span class="emphasis">def calculate_</span>array<span class="emphasis">_sum(arr):</span></span><br><span class="line"><span class="emphasis">    return sum(arr)</span></span><br><span class="line"><span class="emphasis"># Test case 1: Empty array</span></span><br><span class="line"><span class="emphasis">test_</span>case<span class="emphasis">_1 = []</span></span><br><span class="line"><span class="emphasis">print(calculate_</span>array<span class="emphasis">_sum(test_</span>case<span class="emphasis">_1))  # Expected output: 0</span></span><br><span class="line"><span class="emphasis"># Test case 2: Array with elements</span></span><br><span class="line"><span class="emphasis">test_</span>case<span class="emphasis">_2 = [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="emphasis">print(calculate_</span>array<span class="emphasis">_sum(test_</span>case<span class="emphasis">_2))  #</span></span><br><span class="line"><span class="emphasis">2024-12-13 09:31:23.256 | WARNING  | metagpt.utils.cost_</span>manager:update<span class="emphasis">_cost:49 - Model qwen2.5:latest not found in TOKEN_</span>COSTS.</span><br><span class="line">2024-12-13 09:31:23.261 | INFO     | <span class="strong">__main__</span>:<span class="emphasis">_act:15 - ---------------</span></span><br><span class="line"><span class="emphasis">2024-12-13 09:31:23.263 | INFO     | <span class="strong">__main__</span>:_</span>act:16 - Alice(RunnableCoder): to do SimpleRunCode(SimpleRunCode)</span><br><span class="line">2024-12-13 09:31:23.264 | INFO     | <span class="strong">__main__</span>:<span class="emphasis">_act:17 - ---------------</span></span><br><span class="line"><span class="emphasis"> Expected output: 15</span></span><br><span class="line"><span class="emphasis">\```</span></span><br><span class="line"><span class="emphasis">2024-12-13 09:32:05.116 | INFO     | <span class="strong">__main__</span>:main:11 - RunnableCoder: 0</span></span><br><span class="line"><span class="emphasis">15</span></span><br></pre></td></tr></tbody></table></figure><p>结果显示，role 分别调用 SimpleWriteCode、SimpleRunCode 动作，生成代码并进行运行（由于 logger 在并发编程中的问题，输出部分错乱）<br>总结：</p><ul><li><strong>Action</strong>：对应 langchian、llamaIndex 的工具，通过继承 Action 类 + 实现 run 函数，实现自定义</li><li><strong> Role</strong>：对应 langchian、llamaIndex 的 Agent，通过继承 Role 类 + 实现_act 函数，实现自定义</li></ul><p>Role 的执行逻辑：</p><ol><li>通过 self. Rc. Todo 获取下一步需要执行的动作</li><li>通过 self. Get_memories (k=1)[0] 获取 Role 最近的 K 个 messages</li><li> 通过 todo.Run (msg. Content) 执行动作，并获得结果</li></ol><p>通过调试，发现 role.Run (msg) 背后逻辑如下，即按顺序调用动作</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_act_by_order</span>(<span class="params">self</span>) -&gt; Message:</span><br><span class="line">    <span class="string">"""switch action each time by order defined in _init_actions, i.e. _act (Action1) -&gt; _act (Action2) -&gt; ..."""</span></span><br><span class="line">    start_idx = <span class="variable language_">self</span>.rc.state <span class="keyword">if</span> <span class="variable language_">self</span>.rc.state &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>  <span class="comment"># action to run from recovered state</span></span><br><span class="line">    rsp = Message(content=<span class="string">"No actions taken yet"</span>)  <span class="comment"># return default message if actions=[]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_idx, <span class="built_in">len</span>(<span class="variable language_">self</span>.states)):</span><br><span class="line">        Self._set_state (i)</span><br><span class="line">        Rsp = <span class="keyword">await</span> <span class="variable language_">self</span>._act ()</span><br><span class="line">    Return rsp  <span class="comment"># return output from the last action</span></span><br></pre></td></tr></tbody></table></figure><p>关于 Role 内，动作的执行逻辑有三个方向：</p><ul><li>React：边思考边执行，不断循环，直到解决问题</li><li> Order：按顺序执行</li><li> Plan_and_act：先规划，然后按步骤执行</li></ul><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/MetaGPT-Agent-20250115192633.png" alt="MetaGPT-Agent-20250115192633"></p><p>如果设置 Role 的相应方式为：RoleReactMode. REACT，那么调用将是以上图片的逻辑，概括如下</p><ol><li>Role 观察用户输入 (_observe)</li><li> 通过 llm 选择执行工具 (_think)，</li><li>执行工具 (_act)，得到结果</li><li> Llm 判定结果是否回答用户问题，不能回答时，再次执行 2-3，重复多次，直到能回答问题<br>重复执行 2-3 的过程，就是所谓的 react</li></ol><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/MetaGPT-Agent-20250115192552.png" alt="MetaGPT-Agent-20250115192552"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MetaGPT 是多 Agent 框架，通过定义不同的角色及其动作，组件团队去解决问题&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="MetaGPT" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/MetaGPT/"/>
    
    
  </entry>
  
  <entry>
    <title>RAG 的 PostRetrieval 优化之 Selection</title>
    <link href="https://www.shaogui.life/posts/341085813.html"/>
    <id>https://www.shaogui.life/posts/341085813.html</id>
    <published>2024-12-05T02:14:39.000Z</published>
    <updated>2025-01-19T06:22:14.275Z</updated>
    
    <content type="html"><![CDATA[<ul><li></li></ul><span id="more"></span><p>CRAG 引入了一个轻量级检索评估器，用于评估检索到的文档的整体质量，提供触发不同知识检索操作（如 “正确”、“不正确” 或 “模糊”）的置信度。CRAG 还可以通过合并 Web 搜索来确定检索到的结果是否相关，从而解决静态语料库中的限制</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/Selection-20250116093147.png" alt="Selection-20250116093147"></p><p>指具有自我查询能力的检索器。具体而言，给定任何自然语言查询，检索器使用查询构造的 LLM 链来编写结构化查询，然后将该结构化查询应用于其底层的 VectorStore。这使得检索器不仅可以将用户输入的查询用于与存储文档内容的语义相似性比较，<strong>还可以从用户查询中提取存储文档的元数据过滤器并执行这些过滤器</strong></p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/%E8%87%AA%E6%9F%A5%E8%AF%A2selfQuery-20241216135424.png" alt="自查询selfQuery-20241216135424"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="RAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/"/>
    
    <category term="NextRAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/NextRAG/"/>
    
    
  </entry>
  
  <entry>
    <title>RAG 的 Orchestration 优化之 Scheduling</title>
    <link href="https://www.shaogui.life/posts/2999851046.html"/>
    <id>https://www.shaogui.life/posts/2999851046.html</id>
    <published>2024-12-03T01:28:47.000Z</published>
    <updated>2025-01-18T10:54:21.368Z</updated>
    
    <content type="html"><![CDATA[<p>随着 RAG 系统的复杂性和适应性的提升，调度模块能够有效地管理整个流程。它在模块化 RAG 系统中发挥着关键作用，帮助识别需要外部数据检索的关键时刻，评估生成结果的质量，并决定是否需要进一步的处理。调度模块常用于递归、迭代和自适应检索场景，确保系统能够在合适的时机停止生成或启动新的检索过程</p><span id="more"></span><h3 id="scheduling-rulejudge"><a class="markdownIt-Anchor" href="#scheduling-rulejudge"></a> Scheduling-RuleJudge</h3><p>后续步骤由一组预设规则控制。通常，系统通过评分机制评估生成的答案质量，是否继续或停止生成取决于这些分数是否超过了预定的阈值，阈值通常与单个 token 的置信度相关</p><h3 id="scheduling-llmjudge"><a class="markdownIt-Anchor" href="#scheduling-llmjudge"></a> Scheduling-LLMJudge</h3><p>LLM 能够独立判断后续操作的流程。有两种主要方法可以实现这一能力。第一种方法利用 LLM 的上下文学习能力，通过提示工程来判断是否继续。这种方法的优势在于无需对模型进行微调，然而其判断结果取决于 LLM 是否严格遵循所提供的指令。</p><p>第二种方法通过微调 LLM，使其生成特定的 token 来触发操作。这一技术来源于 <strong>Toolformer</strong>，并已集成到 <strong>Self-RAG</strong> 等框架中。此方法能够更直接地控制 LLM 的行为，提高其对特定对话上下文触发条件的响应能力。然而，这需要大量符合指令集的微调数据</p><h3 id="scheduling-knowledgeguide"><a class="markdownIt-Anchor" href="#scheduling-knowledgeguide"></a> Scheduling-KnowledgeGuide</h3><p>除了规则判断和完全依赖 LLM 控制的方式之外，知识引导调度是一种更灵活的中间方法。它利用知识图谱引导检索和生成流程，具体做法是从知识图谱中提取与问题相关的信息并构建推理链。推理链由一系列逻辑相关的节点组成，每个节点提供解决问题的关键信息。基于这些节点的信息，可以分别执行检索和内容生成。这种方法不仅提高了问题解决的效率和准确性，还使生成的解释更加清晰</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着 RAG 系统的复杂性和适应性的提升，调度模块能够有效地管理整个流程。它在模块化 RAG 系统中发挥着关键作用，帮助识别需要外部数据检索的关键时刻，评估生成结果的质量，并决定是否需要进一步的处理。调度模块常用于递归、迭代和自适应检索场景，确保系统能够在合适的时机停止生成或启动新的检索过程&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="RAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/"/>
    
    <category term="NextRAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/NextRAG/"/>
    
    
  </entry>
  
  <entry>
    <title>RAG 的 Orchestration 优化之 Routing</title>
    <link href="https://www.shaogui.life/posts/1782939751.html"/>
    <id>https://www.shaogui.life/posts/1782939751.html</id>
    <published>2024-11-28T04:34:36.000Z</published>
    <updated>2025-01-18T10:54:21.368Z</updated>
    
    <content type="html"><![CDATA[<p>根据不同查询将其路由到特定处理管道，这是适应多场景 RAG 架构的关键功能。需要决策机制来确定将使用哪些模块，依据模型输入或元数据信息进行选择。不同提示或组件有不同的路由机制</p><span id="more"></span><p>查询路由涉及将不同类型的查询定向到系统中最合适的检索或生成模块。这种方法可确保每个查询都由最合适的算法或数据源处理，从而优化准确性和效率</p><p>举个例子：当用户希望得到一个不涉及统计、关系的答案时，使用向量检索即可，当用户希望对结果进行统计时，使用数据库检索</p><p>此选择过程由 LLM 指导，LLM 会设置结果的格式以正确路由查询。在更复杂的场景中，路由可能会扩展到子链或其他代理，如 Multi-Documents Agent 模型所示</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/Routing-20250116094714.png" alt="Routing-20250116094714"></p><h3 id="metadatarouting"><a class="markdownIt-Anchor" href="#metadatarouting"></a> MetadataRouting</h3><p>从查询中提取关键术语或实体，并结合块中的元数据优化路由</p><h3 id="semanticrouting"><a class="markdownIt-Anchor" href="#semanticrouting"></a> SemanticRouting</h3><p>根据查询的语义信息，将其路由到不同的模块。</p><h3 id="hybridrouting"><a class="markdownIt-Anchor" href="#hybridrouting"></a> HybridRouting</h3><p>结合语义分析和基于元数据的路由方法，以改进查询路由</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据不同查询将其路由到特定处理管道，这是适应多场景 RAG 架构的关键功能。需要决策机制来确定将使用哪些模块，依据模型输入或元数据信息进行选择。不同提示或组件有不同的路由机制&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="RAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/"/>
    
    <category term="NextRAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/NextRAG/"/>
    
    
  </entry>
  
  <entry>
    <title>RAG 的检索优化之 RetrievalSelection</title>
    <link href="https://www.shaogui.life/posts/2262543740.html"/>
    <id>https://www.shaogui.life/posts/2262543740.html</id>
    <published>2024-11-22T04:40:12.000Z</published>
    <updated>2025-01-18T10:54:21.366Z</updated>
    
    <content type="html"><![CDATA[<p>检索的目的是找到能准确回答 query 的相关 chunks，目前有不同的方法去做到这一点，比如关键词、向量等</p><span id="more"></span><h3 id="sparseretrieval"><a class="markdownIt-Anchor" href="#sparseretrieval"></a> SparseRetrieval</h3><p>基于词汇的稀疏检索，如稀疏检测模型 BM 25，TF-IDF 等</p><h3 id="denseretrieval"><a class="markdownIt-Anchor" href="#denseretrieval"></a> DenseRetrieval</h3><p>基于 embedding 的稠密检索，使用余弦相似度、欧氏距离等指标评估文本相似度</p><h3 id="hybridretriever"><a class="markdownIt-Anchor" href="#hybridretriever"></a> HybridRetriever</h3><p>混合搜索将传统的基于关键字的搜索与语义搜索技术相结合。在这种技术中，您可以同时创建 keyword 索引和 vector-embeddings 索引。执行搜索时，它会同时执行关键字搜索和语义搜索来检索结果。最终结果使用 reranker 模型进行排名，该模型对它们与用户查询的相关性进行评分</p><p>这种方法提高了相关性，提高了覆盖率，并为各种查询类型提供了灵活性。混合搜索在具有严格词汇表的域中特别有用。例如，在医疗保健领域，医生经常使用 “COPD” 等缩写来表示慢性阻塞性肺病，或 “HTN” 表示高血压。在这种情况下，语义搜索可能会错过带有缩写的结果，而关键字搜索可以帮助捕获这些结果</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/RetrievalSelection-20250116092354.png" alt="RetrievalSelection-20250116092354"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;检索的目的是找到能准确回答 query 的相关 chunks，目前有不同的方法去做到这一点，比如关键词、向量等&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="RAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/"/>
    
    <category term="NextRAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/NextRAG/"/>
    
    
  </entry>
  
  <entry>
    <title>RAG 的 PostRetrieval 优化之 Rerank</title>
    <link href="https://www.shaogui.life/posts/141281180.html"/>
    <id>https://www.shaogui.life/posts/141281180.html</id>
    <published>2024-11-18T07:36:21.000Z</published>
    <updated>2025-01-18T10:54:21.366Z</updated>
    
    <content type="html"><![CDATA[<p>重新排名是检索增强生成 （RAG） 中最常用的技术之一，在从数据库中检索数据后应用。在此方法中，检索到的数据使用 reranker 模型重新排名，该模型根据文档与查询的相关性对文档进行排序</p><span id="more"></span><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/%E6%A3%80%E7%B4%A2%E7%BB%93%E6%9E%9C%E9%87%8D%E6%8E%92%E5%BA%8FRerank-20241216135816.png" alt="检索结果重排序Rerank-20241216135816"></p><h3 id="rerank-rulebase"><a class="markdownIt-Anchor" href="#rerank-rulebase"></a> ReRank-Rulebase</h3><p>计算指标以重新排列块根据某些规则。常见的指标包括：多样性，相关性和 MRR（最大边际相关性）。</p><p>这个其想法是减少冗余并增加结果多样性。MMR 根据以下条件为最终关键短语列表选择短语查询相关性和信息新颖性相结合的标准。</p><h3 id="rerank-modelbase"><a class="markdownIt-Anchor" href="#rerank-modelbase"></a> ReRank-Modelbase</h3><p>Reranker 模型（例如 Cohere 的 Rerank 3）是专门的 AI 模型，用于评估这些检索到的文档与用户查询相关的相关性并确定其优先级。这些模型对较小的候选文档集进行操作，侧重于根据查询和文档的上下文微调排名。通常在包含相关和不相关文档示例的数据集上进行训练，reranker 可以有效地区分高质量的结果和不太相关的结果</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;重新排名是检索增强生成 （RAG） 中最常用的技术之一，在从数据库中检索数据后应用。在此方法中，检索到的数据使用 reranker 模型重新排名，该模型根据文档与查询的相关性对文档进行排序&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="RAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/"/>
    
    <category term="NextRAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/NextRAG/"/>
    
    
  </entry>
  
  <entry>
    <title>RAG 的预检索 PreRetrieval 优化之 QueryTrasformation</title>
    <link href="https://www.shaogui.life/posts/245956733.html"/>
    <id>https://www.shaogui.life/posts/245956733.html</id>
    <published>2024-11-18T04:36:21.000Z</published>
    <updated>2025-01-18T10:54:21.366Z</updated>
    
    <content type="html"><![CDATA[<p>与 QueryExpansion 不同，QueryTrasformation 的目的是基于原始 prompt 生成新的 prompt，使用新的 prompt 去检索知识库</p><p>这个转换的原因是原始 prompt 可能存在字符紊乱、错别字问题</p><span id="more"></span><h3 id="重写rewrite"><a class="markdownIt-Anchor" href="#重写rewrite"></a> 重写 Rewrite</h3><p>将用户的查询重构为 LLM 更容易理解且检索器更容易使用的格式。在这里，您首先通过微调的语言模型处理用户查询，以优化和构建它。如图所示，提问中经常涉及：文字语序错乱、同义词替换等问题，直接去向量数据库检索，提取的内容有问题，因此在正式检索前，先使用 llm 优化问题</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/QueryTrasformation-20250116091707.png" alt="QueryTrasformation-20250116091707"></p><h3 id="hyde"><a class="markdownIt-Anchor" href="#hyde"></a> HyDE</h3><p>HyDE&nbsp;技术与前面描述的假设问题索引方法相反，该技术首先使用 llm 回答用户查询，然后使用答案在数据库实现检索，以在存储中获取最佳匹配数据。</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/QueryTrasformation-20250116091707-1.png" alt="QueryTrasformation-20250116091707-1"></p><h3 id="step-backprompt"><a class="markdownIt-Anchor" href="#step-backprompt"></a> Step-BackPrompt</h3><p>原始查询被抽象转化为高级概念问题（后退问题）。在 RAG 系统，包括退一步问题和原始问题查询用于检索，它们的结果被组合在一起生成语言模型的答案。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;与 QueryExpansion 不同，QueryTrasformation 的目的是基于原始 prompt 生成新的 prompt，使用新的 prompt 去检索知识库&lt;/p&gt;
&lt;p&gt;这个转换的原因是原始 prompt 可能存在字符紊乱、错别字问题&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="RAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/"/>
    
    <category term="NextRAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/NextRAG/"/>
    
    
  </entry>
  
  <entry>
    <title>利用 langchian 搭建通用的表格数据分析工具</title>
    <link href="https://www.shaogui.life/posts/2088963120.html"/>
    <id>https://www.shaogui.life/posts/2088963120.html</id>
    <published>2024-11-17T19:50:17.000Z</published>
    <updated>2025-01-19T06:20:48.256Z</updated>
    
    <content type="html"><![CDATA[<p>基于 RAG 搭建表格问答系统</p><span id="more"></span><h2 id="场景描述及解决思路"><a class="markdownIt-Anchor" href="#场景描述及解决思路"></a> 场景描述及解决思路</h2><p>与 RAG 类似，但是 RAG 无法解决少量提示词的问题，比如：</p><blockquote><ol><li>2019 年 7 月一共出现多少次异常？</li><li>张三一共解决多少个问题？</li><li>2019 年 10 月 1 日的异常是谁解决的？</li></ol></blockquote><p>诸如此类，涉及时间、人物的精确查询，RAG 过程很难精确检索到，鉴于此，本文基于 langchain 实现针对表格的通用数据分析应用，其架构如下：</p><p><img data-src="https://picgo-1304919305.cos.ap-guangzhou.myqcloud.com/picGo/Drawing-2024-11-14-13.55.10.excalidraw.png" alt="Drawing-2024-11-14-13.55.10.excalidraw"><br>首先使用 LLM 对提问进行分类，一共分两类：普通查询、精确查询，普通查询是 RAG 过程，精确查询首先通过 LLM 生成查询命令，如 pandas 命令，然后执行命令拿到结果</p><h2 id="关键代码分析"><a class="markdownIt-Anchor" href="#关键代码分析"></a> 关键代码分析</h2><p><strong>分类 LLM</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class_prompt=ChatPromptTemplate.from_template(<span class="string">"""你是一名问题归类员，你的任务识别以下由三个引号包含的问题，然后将其分类为：“普通查询”、“精准查询”，当提问涉及准确的时间、地点、人物时，归类为精准查询，否则归类为普通查询。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">直接输出“普通查询”、“精准查询”之一，不要输出其他任何信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">问题：```{question}``` &nbsp;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span>)</span><br><span class="line"></span><br><span class="line">class_chain=class_prompt|llm|StrOutputParser()</span><br></pre></td></tr></tbody></table></figure><p><strong>RAG 查询</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">rag_prompt=PromptTemplate.from_template(</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># 角色</span></span><br><span class="line"><span class="string">你是一个严格的根据上下文生成回答的回答者，请根据以下由三个单引号包含的上下文回答问题，注意回答内容必须来自上下文，不能输出上下文不包含的内容，最后使用表格输出</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 技能</span></span><br><span class="line"><span class="string">1. 分析用户问题</span></span><br><span class="line"><span class="string">2. 根据上下文回答用户问题</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 技能1</span></span><br><span class="line"><span class="string">1. 根据提问检索到关联的上下文</span></span><br><span class="line"><span class="string">2. 将关联上下文直接以表格的形式输出，不作任何改变</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 技能2</span></span><br><span class="line"><span class="string">1. 分析提问及关联的上下文，给出最终答案</span></span><br><span class="line"><span class="string">2. 答案以列表输出，并使用加粗优化输出</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 要求</span></span><br><span class="line"><span class="string">1. 回答内容必须来自上下文，不得输出上下文不存在的内容</span></span><br><span class="line"><span class="string">2. 如果提问没有涉及的上下文，回答"知识库无法检索到该内容"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上下文：'''{context}'''</span></span><br><span class="line"><span class="string">问题：{question}</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">format_docs</span>(<span class="params">docs</span>):</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> <span class="string">"\n\n"</span>.join(doc.page_content <span class="keyword">for</span> doc <span class="keyword">in</span> docs)</span><br><span class="line"></span><br><span class="line">rag_chain = {<span class="string">"context"</span>: itemgetter(<span class="string">"question"</span>)|vectordb.as_retriever(search_kwargs={<span class="string">'k'</span>: <span class="number">4</span>, <span class="string">'lambda_mult'</span>: <span class="number">0.25</span>})|format_docs, <span class="string">"question"</span>: RunnablePassthrough()} \</span><br><span class="line">&nbsp; &nbsp; |rag_prompt \</span><br><span class="line">&nbsp; &nbsp; | llm \</span><br><span class="line">&nbsp; &nbsp; | StrOutputParser()</span><br></pre></td></tr></tbody></table></figure><p><strong>精确查询</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先，构造一个提示模版字符串：`template_string`</span></span><br><span class="line">system_string=<span class="string">"你正在使用pandas处理DataFrame，请根据三个引号分隔的问题输出pandas命令，其中`print(df.head())`的结果如下:\n"</span></span><br><span class="line"></span><br><span class="line">system_string+=df.head().to_markdown()+<span class="string">"\n"</span></span><br><span class="line">system_string+= <span class="string">"如果不清楚使用哪一列过滤结果，请使用“现象描述、异常分析，解决方案”三列检索内容是否出现\n"</span></span><br><span class="line">system_string+= <span class="string">"不要转换提问的文字，比如提问：相机标定不成功如何解决的？直接用'相机标定不成功'检索，而不是用'视觉'\n"</span></span><br><span class="line">system_string+= <span class="string">"请使用1行代码完成需求\n"</span></span><br><span class="line">system_string+= <span class="string">"只输出代码，不要输出其他任何信息，也不能写任何注释\n"</span></span><br><span class="line">system_string+= <span class="string">"确保代码可运行\n"</span></span><br><span class="line"></span><br><span class="line">sql_prompt = ChatPromptTemplate.from_messages([(<span class="string">"system"</span>, system_string), (<span class="string">"human"</span>, <span class="string">"'''{question}'''"</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改pandas命令</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_sanitize_output</span>(<span class="params">pandas_cmd: <span class="built_in">str</span></span>):</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">if</span> pandas_cmd[-<span class="number">1</span>]==<span class="string">']'</span>:</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; ss,match_end=find_matching_bracket(pandas_cmd)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; pandas_cmd=pandas_cmd[ss-<span class="number">2</span>:match_end+<span class="number">1</span>]</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; pandas_cmd+=<span class="string">'.to_markdown()'</span></span><br><span class="line">&nbsp; &nbsp; pandas_cmd=<span class="string">"print("</span>+pandas_cmd+<span class="string">")"</span></span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> pandas_cmd</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 统计sql找到记录的数量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postprocess</span>(<span class="params">sql_result</span>):</span><br><span class="line">&nbsp; &nbsp; row=sql_result.count(<span class="string">'\n'</span>)-<span class="number">2</span> <span class="comment"># 除去表头及分隔</span></span><br><span class="line">&nbsp; &nbsp; append_text=<span class="string">"根据以上找到的信息，统计出现{}条记录。"</span>.<span class="built_in">format</span>(row)</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> sql_result+<span class="string">'\n'</span>+append_text</span><br><span class="line"></span><br><span class="line">sql_chain = sql_prompt | llm | StrOutputParser() |_sanitize_output </span><br><span class="line">| PythonREPL(_<span class="built_in">globals</span>=<span class="built_in">globals</span>(), _<span class="built_in">locals</span>=<span class="literal">None</span>).run </span><br><span class="line">| postprocess</span><br></pre></td></tr></tbody></table></figure><p><strong>合并所有过程</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义路由</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">route</span>(<span class="params">info</span>):</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">if</span> <span class="string">"精准查询"</span> <span class="keyword">in</span> info[<span class="string">"class"</span>]:</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">return</span> sql_chain</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">elif</span> <span class="string">"普通查询"</span> <span class="keyword">in</span> info[<span class="string">"class"</span>]:</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">return</span> rag_chain</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">else</span>:</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">return</span> rag_chain</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_core.runnables <span class="keyword">import</span> RunnableLambda</span><br><span class="line">full_chain={<span class="string">"class"</span>:class_chain,<span class="string">"question"</span>:RunnablePassthrough()}\</span><br><span class="line">|RunnableLambda(route)</span><br><span class="line"></span><br><span class="line">response = full_chain.invoke(message)</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于 RAG 搭建表格问答系统&lt;/p&gt;</summary>
    
    
    
    <category term="2-深度学习" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="LLM开发工程师指南" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/"/>
    
    <category term="RAG" scheme="https://www.shaogui.life/categories/2-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/LLM%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8C%87%E5%8D%97/RAG/"/>
    
    
  </entry>
  
</feed>
